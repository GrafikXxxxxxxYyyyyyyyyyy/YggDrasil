# TODO 04: Уровень пайплайна (Pipeline) — полная реализация

Технически полный и всеобъемлющий TODO по **реализации уровня пайплайна** (4-й уровень): пайплайн как «граф графов», структура данных, построение, валидация, исполнитель, сериализация (конфиг + веса), загрузка из чекпоинта, обучение, конфиг и шаблоны, multi-endpoint и связь с этапом и миром. Учтены вся база проекта (фундамент, узлы-задачи, графовый движок), [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md), [TRAINABILITY_AT_ALL_LEVELS.md](TRAINABILITY_AT_ALL_LEVELS.md), [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md), [World_Serialization.md](World_Serialization.md).

**Канон:** [Pipeline_Level.md](Pipeline_Level.md), [Graph_Level.md](Graph_Level.md), [Stage_Level.md](Stage_Level.md). Предшествующие уровни: [TODO_01_FOUNDATION.md](TODO_01_FOUNDATION.md), [TODO_02_TASK_NODES_AND_GRAPH.md](TODO_02_TASK_NODES_AND_GRAPH.md), [TODO_03_GRAPH_ENGINE.md](TODO_03_GRAPH_ENGINE.md).

**Границы этого TODO:** пайплайн — **граф, узлами которого являются целые графы** (один граф = одна задача); рёбра пайплайна соединяют **внешние выходы одного графа с внешними входами другого**; выполнение — по топологии, вызов `run(graph, inputs)` для каждого графа-узла; сериализация пайплайна = структура + агрегация чекпоинтов графов; загрузка из чекпоинта; обучение выбранных графов в пайплайне; конфиг и шаблоны; контракт пайплайна для этапа и multi-endpoint.

---

## Зависимости от предыдущих уровней

| Компонент | Откуда берётся | Как используется пайплайном |
|-----------|----------------|-----------------------------|
| **Граф (Graph)** | TODO_03 | Узел пайплайна = целый граф. Пайплайн хранит отображение `pipeline_node_id → Graph`. Выполнение узла = `graph.run(inputs)`; контракт графа (get_input_spec, get_output_spec) задаёт порты для рёбер пайплайна. |
| **Контракт графа** | TODO_03, Graph_Level | Входы/выходы графа (имена и типы портов). Рёбра пайплайна связывают (source_graph_id, source_port) с (target_graph_id, target_port); при добавлении ребра проверяется совместимость типов по контрактам графов. |
| **Сериализация графа** | TODO_03 | Конфиг графа (nodes, edges, exposed_inputs/outputs); чекпоинт графа (веса всех узлов). Конфиг пайплайна содержит конфиги графов (вложенные или ссылки); чекпоинт пайплайна = совокупность чекпоинтов графов. |
| **Загрузка графа из чекпоинта** | TODO_03 | При загрузке пайплайна из чекпоинта для каждого графа-узла вызывается загрузка структуры (from_config) и весов (load_from_checkpoint). |
| **Обучаемость графа** | TODO_03, TRAINABILITY | Пайплайн может помечать подмножество графов как trainable; при обучении пайплайна forward/backward проходят по топологии, оптимизатор получает параметры только выбранных графов. |
| **Блок, узел, порты** | TODO_01, TODO_02 | Внутри графов; пайплайн с графами не работает напрямую с блоками — только с графами как чёрными ящиками. |

Без реализованного графового движка (TODO_03) пайплайн не может ни хранить графы, ни выполнять их, ни сериализовать/загружать; при реализации пайплайна предполагается, что граф имеет стабильный контракт и API run/save/load.

---

## 1. Структура данных пайплайна

### 1.1 Что реализовать

- [ ] **Пайплайн (Pipeline)** — контейнер с: (1) **узлы:** отображение `pipeline_node_id: str → Graph` (каждый узел — целый граф одной задачи); (2) **рёбра пайплайна:** список рёбер вида `(source_node_id, source_port, target_node_id, target_port)`, где порты — **внешние** порты графов (имена из контракта графа); (3) **внешний контракт пайплайна:** списки внешних входов и выходов пайплайна — каждый элемент привязан к `(pipeline_node_id, port_name)` графа и опционально имеет логическое имя для вызова run; (4) идентификатор пайплайна `pipeline_id` и метаданные (версия схемы, описание).
- [ ] **Инварианты:** каждый pipeline_node_id в рёбрах присутствует в узлах; source_port и target_port — имена из get_output_spec(source_graph) и get_input_spec(target_graph) соответственно; типы портов на концах ребра совместимы. Внешние входы пайплайна — порты графов, не имеющие входящего ребра от другого графа (или явно помеченные); внешние выходы — порты графов, помеченные как выходы пайплайна (или не имеющие исходящего ребра к другому графу).
- [ ] **Индексы:** по pipeline_node_id быстро получать входящие и исходящие рёбра пайплайна (in_edges[node_id], out_edges[node_id]) для исполнителя и валидации.

### 1.2 Вырожденный случай: пайплайн из одного графа

- [ ] Пайплайн может состоять из **одного узла** (одного графа). Рёбер между графами нет; внешние входы/выходы пайплайна = внешние входы/выходы этого графа. Выполнение: один вызов run(graph, inputs). Это даёт единый интерфейс «пайплайн» для одной задачи и совместимость с уровнем этапа (этап = граф пайплайнов; узел этапа может быть пайплайном из одного графа). Связь с [Pipeline_Level.md](Pipeline_Level.md) §2–3.

### 1.3 Критерии

- [ ] По пайплайну однозначно определены множество графов-узлов, множество рёбер пайплайна и список внешних входов/выходов пайплайна; запрос входящих/исходящих рёбер по pipeline_node_id выполняется без полного перебора.

---

## 2. API построения пайплайна (Pipeline Builder)

### 2.1 Добавление графа как узла

- [ ] **AddGraph(graph_or_config, pipeline_node_id=None):**
  - **Вариант A:** `graph_or_config` — экземпляр Graph (уже собранный граф). Тогда `pipeline_node_id` обязателен или генерируется (например, graph.graph_id или `"graph_" + str(len(nodes))`). Узел пайплайна = этот граф; контракт берётся из графа (get_input_spec, get_output_spec).
  - **Вариант B:** `graph_or_config` — словарь конфига графа (или путь к YAML/JSON). Граф создаётся через `Graph.from_config(config)`; pipeline_node_id задаётся или из конфига (graph_id), или генерируется. Узел пайплайна = созданный граф.
  - **Уникальность pipeline_node_id:** при добавлении проверять, что идентификатор не занят; иначе ошибка или генерация уникального.
- [ ] **Связь с проектом:** граф — единственная исполняемая единица внутри пайплайна; пайплайн не создаёт графы «из блоков», только принимает готовый граф или собирает его из конфига (делегируя Graph.from_config).

### 2.2 Добавление ребра пайплайна

- [ ] **AddEdge(source_node_id, source_port, target_node_id, target_port):**
  - Проверить: source_node_id и target_node_id есть в пайплайне (это идентификаторы графов-узлов). source_port — имя из **внешних выходов** графа source_node_id (get_output_spec); target_port — имя из **внешних входов** графа target_node_id (get_input_spec). Типы портов совместимы (по правилам из контрактов графов). При множественных входящих рёбрах на один вход графа — только если контракт графа допускает несколько источников (агрегация).
  - Добавить ребро в список рёбер пайплайна; обновить индексы in_edges/out_edges.
- [ ] **Связь с Stage:** этап на своём уровне делает то же — рёбра между пайплайнами по внешним портам пайплайнов; контракт пайплайна аналогичен контракту графа.

### 2.3 Внешние входы и выходы пайплайна

- [ ] **expose_input(pipeline_node_id, port_name, name=None):** пометить внешний вход графа (узла пайплайна) как внешний вход пайплайна. name — логическое имя для вызова run(pipeline, inputs={name: value}); если не задан — использовать `(pipeline_node_id, port_name)` или сгенерировать. Записать в _exposed_inputs.
- [ ] **expose_output(pipeline_node_id, port_name, name=None):** пометить внешний выход графа как внешний выход пайплайна; name — ключ в возвращаемом словаре outputs. Записать в _exposed_outputs.
- [ ] **Автовывод (опционально):** метод infer_exposed_ports(): внешний вход пайплайна = внешние входы графов, не имеющие входящего ребра от другого графа; внешний выход = внешние выходы графов, не имеющие исходящего ребра к другому графу. Использовать только если пользователь не задал expose_input/expose_output явно.
- [ ] **Контракт пайплайна:** get_input_spec() и get_output_spec() пайплайна — списки имён (и типов, если доступны) для вызова run и для соединения пайплайна как узла этапа. Связь с [Stage_Level.md](Stage_Level.md), [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md).

### 2.4 Критерии приёмки (Builder)

- [ ] Пайплайн можно собрать программно: AddGraph (граф или конфиг) и AddEdge между внешними портами графов; expose_input/expose_output для контракта пайплайна. Уникальность pipeline_node_id; валидация портов и типов при AddEdge.

---

## 3. Валидация пайплайна

### 3.1 При добавлении ребра

- [ ] Существование source_node_id и target_node_id; source_port в get_output_spec(source_graph), target_port в get_input_spec(target_graph); совместимость типов (и при необходимости shape/dtype по контракту графов).

### 3.2 Полная валидация (перед run или по запросу)

- [ ] **Топология:** граф пайплайна (вершины = графы, рёбра = рёбра пайплайна) должен быть **DAG** — циклы на уровне пайплайна не допускаются (циклы допустимы внутри графа, не между графами). При обнаружении цикла — ошибка валидации.
- [ ] **Достижимость:** каждый граф-узел достижим от хотя бы одного внешнего входа пайплайна и ведёт к внешнему выходу (или к графу, из которого достижим выход); иначе предупреждение «висячий узел».
- [ ] **Внешние входы:** каждый объявленный внешний вход пайплайна соответствует внешнему входу графа по (pipeline_node_id, port_name); при run для каждого внешнего входа будет подано значение (проверка обязательности по контракту).
- [ ] **Внутренняя валидность графов:** опционально для каждого графа-узла вызвать graph.validate(); ошибки агрегировать с указанием pipeline_node_id.
- [ ] **Связь с проектом:** валидация гарантирует, что run пайплайна не упрётся в отсутствующие входы или циклы между графами; этап при выполнении полагается на валидный пайплайн.

### 3.3 Реализация

- [ ] Метод `Pipeline.validate(strict=True) -> ValidationResult`: перечень проверок; при strict=False только предупреждения. ValidationResult — список ошибок и предупреждений с указанием узла/порта/ребра.

---

## 4. Исполнитель пайплайна (Executor)

### 4.1 Топологический порядок

- [ ] Пайплайн — DAG; вычислить **топологическую сортировку** графов-узлов (источники сначала, затем узлы, у которых все предки уже выполнены). Порядок выполнения = этот топологический порядок.
- [ ] **Буфер (cache):** ключ — пара (pipeline_node_id, port_name) для внешних выходов графов; значение — результат, возвращённый графом по этому порту. Внешние входы пайплайна при run подаются в буфер под ключами, соответствующими внешним входам (привязка к (pipeline_node_id, port_name)). При выполнении графа G: собрать входы для G из буфера по входящим рёбрам пайплайна (для каждого ребра с target_node_id=G взять значение из буфера по (source_node_id, source_port)); вызвать `graph.run(inputs)`; записать выходы G в буфер по (pipeline_node_id, port_name) для каждого внешнего выхода G.
- [ ] **Сигнатура run:** `run(pipeline, inputs, *, training=False, device=None, callbacks=None, **graph_run_kwargs) -> outputs`. inputs — словарь по внешним входам пайплайна; training — передаётся в каждый graph.run(..., training=training); device и graph_run_kwargs (например, num_loop_steps) пробрасываются в графы; callbacks — опционально хуки на начало/конец выполнения каждого графа-узла; outputs — словарь по внешним выходам пайплайна (значения из буфера после выполнения всех графов).

### 4.2 Передача данных между графами

- [ ] В одном процессе данные между графами передаются **в памяти** (буфер): выход одного run(graph) попадает в буфер и подаётся на вход следующего графа. Сериализация на границе не обязательна при локальном выполнении.
- [ ] При **распределённом выполнении** (multi-endpoint): узел пайплайна может быть помечен как remote (endpoint_url); тогда вместо локального graph.run() исполнитель выполняет запрос к эндпоинту (HTTP/gRPC), передаёт сериализованные входы и получает сериализованные выходы; буфер хранит результат для следующих узлов. Формат сериализации (JSON, бинарные артефакты по контракту портов) — см. п. 9. Связь с [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md).

### 4.3 Критерии приёмки (Executor)

- [ ] Исполнитель по пайплайну и inputs выполняет графы в топологическом порядке; данные передаются по рёбрам пайплайна через буфер; внешние выходы собираются и возвращаются. Поддержка training, device, callbacks и проброс kwargs в графы. Документированное поведение при опциональных входах графа.

---

## 5. Сериализация пайплайна (структура — конфиг)

### 5.1 Схема конфига пайплайна

- [ ] **Версия:** поле `schema_version` или `pipeline_version` для обратной совместимости.
- [ ] **Узлы (графы):** список записей; каждая запись: `pipeline_node_id`, конфиг графа. Конфиг графа — в формате из TODO_03 (nodes, edges, exposed_inputs, exposed_outputs, metadata) — **вложенный** в конфиг пайплайна или **ссылка** (`ref: path/to/graph_config.yaml`). При ссылке при загрузке пайплайна конфиг графа читается из файла.
- [ ] **Рёбра пайплайна:** список `{ source_node, source_port, target_node, target_port }`.
- [ ] **Внешние входы/выходы пайплайна:** список `{ name (опционально), pipeline_node_id, port_name }`.
- [ ] **Метаданные:** pipeline_id, description, опционально default device, endpoint_url по узлам для multi-endpoint.
- [ ] **Формат файла:** YAML или JSON; UTF-8. Имена полей зафиксированы (например, `graphs`, `edges`, `exposed_inputs`, `exposed_outputs`).

### 5.2 Сохранение и загрузка структуры

- [ ] **save_config(path)** или **to_dict():** сериализовать пайплайн в конфиг: для каждого узла — конфиг графа (graph.to_dict() или сохранённый путь при ref); рёбра; внешние порты; метаданные. Веса графов в конфиг не входят (см. п. 6).
- [ ] **load_config(path)** или **from_dict(d):** прочитать конфиг; для каждой записи узла создать граф через Graph.from_config(node_config); добавить рёбра; задать внешние входы/выходы. Получается пайплайн с графами без загруженных весов (или с дефолтными весами графов). Связь с [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md): структура пайплайна полностью восстанавливается из конфига.

### 5.3 Вложенность и ссылки

- [ ] Поддержка **вложенных конфигов графов** (всё в одном файле) и **ссылок** (ref на отдельный файл или URI). При сохранении опция: сохранять графы вложенно или выносить в отдельные файлы и сохранять ref. При загрузке разрешать ref (читать по пути или URI).

---

## 6. Сериализация весов пайплайна и загрузка из чекпоинта

### 6.1 Формат чекпоинта пайплайна

- [ ] **Веса пайплайна = совокупность весов всех графов-узлов.** Отдельного state_dict у пайплайна нет; чекпоинт пайплайна — это **агрегация чекпоинтов графов**.
- [ ] **Вариант A — каталог:** каталог `checkpoint_dir/` с подкаталогами (или файлами) по pipeline_node_id: `checkpoint_dir/<pipeline_node_id>/` содержит чекпоинт графа (формат из TODO_03 — один файл или каталог с чекпоинтами узлов графа). Плюс `pipeline_meta.json` с списком pipeline_node_id и версией.
- [ ] **Вариант B — один архив/файл:** один файл (например, .zip или .tar) с внутренней структурой `/<pipeline_node_id>/config.yaml` и `/<pipeline_node_id>/checkpoint.pt` (или аналог) для каждого графа. При загрузке распаковать и для каждого узла вызвать Graph.load_from_checkpoint(subpath).
- [ ] Выбор формата конфигурируем; документировать оба и обеспечить загрузку.

### 6.2 Сохранение весов

- [ ] **save_checkpoint(path, format="dir"|"archive"):** для каждого графа-узла вызвать graph.save_checkpoint(subpath) или graph.save(subpath) (конфиг + чекпоинт графа); при format="dir" — каталог с подкаталогами по pipeline_node_id; при format="archive" — упаковать в один файл. Сохранить метаданные пайплайна (pipeline_id, список узлов, версия).
- [ ] **Совместное сохранение:** метод `pipeline.save(save_dir)` — сохранить конфиг пайплайна в `save_dir/config.yaml` и чекпоинт в `save_dir/checkpoints/` (или один архив `save_dir/checkpoint.zip`). Полная воспроизводимость: конфиг + чекпоинты всех графов.

### 6.3 Загрузка из чекпоинта

- [ ] **load_from_checkpoint(checkpoint_path, config_path=None):** если пайплайн уже создан из конфига, загрузить веса: для каждого pipeline_node_id прочитать чекпоинт графа из соответствующего подпути и вызвать graph.load_from_checkpoint(subpath). Если передан config_path — сначала построить пайплайн из конфига (from_config), затем загрузить веса из checkpoint_path.
- [ ] **load_from_checkpoint(save_dir):** если в save_dir есть config и чекпоинт (по соглашению имён), загрузить конфиг пайплайна и чекпоинты всех графов; вернуть экземпляр Pipeline. API вида `Pipeline.load(save_dir)` или `Pipeline.load_from_checkpoint(save_dir)`.
- [ ] **Связь с [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md):** на уровне пайплайна веса сериализуются (агрегация чекпоинтов графов) и загрузка из чекпоинта реализована; этап и мир при загрузке вызывают загрузку пайплайнов-узлов, опираясь на этот контракт.

### 6.4 Версионирование

- [ ] При сохранении записывать версию схемы пайплайна и при необходимости версии форматов чекпоинтов графов. При загрузке проверять совместимость; при несовпадении — ошибка с сообщением или миграция (если реализована).

---

## 7. Обучение на уровне пайплайна

### 7.1 Выбор trainable графов

- [ ] Пайплайн задаёт, какие графы-узлы **trainable** (остальные заморожены). Конфиг: список pipeline_node_id с флагом trainable или список только trainable. При обучении пайплайна оптимизатор получает параметры только от trainable графов: для каждого такого графа вызвать graph.trainable_parameters() и объединить в один итератор.
- [ ] **Forward:** run(pipeline, inputs, training=True) выполняется по топологии; градиенты при backward (если фреймворк поддерживает) текут через графы; замороженные графы не обновляются. Связь с [TRAINABILITY_AT_ALL_LEVELS.md](TRAINABILITY_AT_ALL_LEVELS.md).
- [ ] **Чекпоинты обучения:** при сохранении в процессе обучения сохранять чекпоинт пайплайна (все графы или только trainable — по политике); после обучения полный pipeline.save() для воспроизводимости.

### 7.2 Конфиг обучения

- [ ] В конфиге пайплайна или в отдельном конфиге обучения: trainable_nodes (список pipeline_node_id), lr (глобально или по узлам), freeze_others; опционально разные lr для разных графов. Сериализуемость конфига обучения для воспроизводимости экспериментов.

### 7.3 Критерии приёмки (обучение)

- [ ] Можно задать подмножество графов пайплайна как trainable; run(..., training=True) и backward по loss на выходе пайплайна обновляют только выбранные графы; чекпоинт пайплайна сохраняет веса всех графов и загружается корректно.

---

## 8. Конфиг и шаблоны пайплайна

### 8.1 From_config

- [ ] **Pipeline.from_config(config)** или **Pipeline.from_yaml(path):** config — словарь с полями graphs (узлы с конфигами графов), edges, exposed_inputs, exposed_outputs, metadata. Для каждого элемента graphs: Graph.from_config(node_config), узел с pipeline_node_id; добавить рёбра; установить внешние входы/выходы. Валидация после сборки (опционально). Возврат экземпляра Pipeline.
- [ ] **Разрешение ref:** при конфиге графа вида `ref: path/to/graph.yaml` загрузить конфиг графа из файла и затем Graph.from_config(loaded).

### 8.2 From_template

- [ ] **Pipeline.from_template(template_name, **kwargs):** шаблон — именованная функция или конфиг-генератор, возвращающий конфиг пайплайна (словарь в формате п. 5). Параметры kwargs подставляются в шаблон (например, список графов, порядок, разрешения, имена). Реализация: получить конфиг из шаблона, подставить kwargs, вызвать Pipeline.from_config(config). Шаблоны регистрируются (например, "text_to_video", "generate_and_upscale"); документировать доступные шаблоны и параметры.
- [ ] **Связь с проектом:** этап и мир могут использовать те же механизмы шаблонов для пайплайнов; [World_Serialization.md](World_Serialization.md) задаёт аналогичную логику для мира.

### 8.3 Валидация после загрузки

- [ ] После from_config вызывать pipeline.validate(); при ошибках возвращать понятное сообщение с указанием pipeline_node_id и порта. Подсказки при отсутствующем графе или несовместимых типах портов.

---

## 9. Multi-endpoint: пайплайн с удалёнными графами

### 9.1 Реестр эндпоинтов

- [ ] В конфиге пайплайна для каждого графа-узла можно задать **локальный** граф (конфиг + чекпоинт) или **удалённый** эндпоинт: `endpoint_url: "https://..."` (или gRPC). При загрузке пайплайна: если endpoint_url задан, узел пайплайна хранит не экземпляр Graph, а **дескриптор удалённого сервиса** (URL, контракт вход/выход); при run исполнитель вызывает удалённый API вместо локального graph.run(). Связь с [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md).
- [ ] **Контракт удалённого графа:** тот же, что у графа — имена и типы входов/выходов; сериализация запроса/ответа (JSON для метаданных, бинарные или base64 для тензоров/изображений по соглашению). Пайплайн-оркестратор сериализует входы из буфера, отправляет запрос, десериализует выходы и кладёт в буфер.

### 9.2 Гибридный режим

- [ ] Часть узлов пайплайна — локальные графы, часть — удалённые. Порядок выполнения и буфер те же; различие только в способе вызова (локальный run vs HTTP/gRPC). Поведение системы эквивалентно полностью локальному запуску при корректных контрактах и сериализации.

### 9.3 Критерии приёмки (multi-endpoint)

- [ ] В конфиге пайплайна можно указать endpoint_url для выбранных узлов; при run эти узлы выполняются запросом к эндпоинту; данные между узлами передаются через буфер после десериализации. Документировать формат API эндпоинта (входы/выходы по контракту графа).

---

## 10. Связь с этапом и миром

### 10.1 Пайплайн как узел этапа

- [ ] **Этап (Stage)** — граф пайплайнов ([Stage_Level.md](Stage_Level.md)). Узел этапа = пайплайн (в т.ч. из одного графа). Контракт пайплайна (get_input_spec, get_output_spec) используется этапом для соединения рёбер этапа: выход одного пайплайна → вход другого. Реализация этапа (отдельный TODO) будет вызывать pipeline.run(inputs) для каждого узла-пайплайна и передавать state по рёбрам этапа.
- [ ] **Сериализация этапа:** конфиг этапа содержит конфиги пайплайнов (вложенные или ref); чекпоинт этапа = чекпоинты пайплайнов. Пайплайн должен быть полностью сериализуем и загружаем из чекпоинта, чтобы этап мог сохранять и восстанавливать себя.

### 10.2 State и мир

- [ ] На уровне этапа между пайплайнами передаётся **state** (или данные в формате state). Пайплайн не обязан знать про «пять блоков» мира — он оперирует своими входами/выходами; этап мапит state на входы пайплайна и выходы пайплайна на state. Контракт пайплайна достаточен для этого маппинга. Связь с [Scheme.md](Scheme.md), [World_Level.md](World_Level.md).

### 10.3 Документирование контракта

- [ ] Явно описать: входной и выходной контракт пайплайна (имена и типы), чтобы этап и оркестраторы могли подключать пайплайны без знания внутренней структуры графов. get_input_spec(), get_output_spec() возвращают структурированное описание (список пар имя/тип).

---

## 11. Дополнительные требования

### 11.1 Устройство и опции выполнения

- [ ] **to(device):** перенос всех графов-узлов на заданное устройство (вызов graph.to(device) для каждого графа). При run опционально передавать device в graph_run_kwargs.
- [ ] **Проброс опций:** run(pipeline, inputs, **kwargs) — неизвестные kwargs пробрасывать в каждый graph.run(..., **kwargs) (например, num_loop_steps, seed).

### 11.2 Хуки и отладка

- [ ] **Регистрация хуков:** перед/после выполнения каждого графа-узла (pipeline_node_id, inputs, outputs). Использование: логирование, замер времени, мониторинг.
- [ ] **Сухой прогон (dry run):** опция run(..., dry_run=True) — проверить порядок выполнения и наличие входов в буфере без вызова graph.run() (заглушки или пропуск). Полезно для валидации сложных пайплайнов.

### 11.3 Производительность

- [ ] **Кэширование топологического порядка:** после добавления/удаления узлов или рёбер пересчитывать порядок выполнения только при изменении; кэш инвалидировать при add_graph/add_edge/remove.
- [ ] **Буфер без лишних копий:** передавать по ссылке значения из буфера в graph.run() где возможно; контракт графа не должен мутировать входы (документировать).

---

## 12. Критерии приёмки уровня пайплайна (сводка)

- [ ] **Структура:** пайплайн представлен графами-узлами (pipeline_node_id → Graph), рёбрами пайплайна (между внешними портами графов), внешними входами/выходами пайплайна; индексы in/out по узлам.
- [ ] **Построение:** AddGraph (граф или конфиг), AddEdge с валидацией по контрактам графов, expose_input/expose_output; вырожденный случай — один граф.
- [ ] **Валидация:** при AddEdge и полная validate(); DAG, достижимость, совместимость типов портов; опционально валидация внутренних графов.
- [ ] **Исполнитель:** топологическая сортировка, буфер по (pipeline_node_id, port_name), run(pipeline, inputs, training=..., **kwargs) → outputs; поддержка training и проброс опций в графы; опционально callbacks.
- [ ] **Сериализация:** конфиг пайплайна (графы с вложенными конфигами или ref, рёбра, внешние порты, версия); чекпоинт = агрегация чекпоинтов графов (каталог или архив); save_config, save_checkpoint, save; load_config, load_from_checkpoint, load.
- [ ] **Загрузка из чекпоинта:** восстановление пайплайна из конфига + загрузка весов всех графов; пайплайн готов к run. Соответствие [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md).
- [ ] **Обучение:** выбор trainable графов; trainable_parameters() пайплайна = объединение по trainable графам; сохранение/загрузка чекпоинта при обучении. Соответствие [TRAINABILITY_AT_ALL_LEVELS.md](TRAINABILITY_AT_ALL_LEVELS.md).
- [ ] **Конфиг и шаблоны:** from_config/from_yaml; from_template(name, **kwargs); валидация после загрузки и понятные ошибки; ref на конфиги графов.
- [ ] **Multi-endpoint:** опционально endpoint_url по узлам; выполнение удалённых узлов через API; сериализация/десериализация по контракту. Соответствие [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md).
- [ ] **Контракт пайплайна:** get_input_spec(), get_output_spec() для этапа и оркестрации; связь с [Stage_Level.md](Stage_Level.md) и [World_Serialization.md](World_Serialization.md).

После выполнения этого TODO уровень пайплайна реализован полностью и согласован с графовым движком (TODO_03), сериализацией, обучаемостью, multi-endpoint и со всей структурой проекта (этап, мир).
