# TODO 01: Фундаментальный уровень (ядро системы)

Пошаговый список того, **что должно быть реализовано**, **как должно быть реализовано**, **что должно поддерживаться** и **как это соотносится со всем проектом** — для **полной реализации ядра системы на фундаментальном уровне**.

**Канон:** [Abstract_Block_And_Node.md](Abstract_Block_And_Node.md), [System.md](System.md). Сериализация и чекпоинты: [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md). Обучаемость: [TRAINABILITY_AT_ALL_LEVELS.md](TRAINABILITY_AT_ALL_LEVELS.md).

**Границы фундамента:** Abstract Base Block, Abstract Graph Node, порты, рёбра, преобразование блок→узел, сериализация структуры и весов на уровне блока/узла, загрузка из чекпоинта. Всё выше (узлы-задачи, граф, пайплайн, этап, мир) опирается на этот уровень.

**Учёт нового канона:** при реализации блока и реестра учитывать: (1) **Модели через API** ([LLM_API_SUPPORT.md](LLM_API_SUPPORT.md)) — любой блок может работать без локальных весов (режим «только API»), если у провайдера есть API; конфиг блока должен допускать `backend: "api"`, `provider`, `model_id`; (2) **Повторное использование моделей** ([MODEL_REUSE.md](MODEL_REUSE.md)) — идентификация «одна и та же модель» по checkpoint_ref/model_id; при сборке графа/пайплайна один ref → один экземпляр блока в памяти. Контракт блока (порты, forward, state_dict) единый для локальных и API-блоков. (3) **Обучение при reuse и API:** [TRAINING_REUSE_AND_API_SCENARIOS.md](TRAINING_REUSE_AND_API_SCENARIOS.md). (4) **Поддержка агентных систем** ([AGENT_SYSTEMS_SUPPORT.md](AGENT_SYSTEMS_SUPPORT.md)) — блок может реализовывать агентный контракт (состояние между вызовами, tool_calls/tool_results); state_dict включает состояние агента. (5) **Гибкость использования (канон):** пользователь может использовать движок на уровне блоков в классических сценариях (только блоки, напр. нейросеть для детекции) в рамках единого канона; см. [AGENT_SYSTEMS_SUPPORT.md](AGENT_SYSTEMS_SUPPORT.md) §0.

### Пункты к реализации на этапе 01 (новый канон)

- [ ] **API-режим блока:** в конфиге блока поддержка полей `backend: "api"`, `provider`, `model_id` (и при необходимости `endpoint_url`); блок в этом режиме не загружает локальные веса, при forward выполняет запрос к API; контракт портов и state_dict (пустой или только метаданные) единый с локальным блоком.
- [ ] **Идентификация для повторного использования:** в конфиге блока или при создании — поле `checkpoint_ref` (путь/URI для локальных весов) или `model_id` (для API); реестр или фабрика при build(config) должны возвращать один экземпляр на один ref/model_id при наличии пула (пул может быть введён на уровне реестра или графа в TODO_02/03).
- [ ] **Задел для пула:** реестр (или отдельный сервис) допускает кэш/пул «checkpoint_ref/model_id → блок», чтобы вышележащие уровни (граф, пайплайн) при сборке могли запрашивать блок по ref и получать один и тот же экземпляр.
- [ ] **Задел для агентного блока:** контракт блока допускает опциональное расширение для агента: (1) внутреннее состояние между вызовами (память, диалог), сохраняемое в state_dict; (2) выход может содержать tool_calls; вход — опционально tool_results. Реестр/типы могут различать блоки с агентным контрактом для исполнителя графа. См. [AGENT_SYSTEMS_SUPPORT.md](AGENT_SYSTEMS_SUPPORT.md) §2.1.

---

## Связь с остальным проектом

| Уровень выше | Как опирается на фундамент |
|--------------|----------------------------|
| **Узлы-задачи** (Backbone, Solver, Codec, …) | Наследуют/реализуют Block (и концепцию Node); объявляют порты и выполнение; регистрируются в реестре типов. |
| **Граф** | Состоит из узлов (каждый узел = блок + имя + рёбра); рёбра связывают порты узлов; исполнитель вызывает блоки узлов. |
| **Пайплайн / Этап / Мир** | Агрегируют вложенные сущности; веса на этих уровнях = веса блоков внутри; загрузка из чекпоинта опирается на загрузку блоков. |
| **Сериализация на всех уровнях** | На фундаменте: конфиг блока + state_dict сериализуемы; блок загружается из чекпоинта; без этого невозможна сериализация графа и выше. |
| **Обучаемость на всех уровнях** | Блок предоставляет обучаемые параметры и state_dict; без контракта блока обучение графа/мира не определено. |
| **Multi-endpoint, LoRA-мир** | Граф/мир разворачиваются по эндпоинтам и замораживаются с LoRA; единицей остаётся блок с портами и весами. |

Итого: фундамент — **единственная основа** для всех уровней; реализация должна быть полной и соответствовать канону, иначе вышележащие TODO не будут согласованы.

---

## 1. Abstract Base Block (блок)

### 1.1 Что реализовать

- [ ] **Базовый класс (или интерфейс) Abstract Base Block**, от которого наследуются все конкретные блоки.
- [ ] **Хранилище блока:** параметры и конфигурация, тензоры и веса, ссылки, состояние для save/load (state_dict). Всё, что блок хранит, должно быть доступно для сериализации и загрузки из чекпоинта.
- [ ] **Контракт: объявление портов** — метод или метаданные: имена входных и выходных портов, типы (или схема данных), опциональность. Порты объявляются без привязки к графу.
- [ ] **Контракт: выполнение** — метод `forward(inputs) -> outputs` или `run(inputs) -> outputs`, где `inputs` и `outputs` — словари по именам портов (или согласованный формат). Выполнение детерминировано объявленными портами.
- [ ] **Контракт: идентификация** — атрибуты или свойства `block_type` (строка/идентификатор типа) и `block_id` (уникальный в области видимости идентификатор экземпляра). По ним граф и реестр обращаются к блоку.
- [ ] **Жизненный цикл:** создание (по конфигу), опционально размещение в узле, выполнение (по вызову), сохранение/загрузка (см. п. 1.2).

### 1.2 Как реализовать

- **Базовый класс:** абстрактные методы `declare_ports()` (или статический/экземплярный список портов), `forward(inputs)` / `run(inputs)`; свойства `block_type`, `block_id`; методы `state_dict()`, `load_state_dict()`, опционально `trainable_parameters()` для обучаемости. Конкретные блоки переопределяют объявление портов и логику выполнения.
- **Конфиг:** блок должен создаваться из словаря/конфига (например, `block_type` + параметры); при сохранении конфиг блока сериализуем (YAML/JSON), чтобы можно было восстановить структуру без весов.
- **Порты:** явная структура данных для порта (имя, направление in/out, тип, optional, multiple/aggregation policy при необходимости). Совместимость типов при соединении — либо строгая проверка, либо правила приведения; должно быть документировано.

### 1.3 Что должно поддерживаться

- [ ] **Сериализация структуры блока:** конфиг (block_type, block_id, параметры) сохраняется в формате, пригодном для восстановления «пустого» блока (без весов или с дефолтными).
- [ ] **Сериализация весов блока:** state_dict (все тензоры/параметры, необходимые для воспроизведения работы) сохраняется в чекпоинт; формат (например, safetensors, torch) зафиксирован или конфигурируем.
- [ ] **Загрузка блока из чекпоинта:** API вида `load_from_checkpoint(path)` или `load_state_dict(state_dict)` — восстановление весов блока; при необходимости восстановление из конфига + чекпоинт в два шага (сначала создать блок из конфига, затем загрузить веса).
- [ ] **Опционально: фазы train/eval** — блок может переключать режим (например, dropout, batch norm); контракт выполнения может учитывать режим.
- [ ] **Композиция: блоки из блоков** — блок может содержать подблоки; снаружи он по-прежнему объявляет порты и выполнение; внутри — вызов подблоков и передача данных. Сохранение/загрузка такого блока включает конфиг и веса подблоков (рекурсивно).

### 1.4 Связь с проектом

- Без блока с контрактом портов и state_dict невозможны граф (узлы = блоки), сериализация на всех уровнях ([SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md)), обучаемость ([TRAINABILITY_AT_ALL_LEVELS.md](TRAINABILITY_AT_ALL_LEVELS.md)), LoRA-мир (заморозка/адаптеры на блоке). Реализация блока должна быть достаточной, чтобы уровень узлов-задач (Abstract_Task_Nodes) мог наследовать и расширять его без дублирования контракта.

---

## 2. Порты (детализация для блока и графа)

### 2.1 Что реализовать

- [ ] **Структура данных «порт»:** имя (уникальное внутри блока), направление (in/out), тип данных (или схема), опциональность, при необходимости — политика агрегации для множественных входящих рёбер.
- [ ] **Проверка совместимости:** при соединении двух портов (исходящий → входящий) тип выхода источника и тип входа приёмника должны быть совместимы (правила заданы: равенство типов, подтипы, или явное приведение).
- [ ] **Использование в рёбрах:** ребро задаётся парой (node_id, port_name) для источника и приёмника; имена портов совпадают с объявленными в блоке узла.

### 2.2 Как реализовать

- Порты могут быть частью метаданных блока (список объектов Port или словарь name → Port). Типы — enum или строковые идентификаторы с опциональной схемой (например, tensor shape, dtype). Валидатор графа при добавлении ребра проверяет совместимость по типам.
- Опциональность: при выполнении графа, если опциональный вход не имеет входящего ребра, блоку передаётся значение по умолчанию или специальный маркер «не задано»; блок обязан обработать это (контракт).

### 2.3 Что должно поддерживаться

- [ ] Один выходной порт — источник нескольких рёбер (раздача одного значения).
- [ ] Один входной порт — приёмник одного или нескольких рёбер; при нескольких — политика агрегации (конкатенация, сумма, выбор и т.д.) задаётся в спецификации порта или блока.

### 2.4 Связь с проектом

- Порты — общий язык блока и графа: граф соединяет порты узлов; исполнитель графа передаёт данные по портам. Узлы-задачи (Abstract_Task_Nodes) объявляют порты по своей семантике; граф и шаблоны опираются на эти объявления.

---

## 3. Abstract Graph Node (узел графа)

### 3.1 Что реализовать

- [ ] **Структура «узел»:** уникальное имя узла в графе (node_id), ссылка на блок (ровно один блок в узле), список входящих рёбер, список исходящих рёбер. Узел не хранит данные вычислений — только положение и связи; данные хранит блок.
- [ ] **Рёбра:** формат ребра (source_node_id, source_port_name) → (target_node_id, target_port_name). Хранение в графе: список или множество рёбер; для каждого узла можно запросить входящие/исходящие рёбра по портам.
- [ ] **Преобразование блок → узел:** операция «поместить блок в узел»: создать узел с именем, присвоить узлу блок, далее задать рёбра для портов этого блока. После этого блок участвует в графе как узел.

### 3.2 Как реализовать

- Узел — класс или структура: `node_id: str`, `block: AbstractBaseBlock`, `in_edges: List[Edge]`, `out_edges: List[Edge]` (или граф хранит все рёбра централизованно, а узел запрашивает по node_id). Ребро — именованная кортеж или объект (source_node, source_port, target_node, target_port).
- Валидация при добавлении ребра: существование source_node и target_node, существование указанных портов у соответствующих блоков, совместимость типов портов. Опционально: обязательные входные порты должны иметь ровно одно входящее ребро (или политика задана).

### 3.3 Что должно поддерживаться

- [ ] Входы и выходы графа: вход графа = входной порт какого-то узла, не имеющий входящего ребра от другого узла (или явно помеченный как внешний вход). Выход графа = выходной порт узла, помеченный как внешний выход (или конец цепочки). Узел задаёт участие портов блока в этих входах/выходах графа.
- [ ] Один и тот же класс блоков может использоваться в разных узлах одного графа с разными именами узлов и разными рёбрами.

### 3.4 Связь с проектом

- Граф (уровень выше) состоит из узлов и рёбер; исполнитель графа обходит узлы, собирает входы по входящим рёбрам, вызывает блок узла, раздаёт выходы по исходящим рёбрам. Без узла и рёбер граф не определён. Сериализация графа (структура) — сериализация узлов (node_id, block_type, block_id, конфиг блока) и рёбер; веса графа — веса блоков в узлах.

---

## 4. Граф (структура на фундаменте)

*Примечание: граф как «первый исполняемый уровень» и его исполнитель могут быть вынесены в отдельный TODO (Graph level). Здесь — только то, что относится к ядру: структура графа как множество узлов + множество рёбер и минимально необходимое для сериализации/загрузки на уровне фундамента.*

### 4.1 Что реализовать на фундаменте

- [ ] **Структура графа:** контейнер узлов (node_id → узел) и рёбер (список рёбер или отображения по узлам). Добавление узла (с блоком), добавление ребра с валидацией.
- [ ] **Сериализация структуры графа:** граф сохраняется в конфиг (YAML/JSON): список узлов (для каждого: node_id, block_type, block_id, конфиг блока), список рёбер (source_node, source_port, target_node, target_port), опционально помеченные входы/выходы графа. Этого достаточно, чтобы восстановить граф без весов (блоки создаются из конфига через реестр типов).
- [ ] **Сериализация весов графа:** на уровне фундамента «веса графа» = совокупность state_dict всех блоков в узлах. Формат: один файл с объединённым state_dict (с префиксами по node_id/block_id) или каталог с чекпоинтами по узлам/блокам. Должно быть однозначно восстанавливаемо.
- [ ] **Загрузка графа из чекпоинта:** (1) загрузка конфига графа → создание узлов и блоков (из реестра по block_type), создание рёбер; (2) загрузка чекпоинта весов → загрузка state_dict в каждый блок (по node_id/block_id). API вида `Graph.load_from_checkpoint(config_path, checkpoint_path)` или эквивалент.

### 4.2 Связь с проектом

- Граф — первый уровень, на котором есть и структура, и выполнение (см. Graph_Level). Фундамент обеспечивает: узлы = блоки в обёртке узла, рёбра = связи портов, сериализация/загрузка графа опирается на сериализацию/загрузку блоков. Полноценный исполнитель графа (топологическая сортировка, вызов блоков, буферы) — в TODO уровня графа; здесь закладывается только структура и контракт данных.

---

## 5. Реестр типов блоков (Block Registry)

### 5.1 Что реализовать

- [ ] **Реестр:** отображение `block_type` (строка или идентификатор) → класс (или фабрика) блока. Регистрация класса блока под именем типа; по типу можно создать экземпляр блока из конфига.
- [ ] **Создание блока из конфига:** по полю `type` в конфиге выбрать класс из реестра; остальные поля конфига передать в конструктор или фабрику. В результате — экземпляр блока с заданными параметрами (без весов или с дефолтными, если применимо).
- [ ] **Опционально:** автообнаружение блоков (сканирование пакетов/модулей и регистрация помеченных классов); подсказки при KeyError (похожие имена типов).

### 5.2 Как реализовать

- Глобальный реестр (синглтон или модуль-уровень); декоратор `@register_block("block_type")` или явный вызов `Registry.register("block_type", BlockClass)`. `Registry.build(config)` или `Registry.create(config)` возвращает экземпляр блока.
- Конфиг блока должен содержать как минимум `type` (или `block_type`); остальное — от конкретного класса.

### 5.3 Связь с проектом

- Без реестра нельзя собрать граф/мир из конфига: при десериализации конфига графа для каждого узла нужно создать блок по block_type. Узлы-задачи (Backbone, Solver, Codec, …) регистрируются в этом реестре; плагины и пользовательские блоки — тоже.

---

## 6. Обучаемость на уровне блока (задел для TRAINABILITY)

### 6.1 Что реализовать на фундаменте

- [ ] **Доступ к обучаемым параметрам:** у блока — метод или свойство `trainable_parameters()` (или эквивалент), возвращающее итератор/список параметров, которые можно передать в оптимизатор. Опционально: `freeze()`, `unfreeze()` для заморозки/разморозки весов.
- [ ] **Сохранение и загрузка включают все веса,** необходимые для воспроизведения (в т.ч. для обучения): state_dict не теряет часть параметров; при загрузке из чекпоинта оптимизатор может продолжить обучение с загруженного состояния.

### 6.2 Связь с проектом

- [TRAINABILITY_AT_ALL_LEVELS.md](TRAINABILITY_AT_ALL_LEVELS.md): на уровне блока обучаются параметры блока; граф/пайплайн выбирают подмножество узлов (блоков) для обучения. Контракт `trainable_parameters()` и state_dict на фундаменте обеспечивает возможность обучения на любом уровне выше.

---

## 7. Критерии приёмки (фундамент)

- [ ] Любой блок можно создать из конфига (через реестр), выполнить с входом по портам, получить выход по портам.
- [ ] Любой блок можно поместить в узел графа, задать рёбра по портам; структура графа (узлы + рёбра) сериализуется и восстанавливается из конфига.
- [ ] Веса блока сериализуются (state_dict) и загружаются из чекпоинта; на уровне графа веса всех узлов сериализуются и граф загружается из чекпоинта (конфиг + веса).
- [ ] Порты объявлены с именами и типами; при добавлении ребра проверяется совместимость типов; выполнение графа (если реализовано на этом этапе) передаёт данные по рёбрам в порты блоков.
- [ ] Блок может содержать подблоки; снаружи соблюдается тот же контракт; сериализация/загрузка блока с подблоками поддерживается.
- [ ] Реестр типов блоков позволяет регистрировать классы и создавать блоки по `block_type` из конфига; загрузка графа из конфига использует реестр для создания блоков в узлах.

После выполнения этого TODO фундаментальный уровень готов для построения уровня узлов-задач (Abstract_Task_Nodes) и уровня графа (Graph_Level) с полной сериализацией и загрузкой из чекпоинта на уровне блока и графа.
