# Полная обучаемость на всех уровнях представления

**Принцип:** на **каждом уровне представления** проект должен быть **полностью обучаем**. Любой блок, любой узел, любая обучаемая величина, которую можно обучить, **должна быть обучаемой** — LoRA, ControlNet, Backbone, кодек, кондиционер и т.д., на любом уровне: от отдельного блока до графа, пайплайна, этапа и мира.

Канон: [WorldGenerator_2.0/](../WorldGenerator_2.0/) (Abstract_Block_And_Node, Abstract_Task_Nodes, Graph_Level). Сериализуемость: [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md).

---

## 1. Требование

- **На каждом уровне представления** (блок, узел, граф, пайплайн, этап, мир) всё, что **может быть обучено**, должно **поддерживать обучение**.
- **Любой блок** с обучаемыми параметрами (веса, адаптеры) — обучаем: full fine-tune, LoRA, адаптеры, заморозка части параметров по конфигу.
- **Любой узел** в графе — это блок; если блок обучаем, узел обучаем в составе графа.
- **Конкретно:** Backbone, ControlNet, LoRA, кодек, conditioner, любые адаптеры и любые узлы-задачи с параметрами должны быть доступны для обучения на своём уровне (блок отдельно, или в составе графа/пайплайна/этапа).

Итого: **любая обучаемая сущность на любом уровне** — блок, узел, подмножество узлов графа, целый граф, пайплайн — должна поддерживать тренировку с сохранением структуры и сериализуемости (чекпоинты, конфиг обучения).

---

## 2. Уровни и обучаемость

| Уровень | Что обучается | Как |
|---------|----------------|-----|
| **Блок** | Параметры блока (веса, state_dict) | Выбор оптимизируемых параметров (все / только адаптеры / выбранные модули); loss по входам/выходам портов; сохранение чекпоинта блока. |
| **Узел** | Блок внутри узла | То же, что блок; узел идентифицирует блок для оптимизатора и логирования. |
| **Граф** | Любое подмножество узлов (в т.ч. один узел или все) | Граф задаёт топологию; обучение: forward по графу, loss (на выходах графа или на выходах выбранных узлов), backward по выбранным узлам; заморозка остальных. LoRA, ControlNet, Backbone — узлы графа; каждый может быть trainable/frozen по конфигу. |
| **Пайплайн** | Узлы пайплайна = графы; любой граф (или узлы внутри графа) может быть обучаем | Обучение одного или нескольких графов в пайплайне; остальные заморожены; поток данных между графами сохраняется. |
| **Этап / Мир** | Этапы и графы/пайплайны внутри них | Обучение выбранных этапов или блоков внутри этапов (например, только Автор-LLM или только Творец-граф) при сохранении цикла и контракта state. |

На каждом уровне: **выбор trainable сущностей** (блоки, узлы, графы), **конфиг обучения** (lr, schedule, заморозка), **loss** (по портам/выходам), **чекпоинты** (сериализуемое состояние обучаемых параметров).

---

## 3. Примеры: LoRA, ControlNet, Backbone

- **LoRA (и другие адаптеры):** блок-адаптер в графе; обучаем только параметры адаптера при замороженном backbone (или обучаем и то и другое по конфигу). Уровень: блок как узел графа; граф остаётся исполняемым, обучение — по выбранным узлам.
- **ControlNet:** узел графа с обучаемыми весами; обучение ControlNet отдельно или совместно с backbone; уровень — граф (подмножество узлов trainable).
- **Backbone:** полная или частичная дообучение backbone как узла графа; уровень — блок/узел/граф.

Все перечисленные случаи — **на любом уровне представления**: один блок, один граф, граф внутри пайплайна, граф внутри этапа мира. Система не должна запрещать обучение ни одного типа блока или узла; конфиг задаёт, что trainable, что frozen.

---

## 4. Следствия для реализации

- **Блок:** контракт блока включает возможность запроса обучаемых параметров (например, `trainable_parameters()`), состояние для чекпоинта (state_dict); при обучении графа оптимизатор получает параметры выбранных узлов/блоков.
- **Граф / пайплайн / этап:** механизм обучения (trainer) работает с графом/пайплайном/этапом как с единицей выполнения; при этом указывается, какие узлы (или какие графы в пайплайне) trainable; forward и backward проходят по топологии с учётом заморозки.
- **Сериализуемость:** конфиг обучения и чекпоинты обучаемых блоков/графов сериализуемы; после обучения сохранённый мир/граф/блок можно загрузить и продолжить обучение или только инференс.

Итого: **на каждом уровне представления проект полностью обучаем** — любой блок, любой узел, любая обучаемая величина (LoRA, ControlNet, Backbone и т.д.) поддерживает обучение на своём уровне без исключений.
