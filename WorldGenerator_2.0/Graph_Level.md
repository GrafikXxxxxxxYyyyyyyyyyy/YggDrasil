# Уровень графа: первый исполняемый уровень

Описание **уровня графа** как первого уровня, на котором система **исполняется** ([Abstract_Task_Nodes.md](Abstract_Task_Nodes.md) — узлы-задачи). Граф — это **одна цельная задача** (text-to-image, image-to-video, upscale, распознавание и т.д.); граф **состоит из абстрактных узлов-задач** (Backbone, Solver, Codec, Conditioner, Tokenizer и т.д.), собирается через **Graph.AddNode(...)**, узлы автоматически понимают свою роль. Выше графа — **пайплайн** («граф графов», может состоять из одного графа; [Pipeline_Level.md](Pipeline_Level.md)), затем **этап** — **граф пайплайнов** (узлами этапа являются пайплайны; между этапами передаётся **state**; [Stage_Level.md](Stage_Level.md)), затем World ([System.md](System.md)).

---

## 1. Граф — одна цельная задача

**Граф задаёт одну законченную цель** (одну задачу), а не «кусок» пайплайна. Примеры:

- **Text-to-image** — полная реализация: текст на входе, изображение на выходе. Всё, что нужно (токенизация, условие, диффузия, декодирование), входит в **один граф**.
- **Image-to-video** — целая задача: изображение → видео.
- **Text-to-audio** — целая задача: текст → аудио.
- **Upscale** — целая задача: изображение низкого разрешения → изображение высокого разрешения.
- **Image-to-image** — целая задача (например, стилизация, перевод домена).
- **Распознавание изображений** — не обязательно диффузия; граф может быть и не-диффузионным (классификация, детекция и т.д.).

В контексте проекта **простые задачи выполняются на уровне графа**: один граф = одна задача. Комбинирование задач (текст → картинка → апскейл → видео) делается на уровне **пайплайна** ([Pipeline_Level.md](Pipeline_Level.md)) — граф, узлами которого являются графы; пайплайн **может состоять из одного графа**. По графу текут данные между узлами; по пайплайну — между графами; на уровне этапа ([Stage_Level.md](Stage_Level.md)) между фазами передаётся **state** — это та же логика потока данных, поднятая до уровня этапов и мира.

---

## 2. Граф — первый исполняемый уровень

Ниже уровня графа лежат только **спецификации**:

| Уровень | Характер | Исполнение |
|---------|----------|------------|
| **Фундамент** | Abstract Base Block, Abstract Graph Node | Абстракции; контракты портов и правила «блок → узел». Не исполняются сами по себе. |
| **Над фундаментом** | Abstract Backbone, Solver, Codec, Adapter, Conditioner, Tokenizer, Guidance, … | Спецификации задач, контракты портов, семантика выполнения. Типы/абстракции, не экземпляры. |
| **Граф** | Граф из узлов и рёбер | **Первый уровень, на котором что-то выполняется:** один граф = одна задача; узлы — экземпляры узлов-задач, по рёбрам передаются данные, выполняется forward/run. |

**Исполняемый** значит: по графу можно передать вход задачи, выполнить узлы по топологии и получить выход задачи. Граф — **конкретная собранная структура** для одной цели.

---

## 3. Граф состоит из узлов-задач; сборка через AddNode

Узлы графа — **конкретные реализации** абстрактных узлов-задач (Backbone, Solver, Codec, Conditioner, Tokenizer, Guidance и т.д.). Граф собирается добавлением таких узлов:

- **Graph.AddNode(Backbone)** — добавить узел типа Backbone (например, UNet2D).
- **Graph.AddNode(Codec)** — добавить узел Codec (encode/decode).
- **Graph.AddNode(Solver)** — добавить Solver (DDIM, Euler и т.д.).
- **Graph.AddNode(Conditioner)** — добавить Conditioner (текст/изображение → эмбеддинг).
- **Graph.AddNode(Tokenizer)** — добавить Tokenizer (текст → токены).
- И т.д.

**Узлы автоматически понимают, где они находятся:** по типу узла-задачи (Backbone, Solver, Codec, …) система знает, с какими портами и с какими узлами данный узел должен соединяться. Пользователю не нужно вручную указывать каждое ребро: при добавлении узла его типичные связи выводятся из спецификации задачи. В результате **граф для задачи (например, text-to-image) можно собрать в несколько строк** — добавление нужных узлов и при необходимости явное связывание нестандартных портов.

Рёбра графа соединяют порты узлов согласно контрактам узлов-задач; исполнение — по топологии графа (последовательно или с циклами, например backbone ↔ solver).

---

## 4. Сводка

| Понятие | Определение |
|---------|-------------|
| **Граф** | Одна цельная задача (text-to-image, image-to-video, upscale, image-to-image, распознавание и т.д.). Может быть диффузионной или не-диффузионной. |
| **Состав графа** | Узлы — экземпляры узлов-задач (Backbone, Solver, Codec, Conditioner, Tokenizer, …); сборка через **Graph.AddNode(...)**; узлы знают свою роль и типичные связи. |
| **Первый исполняемый уровень** | По графу передаются данные и выполняется run; вход/выход графа = вход/выход задачи. |
| **Выше графа** | **Пайплайн** (граф графов) → **Этап** (граф пайплайнов) → **Мир** (граф этапов). [Pipeline_Level.md](Pipeline_Level.md), [Stage_Level.md](Stage_Level.md), [World_Level.md](World_Level.md). |

Детали узлов-задач, реестр типов, валидация и сериализация — в [Abstract_Task_Nodes.md](Abstract_Task_Nodes.md) (разделы 11–12).
