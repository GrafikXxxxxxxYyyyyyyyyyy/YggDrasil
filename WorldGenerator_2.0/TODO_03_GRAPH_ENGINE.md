# TODO 03: Графовый движок (Graph Engine) — реализация уровня графа

Технически детализированный TODO по **реализации графового движка** всего проекта: структура графа, построение, валидация, исполнитель (включая циклы), сериализация, загрузка из чекпоинта, обучение и связь с пайплайном, этапом и миром. Учтены фундамент (TODO_01), узлы-задачи (TODO_02), полная сериализуемость, обучаемость, multi-endpoint и контракт графа как единицы исполнения.

**Канон:** [Graph_Level.md](Graph_Level.md), [Abstract_Block_And_Node.md](Abstract_Block_And_Node.md), [Abstract_Task_Nodes.md](Abstract_Task_Nodes.md). Предшествующие TODO: [TODO_01_FOUNDATION.md](TODO_01_FOUNDATION.md), [TODO_02_TASK_NODES_AND_GRAPH.md](TODO_02_TASK_NODES_AND_GRAPH.md). Сериализация: [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md). Обучаемость: [TRAINABILITY_AT_ALL_LEVELS.md](TRAINABILITY_AT_ALL_LEVELS.md). Multi-endpoint: [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md). Пайплайн: [Pipeline_Level.md](Pipeline_Level.md).

**Границы этого TODO:** движок уровня графа — **структура данных графа**, **API построения** (опираясь на блоки и узлы из фундамента и на узлы-задачи с role rules), **валидация**, **исполнитель** (топология, циклы, буферы, вызов блоков), **run(graph, inputs) → outputs**, **режим обучения** (градиенты, выбор trainable узлов), **сериализация/десериализация структуры и весов**, **загрузка из чекпоинта**, **контракт графа как чёрного ящика** для пайплайна и развёртывания. Всё связано с общей структурой проекта.

**Учёт нового канона:** (1) **Модели через API** ([LLM_API_SUPPORT.md](LLM_API_SUPPORT.md)) — граф может содержать узлы в режиме API; исполнитель вызывает block.forward(inputs); контракт графа не меняется. (2) **Повторное использование моделей** ([MODEL_REUSE.md](MODEL_REUSE.md)) — при сборке графа один ref → один экземпляр блока. (3) **Обучение при reuse:** [TRAINING_REUSE_AND_API_SCENARIOS.md](TRAINING_REUSE_AND_API_SCENARIOS.md) — дедупликация параметров в оптимизаторе, чекпоинт один раз на ref.

### Пункты к реализации на этапе 03 (новый канон)

- [ ] **Пул ref → блок при сборке:** при add_node и при Graph.from_config использовать пул (checkpoint_ref или model_id → блок); при создании узла с уже встречавшимся ref подставлять существующий блок; граф не должен содержать два узла с двумя копиями одного и того же блока.
- [ ] **trainable_parameters() с дедупликацией:** при вызове graph.trainable_parameters() возвращать параметры каждого уникального блока не более одного раза (дедупликация по id(block) или по checkpoint_ref), чтобы оптимизатор не регистрировал одни и те же параметры дважды. См. [TRAINING_REUSE_AND_API_SCENARIOS.md](TRAINING_REUSE_AND_API_SCENARIOS.md) §2.1.
- [ ] **Сохранение state_dict по уникальным ref:** при graph.state_dict() формировать состояние по уникальным блокам (один раз на ref), а не по числу узлов; при load_state_dict загружать в блок один раз. Совместимость с сериализацией по [MODEL_REUSE.md](MODEL_REUSE.md).

---

## Зависимости от предыдущих уровней

| Компонент | Откуда берётся | Как используется движком графа |
|-----------|----------------|---------------------------------|
| **Abstract Base Block** | TODO_01 | Узел графа хранит ссылку на блок; исполнитель вызывает `block.forward(inputs)`; блок предоставляет `state_dict`, `load_state_dict`, `trainable_parameters()`. |
| **Порты** | TODO_01 | Рёбра связывают (node_id, port_name); совместимость типов при валидации; при run данные передаются по именам портов в словарях inputs/outputs. |
| **Узел (Node)** | TODO_01 | Узел = (node_id, block); граф хранит отображение node_id → Node; рёбра задают связи портов узлов. |
| **Block Registry** | TODO_01 | При загрузке графа из конфига для каждого узла по `block_type` создаётся блок через `Registry.build(config)`; при AddNode(type, config) — то же. |
| **Узлы-задачи и role rules** | TODO_02 | При AddNode(..., auto_connect=True) движок применяет таблицу типичных связей (роль источника ↔ роль приёмника) и создаёт рёбра к уже существующим узлам; роли выводятся из `block_type` узла. |
| **Внешние входы/выходы графа** | TODO_01, Graph_Level | Вход графа = порт узла без входящего ребра от другого узла (или явно помеченный); выход = порт, помеченный как выход (или без исходящих рёбер в другие узлы). Контракт графа как единицы = список имён входов и выходов с привязкой (node_id, port_name). |

Без выполнения контрактов TODO_01 и TODO_02 графовый движок не может быть реализован согласованно; при реализации движка предполагается, что блок, узел, порты, реестр и role rules уже соответствуют канону.

---

## 1. Структура данных графа

### 1.1 Что реализовать

- [ ] **Граф (Graph)** — контейнер с тремя сущностями: (1) **узлы:** отображение `node_id: str → Node`; (2) **рёбра:** список (или множество) рёбер вида `(source_node_id, source_port, target_node_id, target_port)`; (3) **внешний контракт:** списки внешних входов и выходов графа, каждый элемент — `(node_id, port_name)` или логическое имя входа/выхода графа + привязка к `(node_id, port_name)`. Идентификатор графа (graph_id) и опционально метаданные (версия схемы, описание) для сериализации.
- [ ] **Узел в контексте графа:** хранится как объект с полями `node_id`, `block` (ссылка на Abstract Base Block). Список рёбер может храниться централизованно в графе; по node_id можно получить входящие и исходящие рёбра за O(1) или O(k), построив индекс: `in_edges[node_id]` → список рёбер, у которых target_node_id == node_id; `out_edges[node_id]` → список рёбер, у которых source_node_id == node_id.
- [ ] **Инварианты:** каждый node_id в рёбрах присутствует в узлах; каждый port_name в ребре совпадает с объявленным портом блока соответствующего узла; типы портов на концах ребра совместимы (проверка при добавлении ребра или при валидации).

### 1.2 Как реализовать

- Класс `Graph` с полями: `_nodes: Dict[str, Node]`, `_edges: List[Edge]` (или `Set[Edge]`), `_exposed_inputs: List[Tuple[str, str]]` (или список именованных входов с привязкой), `_exposed_outputs: List[Tuple[str, str]]`, `_graph_id: Optional[str]`. Класс `Edge` — именованный кортеж или датакласс: `(source_node_id, source_port, target_node_id, target_port)`. При добавлении/удалении рёбер обновлять индексы in_edges/out_edges по узлам для быстрого доступа при выполнении.
- **Связь с проектом:** эта структура — единственное представление графа на уровне «граф»; пайплайн хранит графы как узлы и обращается к графу только через контракт (входы/выходы) и вызов run; сериализация графа записывает именно узлы, рёбра и внешний контракт.

### 1.3 Критерии

- [ ] По графу можно однозначно определить множество узлов, множество рёбер и список внешних входов/выходов; запрос «входящие рёбра узла X» и «исходящие рёбра узла X» выполняется без полного перебора всех рёбер (индекс или итерация по списку с фильтром — допустимо, но документировать сложность).

---

## 2. API построения графа (Graph Builder)

### 2.1 Добавление узла

- [ ] **AddNode(block_or_type, node_id=None, config=None, auto_connect=True):**
  - **Вариант A:** `block_or_type` — экземпляр блока (Abstract Base Block). Тогда `node_id` обязателен или генерируется (например, `block.block_type + "_" + str(len(nodes))` или uuid). Конфиг не передаётся. Узел создаётся с этим блоком; блок уже имеет block_type и block_id.
  - **Вариант B:** `block_or_type` — строка (block_type). Тогда блок создаётся через реестр: `block = Registry.build({"type": block_or_type, **config})`; node_id задаётся или генерируется по block_type (например, `block_type.replace("/", "_") + "_" + suffix`). Узел создаётся с полученным блоком.
  - После добавления узла: если `auto_connect=True`, вызвать логику **авто-связывания**: для нового узла определить роль по block_type (префикс или маппинг: backbone, solver, codec, conditioner, tokenizer, adapter, guidance); по таблице role rules найти пары (роль нового узла, роль существующего узла) и соответствующие порты; для каждой пары проверить, что в графе есть подходящий узел с совместимыми портами, и добавить ребро (без дублирования, без нарушения однозначности «один входной порт — одно входящее ребро» для обязательных портов, если политика задана). При неоднозначности (несколько кандидатов) — документированная политика: первый подходящий, или не соединять, или требовать явного add_edge.
- [ ] **Уникальность node_id:** при добавлении узла проверять, что node_id не занят; иначе возвращать ошибку или генерировать уникальный идентификатор.
- [ ] **Связь с TODO_01, TODO_02:** блок из реестра (TODO_01); роль и типичные связи из спецификации узлов-задач (TODO_02). Граф не дублирует логику создания блока — только вызывает реестр и хранит узел.

### 2.2 Добавление ребра

- [ ] **AddEdge(source_node_id, source_port, target_node_id, target_port):**
  - Проверить: source_node_id и target_node_id есть в графе; source_port — выходной порт блока узла source_node_id; target_port — входной порт блока узла target_node_id; типы портов совместимы (правило из фундамента: тип выхода источника и тип входа приёмника совместимы). При множественных входящих рёбрах на один порт — проверить, что порт допускает multiple и задана политика агрегации.
  - Добавить ребро в список рёбер графа и обновить индексы in_edges/out_edges.
  - Опционально: предупреждение, если обязательный вход целевого узла уже имеет входящее ребро (перезапись или второе ребро — по политике).
- [ ] **Связь с проектом:** единственный способ задать поток данных между узлами кроме авто-связывания; пайплайн на своём уровне использует аналог (рёбра между графами по внешним портам графов).

### 2.3 Внешние входы и выходы графа

- [ ] **expose_input(node_id, port_name, name=None):** пометить входной порт узла как внешний вход графа. Опционально задать логическое имя входа (name), по которому вызывающий будет передавать значение в run(graph, inputs={name: value}); если name не задан — использовать `(node_id, port_name)` или сгенерировать уникальный ключ. Записать в `_exposed_inputs`.
- [ ] **expose_output(node_id, port_name, name=None):** пометить выходной порт узла как внешний выход графа; имя name для ключа в возвращаемом словаре outputs. Записать в `_exposed_outputs`.
- [ ] **Автовывод внешних портов (опционально):** метод `infer_exposed_ports()`: вход графа = все входные порты узлов, не имеющие входящего ребра от другого узла; выход графа = все выходные порты узлов, не имеющие исходящего ребра к другому узлу (или помеченные как «конец цепочки»). Использовать только если пользователь не вызвал expose_input/expose_output явно; иначе контракт графа задаётся явно для совместимости с пайплайном и API развёртывания.
- [ ] **Контракт графа как единицы:** после фиксации внешних входов/выходов граф объявляет контракт: список имён входов (и типов, если типы портов доступны) и список имён выходов (и типов). Этот контракт используется пайплайном (соединение выхода одного графа с входом другого) и при развёртывании графа на эндпоинт (API сервиса = run по этим именам). Связь с [Pipeline_Level.md](Pipeline_Level.md) и [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md).

### 2.4 Критерии приёмки (Builder)

- [ ] Граф можно собрать программно: последовательность AddNode и AddEdge (и опционально expose_input/expose_output); поддержка AddNode с созданием блока из реестра по type+config и авто-связыванием по role rules. Уникальность node_id и валидация портов при AddEdge.

---

## 3. Валидация графа

### 3.1 При добавлении ребра

- [ ] Существование узлов и портов; совместимость типов (и при необходимости shape/dtype, если типы это задают). Запрет на циклы по типам не требуется — циклы допустимы (backbone–solver).

### 3.2 Полная валидация (перед run или по запросу)

- [ ] **Проверка связности по данным:** каждый узел достижим от хотя бы одного внешнего входа (или от узла, достижимого от входа) и ведёт к внешнему выходу (или к узлу, из которого достижим выход); иначе предупреждение «висячий узел».
- [ ] **Обязательные порты:** каждый обязательный входной порт каждого узла имеет ровно одно входящее ребро (или значение по умолчанию задано в конфиге блока). Иначе ошибка валидации с указанием (node_id, port_name).
- [ ] **Внешние входы:** каждый объявленный внешний вход соответствует входному порту узла; при run для каждого внешнего входа будет подано значение (или проверка на обязательность входов при run).
- [ ] **Циклы:** граф может содержать циклы; валидатор может вычислять сильно связные компоненты (SCC) и помечать «подграфы-циклы» для исполнителя (см. п. 4). Ошибкой считать только случай, когда внутри цикла обязательный вход узла не получает значения к моменту первого выполнения (т.е. начальные значения для цикла должны поступать снаружи или от узлов вне цикла).
- [ ] **Связь с проектом:** валидация гарантирует, что run не упрётся в отсутствующие входы; пайплайн при выполнении своих графов полагается на то, что граф уже валиден.

### 3.3 Реализация

- Метод `Graph.validate(strict=True) -> ValidationResult`: перечень проверок; при strict=False только предупреждения. ValidationResult — список ошибок и предупреждений с указанием узла/порта/ребра. Использование: перед сохранением в конфиг, перед run (опционально), после from_config.

---

## 4. Исполнитель графа (Executor)

### 4.1 Топологический порядок и циклы

- [ ] **Разбиение графа на DAG и циклы:** построить ориентированный граф G по узлам и рёбрам (узлы = вершины, ребро = дуга от source к target). Вычислить **сильно связные компоненты (SCC)**. Узлы, образующие SCC из более чем одной вершины (или одну вершину с петлёй), — **подграф цикла**; остальные — **DAG-часть**. Топологическая сортировка DAG: порядок обхода от «источников» (узлы без входящих рёбер от других узлов) к «стокам». Подграфы-циклы обрабатываются отдельно: для каждого такого подграфа задаётся **порядок обхода узлов внутри цикла** (фиксированный или выведенный из ролей, например backbone → solver → backbone...) и **число итераций** (N шагов деноisingа и т.д.).
- [ ] **Порядок выполнения:** (1) выполнить все узлы DAG в топологическом порядке; (2) для каждого подграфа-цикла: определить начальные значения на входах узлов цикла (из буфера — результаты узлов вне цикла или внешние входы графа); выполнить итерацию цикла N раз (на каждой итерации в заданном порядке вызвать блоки узлов цикла, передавать выходы по рёбрам в буфер и использовать их как входы на следующей итерации); после N итераций записать финальные выходы цикла в буфер для последующих узлов или во внешние выходы графа.
- [ ] **Буфер (cache):** ключ — пара (node_id, port_name) для выходов узлов; значение — результат выхода блока. Внешние входы графа при run подаются в буфер под ключами, соответствующими внешним входам (привязка к (node_id, port_name)). При выполнении узла: собрать входы узла из буфера (по входящим рёбрам: для каждого ребра в target (node_id, port_name) взять значение из буфера по (source_node_id, source_port)); вызвать block.forward(inputs); записать выходы в буфер по (node_id, port_name) для каждого исходящего порта.
- [ ] **Опциональные входы:** если у узла опциональный порт без входящего ребра, в inputs для блока передать значение по умолчанию (из конфига блока) или специальный маркер; контракт блока обязан это обрабатывать.

### 4.2 Сигнатура run

- [ ] **run(graph, inputs, *, training=False, num_loop_steps=None, device=None, callbacks=None) -> outputs:**
  - **inputs:** словарь { input_name: value } для каждого внешнего входа графа (имена из expose_input или автовывода). Либо словарь {(node_id, port_name): value}, если используется привязка без логических имён.
  - **training:** если True, блоки переводить в режим train (если поддерживается); при использовании фреймворка с автоградиентом (например, PyTorch) градиенты будут течь при последующем backward. Если False — режим eval.
  - **num_loop_steps:** для подграфов-циклов число итераций (например, число шагов деноisingа). Может быть задано в конфиге графа или передаваться в run; если не задано — брать из конфига графа или из конфига узла (например, solver).
  - **device:** опционально перенос блоков и тензоров на устройство (CPU/GPU); реализация зависит от фреймворка.
  - **callbacks:** опционально хуки (на начало/конец выполнения узла, на итерацию цикла) для отладки, логирования, прогресс-бара.
  - **outputs:** словарь { output_name: value } для каждого внешнего выхода графа (значения из буфера по привязке (node_id, port_name) после выполнения).
- [ ] **Идемпотентность run по графу:** один и тот же граф можно вызывать многократно с разными inputs; состояние блоков (веса) не меняется при inference (training=False); при training=True состояние может меняться (batch norm и т.д.), что документировано.

### 4.3 Режим обучения (gradients)

- [ ] Если блоки графа — объекты с поддержкой автоградиента (например, PyTorch nn.Module), то при run(graph, inputs, training=True) и последующем вызове backward(loss) градиенты распространяются по цепочке вызовов. Исполнитель не обязан реализовывать backward сам — достаточно вызывать forward блоков и передавать тензоры; backward обеспечивается фреймворком при привязке loss к выходам графа.
- [ ] **Выбор trainable узлов:** перед обучением граф (или конфиг) задаёт, какие узлы заморожены: для этих узлов либо не вызывать backward, либо обнулять градиенты. Метод `graph.trainable_parameters()` возвращает итератор параметров только тех узлов, которые помечены как trainable; оптимизатор получает этот итератор. Заморозка: вызов `block.eval()` и отключение градиентов для параметров блока, либо блок не входит в trainable_parameters(). Связь с [TRAINABILITY_AT_ALL_LEVELS.md](TRAINABILITY_AT_ALL_LEVELS.md) и [LORA_WORLD_LIGHTWEIGHT_CUSTOM.md](LORA_WORLD_LIGHTWEIGHT_CUSTOM.md).

### 4.4 Критерии приёмки (Executor)

- [ ] Исполнитель по графу и inputs выполняет узлы в корректном порядке (DAG + циклы с заданным N); данные передаются по рёбрам через буфер; внешние выходы собираются и возвращаются. Поддержка training и callbacks; опционально device. Документированное поведение при опциональных входах и при отсутствии значения в буфере (ошибка или значение по умолчанию).

---

## 5. Сериализация графа (структура)

### 5.1 Схема конфига

- [ ] **Версия схемы:** поле `schema_version` или `graph_version` для обратной совместимости при изменении формата.
- [ ] **Узлы:** список записей; каждая запись: `node_id`, `block_type`, `config` (словарь конфига блока, сериализуемый в YAML/JSON). Порты не дублировать в конфиге графа — они заданы типом блока в реестре.
- [ ] **Рёбра:** список записей `{ source_node, source_port, target_node, target_port }`.
- [ ] **Внешние входы/выходы:** список записей `{ name (опционально), node_id, port_name }` для входов и выходов.
- [ ] **Метаданные (опционально):** graph_id, description, num_loop_steps по умолчанию для циклов.
- [ ] **Формат файла:** YAML или JSON; кодировка UTF-8. Имена полей зафиксированы в документации (например, `nodes`, `edges`, `exposed_inputs`, `exposed_outputs`).

### 5.2 Сохранение и загрузка структуры

- [ ] **save_config(path)** или **to_dict():** сериализовать граф в конфиг (узлы, рёбра, внешние порты, метаданные) и записать в файл или вернуть словарь. Блоки не сериализуются в конфиг «как объекты» — только block_type и config каждого узла; state_dict блоков в конфиг не входят (см. п. 6).
- [ ] **load_config(path)** или **from_dict(d):** прочитать конфиг; для каждого узла вызвать `Registry.build({"type": block_type, **config})`, создать узел с node_id; добавить рёбра; задать внешние входы/выходы. Получается граф без загруженных весов (блоки с дефолтными или пустыми весами). Связь с [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md): структура графа полностью восстанавливается из конфига.

### 5.3 Связь с проектом

- Пайплайн и мир при сериализации сохраняют графы как узлы; каждый граф сериализуется в конфиг по этой схеме. Единый формат конфига графа обеспечивает взаимозаменяемость и загрузку из реестра блоков без привязки к конкретному коду графа.

---

## 6. Сериализация весов графа и загрузка из чекпоинта

### 6.1 Формат чекпоинта графа

- [ ] **Вариант A — один файл:** один файл (например, .pt, .safetensors) содержит объединённый state_dict; ключи — с префиксом node_id (например, `node_id.param_name` или `node_id/param_name`), чтобы при загрузке можно было разбить state_dict по узлам и вызвать `block.load_state_dict(sub_dict)` для каждого блока. Порядок узлов при сохранении фиксирован (например, по node_id).
- [ ] **Вариант B — каталог:** каталог с файлами `node_id.pt` (или `node_id.safetensors`) для каждого узла; в каждом файле — state_dict блока этого узла. Плюс опционально `graph_meta.json` с информацией о графе (node_id list, версия).
- [ ] Выбор формата конфигурируем (флаг при save_checkpoint или настройка графа); документировать оба варианта и гарантировать, что загрузка поддерживает оба (или один канонический).

### 6.2 Сохранение весов

- [ ] **save_checkpoint(path, format="single"|"dir"):** для каждого узла графа получить `block.state_dict()`, при формате "single" объединить с префиксами node_id, записать в один файл; при формате "dir" записать в отдельный файл по node_id. Формат файла (PyTorch .pt, safetensors и т.д.) задаётся параметром или конфигом.
- [ ] **Совместное сохранение:** метод `graph.save(save_dir)` — сохранить конфиг графа в `save_dir/config.yaml` (или config.json) и чекпоинт в `save_dir/checkpoint.pt` (или `save_dir/checkpoints/`). Полная воспроизводимость: конфиг + чекпоинт.

### 6.3 Загрузка из чекпоинта

- [ ] **load_from_checkpoint(checkpoint_path, config_path=None):** если граф уже создан (например, из конфига), то только загрузить веса: прочитать чекпоинт (один файл или каталог), для каждого node_id из графа извлечь соответствующий state_dict и вызвать `graph.get_node(node_id).block.load_state_dict(...)`. Если передан config_path, сначала построить граф из конфига (load_config), затем загрузить веса. Итог: граф готов к run.
- [ ] **load_from_checkpoint(save_dir):** если в save_dir есть config и чекпоинт (по соглашению имён), загрузить конфиг и чекпоинт одной операцией; вернуть экземпляр Graph. API вида `Graph.load(save_dir)` или `Graph.load_from_checkpoint(save_dir)`.
- [ ] **Связь с [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md):** на уровне графа веса сериализуются и загрузка из чекпоинта реализована; пайплайн и мир при загрузке вызывают загрузку графов-узлов, опираясь на этот контракт.

### 6.4 Версионирование и совместимость

- [ ] При сохранении чекпоинта записывать версию схемы графа (и при необходимости версию формата state_dict). При загрузке проверять совместимость; при несовпадении версий — ошибка с понятным сообщением или миграция по правилам (если реализована).

---

## 7. Сборка графа из конфига и шаблонов

### 7.1 From_config

- [ ] **Graph.from_config(config)** или **Graph.from_yaml(path):** config — словарь с полями nodes, edges, exposed_inputs, exposed_outputs (и опционально metadata). Для каждого элемента nodes: вызвать Registry.build(node["block_type"], node["config"]), создать узел с node["node_id"]; добавить рёбра по списку edges; установить exposed_inputs и exposed_outputs. Валидация после сборки (опционально). Возврат экземпляра Graph. Зависимость: Block Registry (TODO_01) и согласованность имён полей с п. 5.
- [ ] **Включение подконфигов:** поддержка ссылок в конфиге (например, `config: ref:path/to/block_config.yaml`) для выноса конфигов блоков в отдельные файлы; при загрузке разрешать ссылки и подставлять содержимое.

### 7.2 From_template

- [ ] **Graph.from_template(template_name, **kwargs):** шаблон — именованная функция или конфиг-генератор, который по kwargs возвращает конфиг графа (словарь в формате п. 5). Реализация: получить конфиг из шаблона, подставить kwargs в конфиг (например, num_steps, resolution, model_id), вызвать Graph.from_config(config). Шаблоны регистрируются в реестре шаблонов (например, "text_to_image", "upscale"); документировать доступные шаблоны и их параметры.
- [ ] **Связь с проектом:** удобство для пользователя (одна строка для типовой задачи); пайплайн и этапы могут использовать те же шаблоны для графов-узлов.

### 7.3 Валидация после загрузки

- [ ] После from_config вызывать graph.validate() и при ошибках возвращать понятное сообщение (какой узел/порт/ребро); при ref — указывать путь к подконфигу. Подсказки при KeyError реестра (похожие имена block_type) из TODO_01 применимы при загрузке узлов.

---

## 8. Контракт графа как единицы исполнения (связь с пайплайном и multi-endpoint)

### 8.1 Контракт входа/выхода

- [ ] Граф объявляет **входной контракт:** список пар (имя входа, тип или схема данных), соответствующих exposed_inputs; и **выходной контракт:** список пар (имя выхода, тип или схема). Типы выводятся из портов блоков (если порты типизированы в реестре). Контракт доступен через `graph.get_input_spec()` и `graph.get_output_spec()` (или аналог) для использования пайплайном и для генерации API сервиса при развёртывании.
- [ ] **Пайплайн:** при добавлении графа как узла пайплайна пайплайн соединяет свои рёбра с входами/выходами графа по именам (или по порядку); контракт графа задаёт, какие имена и типы ожидаются. Связь с [Pipeline_Level.md](Pipeline_Level.md).
- [ ] **Multi-endpoint:** при развёртывании графа на эндпоинт API сервиса (REST/gRPC) строится по контракту: запрос содержит значения для каждого входа, ответ — значения для каждого выхода; сериализация (JSON, бинарные артефакты) по типам портов. Связь с [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md).

### 8.2 Идентификация графа

- [ ] graph_id (или имя графа) в метаданных для логирования, сохранения и загрузки; при использовании графа как узла пайплайна пайплайн может хранить граф под своим идентификатором узла (pipeline_node_id), при этом внутренний graph_id графа сохраняется в конфиге пайплайна.

---

## 9. Дополнительные требования движка

### 9.1 Устройство и типы данных (device / dtype)

- [ ] **to(device)** или **set_device(device):** перенос всех блоков графа на заданное устройство (CPU, CUDA, MPS и т.д.). Реализация: обход узлов, вызов block.to(device) для каждого блока (если блок поддерживает). При run опционально передавать device и приводить входные тензоры к этому устройству.
- [ ] **dtype:** при необходимости конвертация типов (float16, bfloat16) для экономии памяти; задаётся в конфиге блока или глобально для графа; исполнитель не обязан менять dtype — блоки могут принимать нужный dtype по конфигу.

### 9.2 Хуки и отладка

- [ ] **Регистрация хуков:** перед выполнением узла / после выполнения узла / на каждой итерации цикла. Сигнатура: hook(node_id, phase, inputs, outputs). Использование: логирование, замер времени, сохранение промежуточных тензоров для отладки.
- [ ] **Сухой прогон (dry run):** опция run(..., dry_run=True) — проверить порядок выполнения и доступность входов в буфере без реального вызова блоков (заглушки или пропуск forward). Полезно для валидации сложных графов.

### 9.3 Производительность

- [ ] **Кэширование топологического порядка и разметки циклов:** после добавления узлов/рёбер пересчитывать порядок выполнения и разметку SCC только при изменении графа (или по запросу); кэш инвалидировать при add_node/add_edge/remove.
- [ ] **Буфер без лишних копий:** где возможно, передавать по ссылке (или по указателю) значения в буфере в блок, чтобы избежать копирования больших тензоров; учитывать, что блок может модифицировать вход (документировать контракт: блок не должен мутировать входы, если не оговорено).

---

## 10. Критерии приёмки графового движка

- [ ] **Структура:** граф представлен узлами (node_id → block), рёбрами и внешними входами/выходами; индексы in/out по узлам для быстрого доступа.
- [ ] **Построение:** AddNode (блок или type+config, авто-связывание по role rules), AddEdge с валидацией, expose_input/expose_output; уникальность node_id.
- [ ] **Валидация:** при AddEdge и полная validate(); обязательные порты, достижимость, корректность циклов (начальные значения).
- [ ] **Исполнитель:** топологическая сортировка, выделение SCC и выполнение циклов с заданным N; буфер по (node_id, port_name); run(graph, inputs, training=..., num_loop_steps=...) → outputs; поддержка training и trainable_parameters() по узлам.
- [ ] **Сериализация:** конфиг графа (узлы, рёбра, внешние порты, версия); чекпоинт весов (один файл с префиксами или каталог по node_id); save_config, save_checkpoint, save; load_config, load_from_checkpoint, load.
- [ ] **Загрузка из чекпоинта:** восстановление графа из конфига + загрузка весов в блоки; граф готов к run. Соответствие [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md).
- [ ] **Конфиг и шаблоны:** from_config/from_yaml; from_template(name, **kwargs); валидация после загрузки и понятные ошибки.
- [ ] **Контракт графа:** входной и выходной контракт (имена и типы) для пайплайна и multi-endpoint; get_input_spec/get_output_spec (или эквивалент).
- [ ] **Связь со всей структурой:** движок опирается на фундамент (блок, узел, порты, реестр) и на узлы-задачи (роли, role rules); граф как единица исполнения используется пайплайном (граф графов), этапом и миром; сериализация и обучаемость на уровне графа обеспечены; развёртывание одного графа на один эндпоинт опирается на контракт и сериализацию.

После выполнения этого TODO графовый движок реализован полностью и согласован с TODO_01, TODO_02 и со всей структурой проекта (пайплайн, этап, мир, сериализация, обучаемость, multi-endpoint).
