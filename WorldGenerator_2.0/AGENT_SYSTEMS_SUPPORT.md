# Полная и глубоко встроенная поддержка агентных систем

**Единый канон проекта:** [CANON.md](CANON.md). **Требование:** фреймворк должен обеспечивать **полноценную и глубоко встроенную поддержку агентных систем** на всех уровнях иерархии. Агентные системы — это системы, в которых одна или несколько сущностей (**агентов**) способны вести рассуждение, хранить состояние между вызовами, **использовать инструменты (tools)** — вызывать другие блоки или графы, — и при необходимости выполнять **многошаговое планирование и выполнение** (plan-and-act, ReAct, tool loop). Поддержка должна быть не надстройкой, а **равноправной частью контрактов и архитектуры**: блок может быть агентом; граф может представлять цикл «агент → инструменты → агент»; этап и мир могут содержать этапы-агентов с инструментами.

Канон: [Abstract_Block_And_Node.md](Abstract_Block_And_Node.md), [Abstract_Task_Nodes.md](Abstract_Task_Nodes.md), [Graph_Level.md](Graph_Level.md), [LLM_API_SUPPORT.md](LLM_API_SUPPORT.md), [Scheme.md](Scheme.md), [World_Level.md](World_Level.md). Расширение выше мира: [EXPANSION_UNIVERSE_GRAPH_OF_WORLDS.md](EXPANSION_UNIVERSE_GRAPH_OF_WORLDS.md).

---

## 0. Тезисы: полная интеграция и классические сценарии (новый канон)

### 0.1 Полная интеграция в архитектуру движка

- **Агентные системы должны быть полностью поддержаны и полностью интегрированы в архитектуру движка YggDrasill.** Они не являются опциональным модулем: контракты блока, графа, пайплайна, этапа и мира допускают агентные сущности как равноправные; исполнитель графа поддерживает агентный цикл (agent_loop); сериализация и обучение распространяются на состояние агентов и инструменты.
- **Агентные системы применимы на любом разумном этапе процесса** в рамках всего фреймворка: на уровне блока (блок-агент), графа (граф с агентом и инструментами), пайплайна (граф-агент как узел), этапа (этап-агент), мира (мир с агентными этапами) и, при расширении, вселенной (агенты как переносчики данных и сущности между мирами). Пользователь может вводить агентные системы там, где это нужно, не ломая канон.

### 0.2 Классические сценарии использования и полная гибкость

- **Движок YggDrasill должен предоставлять пользователю возможность использовать каждую часть в классических сценариях**, сохраняя канон проекта. То есть:
  - **Только агентные системы:** пользователь может использовать YggDrasill **только** для построения и запуска автоматизированных агентных систем (агент + инструменты, agent_loop) в рамках канона и архитектуры движка — без обязательного подъёма до мира или пайплайна языковых моделей.
  - **Только модели мира:** пользователь может использовать YggDrasill **только** для построения модели мира (цикл этапов, state, Scheme) в рамках канона — без обязательного использования агентных систем или диффузии.
  - **Только языковые модели (инференс/обучение):** пользователь может использовать YggDrasill на уровне графа/блоков для инференса или обучения языковых моделей в рамках канона.
  - **Только диффузионные модели:** пользователь может использовать YggDrasill для инференса и обучения диффузионных моделей (граф, пайплайн) в классическом сценарии.
  - **Только простые нейросети:** пользователь может опуститься до уровня блоков и использовать YggDrasill как набор блоков (например, нейросеть для детекции изображений) в классическом сценарии.
- **Аналогично:** комбинированные пайплайны (языковые + диффузионные модели), комбинации языковых моделей, диффузии, агентных систем и моделей мира — всё доступно. Пользователь может **подняться или опуститься до нужного уровня представления** и использовать движок именно на этом уровне: только инференс диффузии, только блок детекции, только пайплайн «языковая модель + диффузия», только агентные системы, только построение мира или полный стек (язык + диффузия + агенты + мир).
- **Итог:** должна быть **полная гибкость использования фреймворка**: пользователь вправе использовать каждую часть по отдельности, собирать из них собственные подсистемы или выстраивать широкий спектр задач — при **простоте и элегантности структуры проекта** и **строгом соблюдении канона и философии** ([Philosophy.md](Philosophy.md), [Scheme.md](Scheme.md)). Агентные системы, модели мира, диффузия, языковые модели и простые блоки — все доступны в классических сценариях и в любых комбинациях в рамках одной архитектуры.

### 0.3 Агентные системы на любом этапе

- Агентные системы должны быть **применимы на любом разумном этапе** процесса в рамках фреймворка: от блока (агент как блок с state и tool_calls) до графа (agent_loop), пайплайна (граф-агент как узел), этапа (этап-агент), мира (агентные этапы) и, при расширении, вселенной (обмен между мирами через агентов/сущности). Реализация и документация должны это явно отражать.

### 0.4 Уровень Вселенной: обмен между мирами и кросс-мировое влияние

- **На уровне Вселенной** агентные системы позволяют **обмениваться данными и информацией между мирами** в контексте действий в отдельном мире. То есть сущности (в т.ч. агенты, персонажи) могут действовать в одном мире, при этом их происхождение или состояние связано с другим миром; обмен по рёбрам графа миров и семантика «перехода» сущности между мирами должны быть поддержаны.
- **Пример:** персонаж (character) из мира A может «перейти» в мир B. В мире B действия персонажа влияют на ход истории мира B и меняют его. Одновременно, поскольку персонаж пришёл из мира A, **история персонажа в мире A также меняется** (например, факт отсутствия в A, последствия возврата, отражение событий из B в биографии в A). Таким образом, сущность, переместившаяся из одного мира в другой, влияет и на историю мира, в котором находится, и на свою историю в мире исхода. Детальная проработка концепции Вселенной как графа миров и взаимодействий между мирами и между сущностями внутри каждого мира приведена в [EXPANSION_UNIVERSE_GRAPH_OF_WORLDS.md](EXPANSION_UNIVERSE_GRAPH_OF_WORLDS.md).

---

## 1. Цели и область применения

- **Агент как блок (узел-задача):** тип блока/узла, который (1) хранит **внутреннее состояние** (история диалога, план, память, контекст); (2) при вызове `forward` может возвращать не только «финальный» ответ, но и **вызовы инструментов** (tool_calls) — идентификатор инструмента и аргументы; (3) принимает на следующем шаге **результаты инструментов** (tool_results) и продолжает рассуждение; (4) завершает работу, когда выдаёт итоговый выход (без tool_calls) или по условию (max_steps, stop). Такой блок реализует **агентный цикл** (LLM + tool use, ReAct, plan-and-execute и т.д.) и может использовать LLM локально или через API ([LLM_API_SUPPORT.md](LLM_API_SUPPORT.md)).
- **Инструменты (tools):** блоки или целые графы, которые **вызываются агентом**. Контракт инструмента: именованные входы (аргументы вызова) и выход (результат). В графе: узел-агент и узлы-инструменты; агент на выходе выдаёт «вызвать инструмент X с аргументами Y»; исполнитель вызывает соответствующий узел/граф и передаёт результат обратно агенту. Инструментом может быть любой блок с стабильным контрактом портов (например, поиск, калькулятор, вызов кодека, вызов другого графа).
- **Граф как агентный контур:** граф, содержащий один (или несколько) узлов-агентов и узлы-инструменты; выполнение — **цикл**: шаг агента → выполнение выбранных инструментов → шаг агента с результатами → … до завершения. Топология графа допускает условные/динамические переходы (какой инструмент вызвать решает агент).
- **Пайплайн и этап:** узел пайплайна или этапа может быть **графом-агентом** (граф с агентом и инструментами); другой узел — граф-инструмент, вызываемый агентом из первого графа (если инструменты вынесены на уровень пайплайна). Этап мира (Автор, Философ, Архитектор, Development of the world) может быть реализован как **агент с инструментами**: например, Автор — агент с доступом к инструментам «генерация текста», «запрос к миру», «запись артефакта».
- **Мир:** цикл мира ([Scheme.md](Scheme.md)) уже задаёт поток state между этапами; этапы могут быть **агентными** (каждый этап — агент со своими инструментами). Поддержка агентных систем означает: (1) этап может быть графом/пайплайном с узлом-агентом и узлами-инструментами; (2) state передаётся между этапами как раньше; (3) при необходимости **action** пользователя и контекст мира передаются агенту (например, в Development of the world) для принятия решений.

Итого: **поддержка агентных систем** — это возможность на любом уровне (блок, граф, пайплайн, этап, мир) использовать **агента** (состояние, рассуждение, вызов инструментов) и **инструменты** (блоки/графы, вызываемые агентом), с единым контрактом выполнения и сериализации.

---

## 2. Требования к реализации по уровням

### 2.1 Уровень блока (Foundation, TODO_01)

- [ ] **Контракт блока-агента (опциональное расширение):** блок может реализовывать **агентный контракт**: (1) состояние между вызовами — хранится внутри блока (conversation, memory, plan); (2) `forward(inputs)` принимает опционально `tool_results: List[{tool_id, result}` и возвращает `outputs`, где помимо обычных портов может быть поле **tool_calls: List[{tool_id, arguments}]**; (3) если `tool_calls` не пусто, исполнитель графа вызывает указанные инструменты и передаёт результаты в следующий вызов блока. Блок без tool_calls в ответе считается завершившим шаг (или финальный ответ на выходном порте). Стандартный блок без этого расширения ведёт себя как раньше (один forward = один вызов, без tool loop).
- [ ] **Идентификация агентного блока:** в конфиге или в block_type — признак того, что блок поддерживает агентный протокол (stateful, tool_calls out, tool_results in). Реестр и исполнитель графа могут проверять этот признак для включения режима «агентный цикл».
- [ ] **Сериализация состояния агента:** состояние агента (история, память) входит в `state_dict()` блока и восстанавливается при `load_state_dict()`; при сохранении графа/пайплайна состояние агента сохраняется вместе с весами.

### 2.2 Уровень узлов-задач и графа (TODO_02, TODO_03)

- [ ] **Роль Agent и тип узла-агента:** в перечне ролей/типов узлов-задач — **Agent** (или аналогичное имя). Абстрактный узел-задача Agent: порты — вход (prompt/context, опционально tool_results), выход (response/text, опционально tool_calls). Конкретные реализации: агент на базе LLM (локального или API) с логикой tool calling (OpenAI function calling, ReAct, custom). Регистрация под типами `agent/llm`, `agent/api`, `agent/react` и т.д.
- [ ] **Узлы-инструменты (tools):** любой блок с контрактом «входы по именам → выход по имени» может быть зарегистрирован как инструмент для агента. В графе: агент объявляет, какие инструменты ему доступны (список node_id или список графов по имени); при выдаче агентом tool_calls исполнитель сопоставляет tool_id с node_id (или с графом в пайплайне) и выполняет вызов, результат передаётся агенту.
- [ ] **Исполнитель графа и агентный цикл:** если в графе есть узел-агент (блок с агентным контрактом), исполнитель поддерживает режим выполнения **agent_loop**: (1) вызов agent.forward(inputs); (2) если в выходе есть tool_calls — для каждого вызова выполнить соответствующий узел-инструмент (или подграф), собрать tool_results; (3) вызвать agent.forward(inputs | tool_results); повторять до отсутствия tool_calls или до достижения max_steps. Входы графа (prompt, context) подаются агенту на первом шаге; выход графа — финальный ответ агента или последний выход.
- [ ] **Рёбра и топология:** граф с агентом может иметь статичные рёбра (например, контекст от conditioner к агенту) и **динамические** вызовы по tool_calls. Исполнитель обрабатывает динамические вызовы по таблице «tool_id → node_id» или «tool_id → graph».

### 2.3 Уровень пайплайна (TODO_04)

- [ ] **Граф-агент как узел пайплайна:** узел пайплайна может быть графом, внутри которого есть агент и инструменты; выполнение такого узла = run графа в режиме agent_loop. Контракт пайплайна (входы/выходы) задаётся по входам/выходам этого графа (например, prompt → финальный ответ агента).
- [ ] **Графы-инструменты в пайплайне:** если инструменты агента вынесены на уровень пайплайна (отдельные графы-узлы), то при tool_call агента пайплайн выполняет вызов соответствующего графа-узла и передаёт результат обратно в граф-агент. Для этого контракт run пайплайна может поддерживать **вложенный вызов по запросу** (sub_call от графа-агента к графу-инструменту) или агентный цикл реализуется внутри одного графа, а пайплайн лишь передаёт данные между графами по рёбрам (без динамического tool_call между графами — в зависимости от выбранной архитектуры). Рекомендуется документировать оба варианта: инструменты внутри графа vs инструменты как отдельные графы в пайплайне.

### 2.4 Уровень этапа и мира (TODO_05, TODO_06)

- [ ] **Этап-агент:** этап может состоять из одного пайплайна (или графа), в котором центральный узел — агент (например, Автор, Философ, Архитектор). Контракт этапа по state ([Scheme.md](Scheme.md)) сохраняется: вход state → маппинг в входы пайплайна (в т.ч. контекст для агента); выход пайплайна → маппинг в выход state. Агент внутри этапа может использовать инструменты (другие узлы того же пайплайна/графа или вызовы к миру).
- [ ] **Development of the world как агент:** этап Среда (Development of the world) по [Scheme.md](Scheme.md) читает мир и генерирует описание следующего шага; он может быть реализован как **агент** с инструментами (чтение мира, запрос к хранилищу, вызов LLM по API). Action пользователя передаётся агенту как часть контекста.
- [ ] **Мир с агентными этапами:** мир не меняет свой контракт (цикл, state, storage); этапы-узлы мира могут быть реализованы как агентные пайплайны/графы. Поддержка агентных систем на уровне мира = возможность собирать мир, в котором каждый этап (Философ, Автор, Среда, Архитектор, Творец) при необходимости реализован как агент с инструментами, с сохранением порядка выполнения и потока state по [Scheme.md](Scheme.md).

---

## 3. Интеграция с существующим каноном

| Документ | Связь с агентными системами |
|----------|-----------------------------|
| [LLM_API_SUPPORT.md](LLM_API_SUPPORT.md) | Агент часто использует LLM для рассуждения; LLM может быть только через API. Блок-агент может быть сконфигурирован с backend: "api" для LLM; контракт портов и tool_calls единый. |
| [MODEL_REUSE.md](MODEL_REUSE.md) | Один и тот же LLM (один model_id/checkpoint_ref) может использоваться несколькими агентами или этапами; один экземпляр в памяти. |
| [TRAINING_REUSE_AND_API_SCENARIOS.md](TRAINING_REUSE_AND_API_SCENARIOS.md) | Обучение агента (политика, промпт-адаптеры, reward) при использовании API LLM и локальных инструментов; дедупликация параметров при общих блоках. |
| [TRAINABILITY_AT_ALL_LEVELS.md](TRAINABILITY_AT_ALL_LEVELS.md) | Агентный блок может иметь обучаемые параметры (адаптеры, политика); граф с агентом обучаем как обычно. |
| [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md) | Состояние агента (память, диалог) сериализуется в state_dict блока; конфиг графа/пайплайна с агентом и инструментами сохраняется и восстанавливается. |
| [Scheme.md](Scheme.md) | Цикл мира и этапы совместимы с агентной реализацией этапов; state и условия выполнения не меняются. |

---

## 4. Критерии приёмки

- [ ] **Блок-агент:** можно зарегистрировать блок, который при forward принимает опционально tool_results и возвращает опционально tool_calls; состояние агента сохраняется в state_dict и восстанавливается при загрузке.
- [ ] **Граф с агентом и инструментами:** граф содержит узел-агент и узлы-инструменты; run(graph, inputs) в режиме agent_loop выполняет цикл «агент → tool_calls → выполнение инструментов → агент» до завершения; выход графа — финальный ответ агента.
- [ ] **Пайплайн/этап с графом-агентом:** узел пайплайна или этапа может быть графом с агентом; выполнение пайплайна/этапа вызывает run этого графа (с agent_loop); контракт по state и по входам/выходам пайплайна/этапа соблюдается.
- [ ] **Мир с агентными этапами:** мир можно собрать из этапов, реализованных как агентные пайплайны/графы; run(world, state, action) выполняется по циклу Scheme; state передаётся между этапами; при необходимости action передаётся в этап (например, Development of the world как агент).
- [ ] **Документация:** в каноне и в TODO на всех этапах (01–07) указано, где и как учитывается поддержка агентных систем; в docs — сводка «что реализовано / что нужно реализовать» по агентам.

Итого: **фреймворк должен поддерживать агентные системы как равноправную часть архитектуры** — агент как тип блока/узла, инструменты как вызываемые блоки/графы, агентный цикл в исполнителе графа, этапы и мир с агентными реализациями, с сохранением единого контракта сериализации, обучения и повторного использования моделей.
