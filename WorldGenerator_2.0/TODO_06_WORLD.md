# TODO 06: Уровень мира (World) — полная реализация

Полный, технически глубоко проработанный TODO по **реализации уровня мира (World)** — верхнего уровня системы: мир как граф этапов, циклическое выполнение, state между этапами, условия выполнения по [Scheme.md](Scheme.md), хранилище state при World update, сериализация (конфиг + веса), загрузка из чекпоинта, обучение, конфиг и шаблоны, начальное содержание мира, multi-endpoint. Учтены вся база (граф → пайплайн → этап), [World_Level.md](World_Level.md), [World_Serialization.md](World_Serialization.md), [Scheme.md](Scheme.md), [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md), [TRAINABILITY_AT_ALL_LEVELS.md](TRAINABILITY_AT_ALL_LEVELS.md), [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md), [LORA_WORLD_LIGHTWEIGHT_CUSTOM.md](LORA_WORLD_LIGHTWEIGHT_CUSTOM.md).

**Канон:** [World_Level.md](World_Level.md), [Stage_Level.md](Stage_Level.md), [Scheme.md](Scheme.md), [World_Serialization.md](World_Serialization.md). Предшествующие уровни: [TODO_01_FOUNDATION.md](TODO_01_FOUNDATION.md) … [TODO_05_STAGE.md](TODO_05_STAGE.md).

**Границы этого TODO:** мир — **граф, узлами которого являются этапы (Stage)**; рёбра мира задают **порядок перехода и поток state** между этапами; в каноне граф **циклический** с фиксированным порядком (Философ → Автор → Среда → Архитектор → Творец); выполнение — последовательный вызов этапов в порядке цикла с **проверкой условий выполнения** по state (Scheme §4, §4.8); **хранилище** для сохранения state при World update; **начальное содержание мира** и **Action** (опционально) для Development of the world; сериализация мира = структура цикла + конфиги этапов + state_schema + storage + агрегация чекпоинтов этапов; загрузка из чекпоинта; обучение выбранных этапов; конфиг и шаблоны мира; связь с LoRA-world.

**Учёт нового канона:** (1) **Модели через API** ([LLM_API_SUPPORT.md](LLM_API_SUPPORT.md)) — мир может использовать этапы с блоками только через API; цикл и state не зависят. (2) **Повторное использование моделей** ([MODEL_REUSE.md](MODEL_REUSE.md)) — при загрузке мира один checkpoint_ref → один экземпляр на всей иерархии. (3) **Обучение мира и LoRA при API:** [TRAINING_REUSE_AND_API_SCENARIOS.md](TRAINING_REUSE_AND_API_SCENARIOS.md), [LORA_WORLD_LIGHTWEIGHT_CUSTOM.md](LORA_WORLD_LIGHTWEIGHT_CUSTOM.md) — LoRA к локальным блокам; для API — промпт-адаптеры.

### Пункты к реализации на этапе 06 (новый канон)

- [ ] **Пул при загрузке мира:** при World.from_config и load_from_checkpoint один и тот же checkpoint_ref в любом этапе/пайплайне/графе даёт один экземпляр модели в памяти; агрегация чекпоинтов этапов без дублирования по ref.
- [ ] **run(world, state, action)** с учётом Scheme §4, §4.8; этапы с API-узлами выполняются по тому же контракту (forward через API внутри блока).
- [ ] **Обучение мира:** trainable этапы; при наличии API-этапов в оптимизатор попадают только локальные параметры и локальные адаптеры (промпт-адаптер и т.д.); LoRA «на весь мир» — только к локальным блокам. См. [TRAINING_REUSE_AND_API_SCENARIOS.md](TRAINING_REUSE_AND_API_SCENARIOS.md) §4, [LORA_WORLD_LIGHTWEIGHT_CUSTOM.md](LORA_WORLD_LIGHTWEIGHT_CUSTOM.md).

---

## Зависимости от предыдущих уровней

| Компонент | Откуда берётся | Как используется миром |
|-----------|----------------|--------------------------|
| **Этап (Stage)** | TODO_05 | Узел мира = целый этап. Мир хранит отображение `stage_id: str → Stage`. Выполнение узла = `stage.run(state, action=...)`; контракт этапа по state (input/output blocks, execution_condition) используется миром для передачи state и для решения «выполнять или пропустить». |
| **Контракт этапа по state** | TODO_05 | Вход/выход этапа в терминах блоков state; условие выполнения (например, «только при заполненных 1,2,3»). Мир перед вызовом stage.run() проверяет execution_condition этапа по текущему state; при невыполнении этап пропускается, state передаётся дальше без изменений. |
| **Сериализация этапа** | TODO_05 | Конфиг этапа (пайплайны, рёбра, state contract, роль, условие); чекпоинт этапа = чекпоинты пайплайнов. Конфиг мира содержит конфиги этапов (вложенные или ref); чекпоинт мира = совокупность чекпоинтов этапов. |
| **Загрузка этапа из чекпоинта** | TODO_05 | При загрузке мира из чекпоинта для каждого этапа-узла вызывается загрузка структуры и весов. |
| **State (схема)** | Scheme, World_Level | State — контейнер с блоками (в каноне пять). Мир задаёт **state_schema** (описание блоков, типы при необходимости); создаёт пустой state; при World update сохраняет state в **storage** (директория/URI по конфигу). |
| **Scheme (цикл, условия)** | Scheme | Порядок этапов в цикле; условия выполнения каждого этапа (Философ при 1,2,3; Автор при 1–4; World update при всех 5; Development безусловно); первая итерация при отсутствии state от пользователя (пропуск Философ, Автор, World update; старт с Development). Всё кодируется в исполнителе мира и в конфиге этапов. |

Без реализованного уровня этапа (TODO_05) мир не может ни хранить этапы, ни выполнять их, ни сериализовать/загружать; при реализации мира предполагается, что этап имеет стабильный контракт по state и API run/save/load. Правила Scheme — единый источник правды для порядка и условий.

---

## 1. Структура данных мира

### 1.1 Что реализовать

- [ ] **Мир (World)** — контейнер с: (1) **узлы:** отображение `stage_id: str → Stage` (каждый узел — целый этап); (2) **цикл (порядок выполнения):** упорядоченный список `stage_id` — порядок обхода графа мира (в каноне: Философ → Автор → Среда → Архитектор → Творец, затем снова первый). Рёбра мира не хранятся отдельно: переход «выход этапа i → вход этапа i+1» задаётся порядком в цикле (последний → первый замыкает цикл); (3) **state_schema:** описание структуры state (в каноне — пять блоков; при расширении — дополнительные поля, типы); (4) **storage:** конфигурация хранилища для сохранения state при World update (директория, URI, шаблон имён файлов, политика версионирования); (5) **начальное содержание мира (initial_world):** опционально — начальный контент мира (initial story, глоссарий, стиль, правила), от которого Development of the world порождает первый state; (6) идентификатор мира `world_id` и метаданные (версия схемы, описание).
- [ ] **Инварианты:** каждый stage_id в цикле присутствует в узлах; порядок цикла однозначно задаёт, куда передаётся state после каждого этапа (следующий в списке или первый после последнего). Контракты этапов по state согласованы со state_schema (этап запрашивает и заполняет только существующие блоки).
- [ ] **Индексы:** по stage_id за O(1) получать этап и его позицию в цикле (для исполнителя и валидации).

### 1.2 Циклический граф

- [ ] В каноне мир — **один цикл**: нет ветвлений, один порядок обхода. Реализация: список `cycle: [stage_id_1, ..., stage_id_N]`; после этапа `stage_id_N` state передаётся этапу `stage_id_1`. Опционально поддержка **нециклических** миров (цепочка этапов без замыкания) — тогда «следующий» после последнего этапа — конец выполнения или явно заданный переход; документировать. Для канона достаточно только циклического варианта. Связь с [World_Level.md](World_Level.md) §2–3, [Scheme.md](Scheme.md) §1.

### 1.3 State и хранилище

- [ ] **State** — объект или словарь с ключами-блоками (1..5 в каноне; при расширении — именованные поля). Мир создаёт пустой state по state_schema (все блоки пустые или с default). **Storage:** при выполнении этапа Среда (World update) state сохраняется в хранилище, если state полностью заполнен (все 5 блоков); путь/имя файла задаётся конфигом storage (state_dir, naming_template, max_snapshots и т.д.). Мир передаёт в этап Среда (или в пайплайны внутри неё) ссылку на хранилище или callback для сохранения; реализация World update внутри этапа Среда использует этот контракт. Связь с [Scheme.md](Scheme.md) §2, §3, [World_Serialization.md](World_Serialization.md) §2–3.

### 1.4 Критерии

- [ ] По миру однозначно определены множество этапов-узлов, порядок цикла, state_schema, storage, initial_world; запрос «следующий этап после X» и «этап по stage_id» выполняется за O(1).

---

## 2. API построения мира (World Builder)

### 2.1 Добавление этапа и задание цикла

- [ ] **AddStage(stage_or_config, stage_id=None):**
  - **Вариант A:** `stage_or_config` — экземпляр Stage. Тогда `stage_id` обязателен или берётся из stage.stage_id / role. Узел мира = этот этап.
  - **Вариант B:** `stage_or_config` — словарь конфига этапа (или путь к YAML/JSON). Этап создаётся через `Stage.from_config(config)`; stage_id задаётся или из конфига (role/stage_id), или генерируется.
  - **Уникальность stage_id:** при добавлении проверять, что идентификатор не занят.
- [ ] **SetCycle(ordered_stage_ids):** задать порядок выполнения — список stage_id в порядке обхода цикла. Длина списка должна совпадать с числом узлов мира; каждый stage_id должен присутствовать в узлах. После последнего этапа в списке переход идёт к первому (цикл замыкается).
- [ ] **Канонический цикл:** константа или метод `set_canonical_cycle()` — установить порядок Философ → Автор → Среда → Архитектор → Творец (имена stage_id по Scheme). Требует, чтобы этапы с такими id уже были добавлены. Связь с [Scheme.md](Scheme.md) §1.

### 2.2 State schema и хранилище

- [ ] **set_state_schema(schema):** задать описание state (количество блоков, имена полей, опционально типы). Schema — словарь или объект (например, blocks: 5, fields: { 1: "description_next", 2: "config", ... } или список имён блоков). Используется для создания пустого state и для валидации.
- [ ] **set_storage(config):** задать конфигурацию хранилища: state_dir (путь или URI), опционально naming_template, max_snapshots, политика ротации. Передаётся этапу Среда (или в конфиг этапа при загрузке) для сохранения state при World update.
- [ ] **set_initial_world(content):** опционально задать начальное содержание мира (тексты, глоссарий, стиль, правила) — контент, который читает Development of the world для генерации первого state. Может быть пустым или заданным в конфиге/отдельном файле. Связь с [World_Serialization.md](World_Serialization.md) §2.

### 2.3 Критерии приёмки (Builder)

- [ ] Мир можно собрать программно: AddStage (этап или конфиг) для каждого звена цикла, SetCycle(ordered_ids); задание state_schema, storage, initial_world. Уникальность stage_id; цикл содержит все этапы ровно один раз.

---

## 3. Валидация мира

### 3.1 Полная валидация

- [ ] **Цикл:** каждый stage_id в цикле присутствует в узлах; в цикле нет дубликатов; число элементов цикла = числу узлов.
- [ ] **Контракты этапов:** для каждого этапа input_state_spec и output_state_spec ссылаются только на блоки из state_schema; execution_condition (если есть) ссылается на существующие блоки.
- [ ] **Порядок и совместимость:** выходные блоки этапа i (по контракту) совместимы с входными блоками этапа i+1 (в цикле); для канона это гарантируется схемой (блок 4 → Автор, блок 5 → Среда и т.д.). Опционально проверять непротиворечивость.
- [ ] **Storage:** если задан storage, проверить, что state_dir (или аналог) валиден (существует или может быть создан); опционально проверка прав записи.
- [ ] **Внутренняя валидность этапов:** опционально для каждого этапа вызвать stage.validate(); ошибки агрегировать с указанием stage_id.

### 3.2 Реализация

- [ ] Метод `World.validate(strict=True) -> ValidationResult` с перечисленными проверками; при strict=False только предупреждения.

---

## 4. Исполнитель мира (Executor)

### 4.1 Один шаг цикла

- [ ] **Один шаг** — обход этапов в порядке цикла: для каждого этапа в порядке `cycle[0], cycle[1], ..., cycle[N-1]`:
  - Получить текущий state (в начале шага — state, переданный извне, или state после предыдущего этапа в этом же обходе).
  - Проверить **execution_condition** этапа по state (если условие задано). Если условие ложно — **пропустить** этап: state не меняется, перейти к следующему этапу в цикле.
  - Если условие истинно: вызвать `stage.run(state, action=action_for_this_step, ...)`. action передаётся только для этапа Среда (Environment) — в подузел Development of the world; для остальных этапов action=None. Результат — новый state; он передаётся следующему этапу в цикле.
  - После последнего этапа в цикле state переходит к первому этапу цикла (следующая итерация) или возвращается как выход «одного прохода» в зависимости от API (см. ниже).
- [ ] **Action:** на вход мира при запуске шага (или итерации) опционально передаётся **action** (действие пользователя). Мир передаёт action только в этап Среда при вызове stage.run(state, action=action). Если этап Среда реализован как граф пайплайнов, action пробрасывается во вход пайплайна/графа, соответствующий Development of the world. Связь с [Scheme.md](Scheme.md) §4.7, §6.

### 4.2 Первая итерация и отсутствие state

- [ ] **Если пользователь не передал state** (или передал пустой state) при первом запуске: по [Scheme.md](Scheme.md) §4.8 этапы **Философ**, **Автор** и **World update** (внутри Среда) **пропускаются** — у них условия не выполнены. Цикл **фактически начинается с Development of the world**: выполняется только этап Среда, причём внутри него выполняется только подузел Development of the world (World update пропускается из-за неполного state). Development создаёт **первый state** (блок 1); этот state передаётся следующему этапу в цикле (Архитектор). Реализация: при state пустом или отсутствующем исполнитель мира либо (A) вызывает этапы по порядку, и каждый этап сам возвращает state без изменений при невыполненном условии, либо (B) мир явно определяет «точку входа» для первой итерации (например, индекс этапа Среда в цикле) и начинает с вызова только Development, затем продолжает с Архитектора. Документировать выбранную стратегию; результат должен соответствовать Scheme §4.8.
- [ ] **Передача state пользователем:** если пользователь передал state (блок 1; 1–2; 1–2–3; 1–2–3–4; 1–2–3–4–5), исполнитель запускает цикл с первого этапа в порядке цикла; каждый этап выполняется или пропускается по своему execution_condition. Таблица из Scheme §4.8 — эталон поведения. Связь с [Scheme.md](Scheme.md) §4.8.

### 4.3 Сигнатура run

- [ ] **run(world, state=None, *, action=None, training=False, device=None, callbacks=None, num_steps=1, **kwargs) -> state_or_iterator:**
  - **state:** входящий state (словарь блоков или объект State). Может быть None или пустым — тогда применяется логика первой итерации (§4.2).
  - **action:** опционально; передаётся в этап Среда (Development of the world).
  - **num_steps:** число полных проходов по циклу (1 = один оборот, N = N оборотов). За один проход state последовательно проходит все этапы в порядке цикла с учётом условий.
  - **training,** **device,** **kwargs:** пробрасываются в stage.run(...). **callbacks:** хуки на начало/конец каждого этапа (stage_id, state_before, state_after) или на каждый шаг цикла.
  - **Возврат:** при num_steps=1 — state после одного прохода по циклу; при num_steps>1 — либо последний state после N проходов, либо итератор по state после каждого прохода (по конфигу или флагу). Документировать семантику.
- [ ] **Сохранение state при World update:** внутри этапа Среда при выполнении World update (когда state полный) state сохраняется в хранилище мира. Мир передаёт в этап Среда конфиг storage или callback save_state(state); этап Среда при вызове своего run вызывает сохранение при выполнении подузла World update. Реализация может быть в виде отдельного сервиса мира (после вызова stage.run() мир проверяет, был ли выполнен World update, и сохраняет state) или этап Среда получает storage при создании и сохраняет сам — зафиксировать в контракте. Связь с [Scheme.md](Scheme.md) §2, [World_Serialization.md](World_Serialization.md) §2.

### 4.4 Критерии приёмки (Executor)

- [ ] Исполнитель по миру и state выполняет этапы в порядке цикла; для каждого этапа проверяется execution_condition; при невыполнении этап пропускается; action передаётся только в Среда; при пустом/отсутствующем state на первой итерации поведение соответствует Scheme §4.8; state сохраняется в storage при World update (полный state). Поддержка num_steps, training, device, callbacks.

---

## 5. Сериализация мира (структура — конфиг)

### 5.1 Схема конфига мира

- [ ] **Версия:** world_id, schema_version, description.
- [ ] **Цикл:** cycle: [stage_id_1, ..., stage_id_N] — порядок этапов.
- [ ] **Узлы (этапы):** stages: { stage_id: stage_config }. Каждый stage_config — конфиг этапа в формате TODO_05 (пайплайны, рёбра, state contract, role, execution_condition). Вложенный или ref на файл.
- [ ] **State schema:** state_schema: { blocks: 5, ... } или список/словарь полей блоков.
- [ ] **Начальное содержание мира:** initial_world: { initial_story, glossary, style, rules } — тексты или ссылки на файлы.
- [ ] **Хранилище:** storage: { state_dir, naming_template, max_snapshots, ... }.
- [ ] **Метаданные:** checkpoint_ref (опционально путь к чекпоинту), теги. Формат: YAML или JSON; UTF-8. Связь с [World_Serialization.md](World_Serialization.md) §3.

### 5.2 Сохранение и загрузка структуры

- [ ] **save_config(path)** / **to_dict():** сериализовать мир в конфиг (cycle, stages с вложенными конфигами или ref, state_schema, initial_world, storage, метаданные). Веса не входят.
- [ ] **load_config(path)** / **from_dict(d):** прочитать конфиг; для каждого stage_id создать Stage.from_config(stage_config); задать цикл, state_schema, storage, initial_world. Получается мир без загруженных весов. Разрешение ref на конфиги этапов. Соответствие [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md), [World_Serialization.md](World_Serialization.md) §5.

### 5.3 Среда (Environment) в конфиге

- [ ] Этап Среда в каноне — **два подузла**: World update и Development of the world. В конфиге мира этап Среда задаётся как этап (граф пайплайнов) с двумя пайплайнами/графами или с одним пайплайном с двумя фазами; в конфиге этапа явно указать subnodes: world_update, development_of_the_world и их конфиги. Загрузка мира создаёт этап Среда по этому конфигу; исполнитель мира при вызове этапа Среда передаёт action и storage так, чтобы Development получал action, а World update использовал storage для сохранения state. Связь с [Scheme.md](Scheme.md) §2, [World_Serialization.md](World_Serialization.md) §3.2.

---

## 6. Сериализация весов мира и загрузка из чекпоинта

### 6.1 Формат чекпоинта мира

- [ ] **Веса мира = совокупность весов всех этапов-узлов.** Чекпоинт мира — **агрегация чекпоинтов этапов** (каталог по stage_id или архив). Метаданные мира (world_id, cycle, версия) в world_meta.json или аналог. Соответствие [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md).

### 6.2 Сохранение весов

- [ ] **save_checkpoint(path, format="dir"|"archive"):** для каждого этапа-узла вызвать stage.save_checkpoint(subpath); сохранить метаданные мира (cycle, world_id, schema_version).
- [ ] **save(save_dir):** конфиг мира в save_dir/config.yaml; чекпоинт в save_dir/checkpoints/ (или один архив). Опционально сохранить последний state мира и initial_world в save_dir для воспроизводимости. Полная воспроизводимость: конфиг + чекпоинты всех этапов. Связь с [World_Serialization.md](World_Serialization.md) §6.

### 6.3 Загрузка из чекпоинта

- [ ] **load_from_checkpoint(checkpoint_path, config_path=None):** если мир уже создан из конфига — загрузить веса всех этапов из соответствующих подпутей. Если передан config_path — сначала World.from_config(config), затем загрузка весов из checkpoint_path.
- [ ] **load(save_dir):** по соглашению имён в save_dir загрузить конфиг мира и чекпоинты этапов; вернуть экземпляр World. Опционально восстановить last_state и initial_world из save_dir. API вида `World.load(save_dir)` или `World.load_from_checkpoint(save_dir)`. Соответствие [World_Serialization.md](World_Serialization.md) §5, §6.

### 6.4 Версионирование

- [ ] При сохранении записывать schema_version мира и при необходимости версии форматов чекпоинтов этапов. При загрузке проверять совместимость; при несовпадении — ошибка с сообщением или миграция (если реализована).

---

## 7. Обучение на уровне мира

### 7.1 Выбор trainable этапов

- [ ] Мир задаёт, какие этапы **trainable** (остальные заморожены). Конфиг: список stage_id с флагом trainable. При обучении мира оптимизатор получает параметры только от trainable этапов (stage.trainable_parameters() по каждому). Соответствие [TRAINABILITY_AT_ALL_LEVELS.md](TRAINABILITY_AT_ALL_LEVELS.md).
- [ ] **Forward:** run(world, state, training=True, num_steps=...) выполняется по циклу; градиенты при backward текут через этапы; замороженные этапы не обновляются. Loss может быть привязан к state на выходе определённого этапа или к выходу мира после N шагов; документировать типичные сценарии (обучение Автора, Творца, всего мира).
- [ ] **LoRA-world:** по [LORA_WORLD_LIGHTWEIGHT_CUSTOM.md](LORA_WORLD_LIGHTWEIGHT_CUSTOM.md) — заморозка всех весов мира, подключение LoRA к выбранным блокам/этапам, обучение только адаптеров. На уровне мира это реализуется как выбор trainable этапов/пайплайнов/графов с LoRA-адаптерами и заморозка остальных; конфиг обучения задаёт политику freeze + lora. Чекпоинт после обучения сохраняет полный мир (включая LoRA). Связь с [LORA_WORLD_LIGHTWEIGHT_CUSTOM.md](LORA_WORLD_LIGHTWEIGHT_CUSTOM.md).

### 7.2 Конфиг обучения

- [ ] В конфиге мира или отдельно: trainable_stages, lr (глобально или по этапам), freeze_others; опционально политика LoRA (какие этапы/блоки с LoRA). Сериализуемость конфига обучения.

### 7.3 Критерии приёмки (обучение)

- [ ] Можно задать подмножество этапов мира как trainable; run(..., training=True) и backward обновляют только их; чекпоинт мира сохраняет и загружает веса всех этапов; поддержка LoRA-world по конфигу.

---

## 8. Конфиг и шаблоны мира

### 8.1 From_config

- [ ] **World.from_config(config)** / **World.from_yaml(path):** config с полями cycle, stages (конфиги этапов), state_schema, initial_world, storage, metadata. Для каждого stage_id в cycle создать Stage.from_config(stages[stage_id]); задать цикл, state_schema, storage, initial_world. Валидация после сборки (опционально). Разрешение ref на конфиги этапов. Соответствие [World_Serialization.md](World_Serialization.md) §5.

### 8.2 From_template

- [ ] **World.from_template(template_name, **kwargs):** шаблон — конфиг мира с параметрами-заполнителями (например, `{{ style }}`, `{{ creator_backbone }}`) или вариантами выбора реализаций этапов. При генерации kwargs подставляются в шаблон; результат — конфиг мира; вызвать World.from_config(generated_config). Шаблоны регистрируются (например, "storytelling", "art_generation", "canon_2.0"); документировать параметры. Соответствие [World_Serialization.md](World_Serialization.md) §4.
- [ ] **Результат:** шаблон + параметры → конфиг мира → загрузка → экземпляр World. Обученный мир = тот же конфиг + чекпоинт. Связь с [World_Serialization.md](World_Serialization.md) §6.

### 8.3 Валидация после загрузки

- [ ] После from_config вызывать world.validate(); при ошибках понятные сообщения с указанием stage_id и блока/поля.

---

## 9. Multi-endpoint: мир с удалёнными этапами

### 9.1 Реестр эндпоинтов

- [ ] В конфиге мира для каждого этапа-узла можно задать локальный этап или **endpoint_url**. При загрузке мира узел с endpoint_url хранит дескриптор удалённого сервиса; при run исполнитель мира вызывает удалённый API (передача state, получение state) вместо локального stage.run(). Сериализация state при передаче между эндпоинтами (JSON, бинарные артефакты по state_schema). Соответствие [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md).
- [ ] **Семантика цикла:** при распределённом мире порядок выполнения и условия выполнения этапов сохраняются; state передаётся между эндпоинтами как единый сериализуемый объект. Документировать формат API этапа (вход/выход = state, опционально action для Среда).

### 9.2 Критерии приёмки (multi-endpoint)

- [ ] В конфиге мира можно указать endpoint_url для выбранных этапов; при run эти этапы выполняются запросом к эндпоинту; state сериализуется/десериализуется по state_schema; поведение эквивалентно локальному запуску.

---

## 10. Связь с Scheme и каноном

### 10.1 Единый источник правды

- [ ] [Scheme.md](Scheme.md) — **единый источник правды** по циклу, state, условиям выполнения, первой итерации, Action, World update и Development. Реализация мира (исполнитель, условия пропуска, точка входа при пустом state) должна **строго соответствовать** Scheme §4, §4.8. Таблица §4.8 (что выполняется при передаче пользователем только блока 1; 1–2; 1–2–3; и т.д.; когда World update выполняется) — эталон для тестов и валидации поведения.
- [ ] **Среда = два подузла:** World update (только при полном state) и Development of the world (безусловно, создаёт state с блоком 1). Конфиг этапа Среда и его пайплайны/графы должны отражать эту структуру; исполнитель мира передаёт action в Development и обеспечивает сохранение state в storage при World update. Связь с [Scheme.md](Scheme.md) §2, §4.6–4.7.

### 10.2 Мир один; мир может развиваться сам

- [ ] **Один мир:** обновляется применением state (World update при полном state); новый state создаётся в Development of the world. **Action не обязателен:** при отсутствии action Development создаёт следующий эпизод по текущему состоянию мира. Мир может **развиваться итеративно без участия пользователя**. Документировать и обеспечивать в run(): при state=None и action=None первая итерация стартует с Development → state с блоком 1 → Архитектор → … → цикл продолжается. Связь с [Scheme.md](Scheme.md) §5, §6.

### 10.3 Документирование контракта мира

- [ ] Явно описать: вход мира (state опционально, action опционально), выход (state после одного или N проходов); state_schema; условия выполнения этапов (таблица по stage_id); формат storage и initial_world; чтобы интеграторы и тесты могли полагаться на стабильный контракт.

---

## 11. Дополнительные требования

### 11.1 Устройство и опции

- [ ] **to(device):** перенос всех этапов-узлов на устройство (stage.to(device)). Проброс device и kwargs в stage.run() при run(world, ...).

### 11.2 Хуки и отладка

- [ ] Регистрация хуков: перед/после каждого этапа в цикле (stage_id, state_before, state_after); на сохранение state в storage (World update). **Сухой прогон** run(..., dry_run=True) — проход по циклу без вызова stage.run() (state передаётся без изменений или по заглушкам) для проверки порядка и условий.

### 11.3 Восстановление последнего state

- [ ] Опционально при загрузке мира восстанавливать **последний сохранённый state** из storage (если есть снапшот) для продолжения цикла с того же места. Конфиг: load_last_state: true; путь к последнему state в storage. Документировать.

---

## 12. Критерии приёмки уровня мира (сводка)

- [ ] **Структура:** мир = этапы-узлы (stage_id → Stage), цикл (упорядоченный список stage_id), state_schema, storage, initial_world; индексы по stage_id.
- [ ] **Построение:** AddStage (этап или конфиг), SetCycle(ordered_ids); set_state_schema, set_storage, set_initial_world; канонический цикл по Scheme.
- [ ] **Валидация:** полная validate(); цикл и узлы согласованы; контракты этапов по state_schema; storage валиден; опционально валидация этапов.
- [ ] **Исполнитель:** выполнение этапов в порядке цикла; проверка execution_condition каждого этапа; пропуск при невыполнении; передача action только в Среда; первая итерация при пустом state по Scheme §4.8; сохранение state в storage при World update; run(world, state, action=..., num_steps=..., **kwargs) → state.
- [ ] **Сериализация:** конфиг мира (cycle, stages, state_schema, initial_world, storage, версия); чекпоинт = агрегация чекпоинтов этапов; save_config, save_checkpoint, save; load_config, load_from_checkpoint, load. Соответствие [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md), [World_Serialization.md](World_Serialization.md).
- [ ] **Загрузка из чекпоинта:** восстановление мира из конфига + загрузка весов всех этапов; опционально last_state и initial_world. Соответствие [World_Serialization.md](World_Serialization.md) §5–6.
- [ ] **Обучение:** выбор trainable этапов; trainable_parameters() мира; LoRA-world по конфигу; сохранение/загрузка чекпоинта. Соответствие [TRAINABILITY_AT_ALL_LEVELS.md](TRAINABILITY_AT_ALL_LEVELS.md), [LORA_WORLD_LIGHTWEIGHT_CUSTOM.md](LORA_WORLD_LIGHTWEIGHT_CUSTOM.md).
- [ ] **Конфиг и шаблоны:** from_config/from_yaml; from_template(name, **kwargs); ref на конфиги этапов; валидация после загрузки. Соответствие [World_Serialization.md](World_Serialization.md) §4–5.
- [ ] **Multi-endpoint:** endpoint_url по этапам; выполнение удалённых этапов через API; state сериализуется между эндпоинтами. Соответствие [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md).
- [ ] **Связь с Scheme:** порядок цикла и условия выполнения этапов строго по [Scheme.md](Scheme.md) §4, §4.8; Среда = World update + Development; мир один, может развиваться сам; Action опционален. Соответствие [World_Level.md](World_Level.md), [Scheme.md](Scheme.md).

После выполнения этого TODO уровень мира реализован полностью и согласован с этапом (TODO_05), сериализацией, обучаемостью, LoRA-world, multi-endpoint и каноном Scheme/World_Serialization.
