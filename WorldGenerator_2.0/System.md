# Система: от основания до мира

Описание системы **с самого основания** — от фундаментальных сущностей до полного цикла мира. Один файл, снизу вверх.

---

## 1. Основание: два начала

Вся система держится на двух взаимосвязанных началах:

| Начало | В проекте | Смысл |
|--------|------------|--------|
| **Материальное** | То, что **хранит** и **несёт**: параметры, тензоры, данные, конфигурация, состояние. | Материя — то, из чего собирается система и что передаётся по цепочкам. |
| **Идеальное** | То, что задаёт **связи**, **порядок** и **логику превращения**: как блоки соединяются, как данные текут. | Идея — форма, в которую складывается материя; порядок и композиция. |

Без материи нечего выполнять; без идеи нет структуры и связей. Оба начала необходимы.

---

## 2. Фундамент: блок и узел графа

На фундаментальном уровне вводятся **две сущности** и **одно правило**.

### 2.1 Abstract Base Block (блок) — материальное начало

- **Блок** — минимальная единица системы: что-то хранит (параметры, тензоры, конфиг, состояние) и что-то вычисляет.
- **Контракт:** объявляет входы/выходы (порты), выполняется по входам, идентифицируется (`block_type`, `block_id`).
- Всё материальное в системе — блоки или композиции блоков. Модели, кодекы, солверы, пайплайны — в основе блоки.

### 2.2 Abstract Graph Node (узел графа) — идеальное начало

- **Узел** — место или роль в графе. Не хранит данные сам — задаёт **положение** и **связи** (рёбра к другим узлам).
- В узле всегда находится блок (материя); узел задаёт, **как** этот блок встроен в целое — куда подключён, откуда и куда идут потоки.

### 2.3 Правило: блок → узел

- **Любой блок может быть помещён в узел графа.** Материя (блок) получает идеальную форму (место и связи), не переставая быть блоком.
- **Система как целое** — граф, узлы которого — блоки; рёбра задают потоки данных между портами. Содержимое узлов — материя; структура графа — идея.

---

## 2.4 Уровень над фундаментом (узлы-задачи)

Над блоком и узлом располагается уровень **абстрактных узлов-задач**: Abstract Backbone, Solver, Codec, Adapter, Conditioner, Tokenizer, Guidance и др. Каждая такая сущность **одновременно** блок и узел и задаёт **спецификацию задачи** (роль в графе, контракт портов, семантику выполнения). Из конкретных реализаций (UNet2D, DDIMSolver, VAE, LoRA, CLIP и т.д.) **собирается граф**. Полное описание: [Abstract_Task_Nodes.md](Abstract_Task_Nodes.md).

### 2.5 Уровень графа: первый исполняемый уровень; одна задача

**Граф** — первый уровень, на котором система **исполняется**, и при этом **одна цельная задача** (text-to-image, image-to-video, upscale, image-to-image, распознавание и т.д.). Граф состоит из узлов-задач (Backbone, Solver, Codec, Conditioner, Tokenizer, …), собирается через Graph.AddNode(...); узлы автоматически понимают свою роль. Ниже графа — только спецификации. Подробно: [Graph_Level.md](Graph_Level.md).

### 2.6 Уровень пайплайна: графы как узлы для комбинированных задач

**Пайплайн** — **граф, узлами которого являются другие графы**; служит для **сложных комбинированных задач** (например, текст → картинка → апскейл → видео). Каждый узел пайплайна — целый граф одной задачи; рёбра пайплайна соединяют выходы одного графа с входами другого. Подробно: [Pipeline_Level.md](Pipeline_Level.md).

### 2.7 Уровень этапа (Stage): граф пайплайнов

**Этап (Stage)** — уровень выше пайплайна и графа. **Этап — граф пайплайнов:** узлами этапа являются пайплайны (пайплайн может состоять из одного графа). Рёбра этапа соединяют выходы одного пайплайна с входами другого; между этапами в цикле мира передаётся state. **Этап как фаза — первая сущность, которая исполняет свою роль в цикле мира:** цикл мира собран из этапов (Философ, Автор, Среда, Архитектор, Творец), каждое звено — этап со своей ролью. Подробно: [Stage_Level.md](Stage_Level.md).

---

## 3. Принцип: Lego

- Всё собирается как **конструктор**: любой блок с любым блоком в рамках правил (порты, типы).
- Порядок и количество блоков не предписаны сверху. Максимальная свобода сборки при единой основе — блок и узел графа.

---

## 4. Верхний уровень: мир как граф этапов

**Мир (World)** — **граф этапов** ([World_Level.md](World_Level.md)): узлами мира являются этапы, по рёбрам передаётся state. В каноне — **циклический граф**. **Этап как фаза — первая сущность, исполняющая свою роль в цикле мира:** каждое звено цикла есть этап (Философ, Автор, Среда, Архитектор, Творец); мир собран из этапов. **Циклический граф из пяти звеньев** (каждое звено — этап):

```
  Философ  →  Автор  →  Среда  →  Архитектор  →  Творец  →  …
```

- **Философ (Philosopher)** — выполняется **только если заполнены блоки 1, 2, 3**; иначе пропускается. Описывает **блок 3** (содержимое артефактов) → **блок 4**. Не генерирует артефакты по блоку 2 — это делает Творец.
- **Автор (Author)** — выполняется **только если заполнены блоки 1, 2, 3, 4**; иначе пропускается. В ядре LLM. Контекст — **неизменённый мир**; **контекст = state**. Генерирует **описание** (блок 5) по блокам 1–4.
- **Среда (Environment)** — **два узла подряд:** (1) **World update** — выполняется **только при полностью заполненном state** (все 5 блоков); иначе пропуск; (2) **Development of the world** — создаёт новый state с блоком 1, выполняется безусловно; получает **Action как контекст для LLM** (если передан).
- **Архитектор (Architect)** — выполняется при заполненном блоке 1; по потоку цикла всегда получает state в нужном виде. В ядре LLM. Контекст — **изменённый мир**; **контекст = state**. Генерирует **конфигурацию** (блок 2) по описанию (блок 1).
- **Творец (Creator)** — выполняется при заполненном блоке 2; по потоку цикла всегда получает state в нужном виде. Генерирует артефакты (блок 3); замыкание цикла.

Между переходами передаётся **state**. Каждый переход читает и/или дополняет state.

---

## 5. State: пять блоков

**State** (состояние мира) задаётся **пятью блоками**:

| № | Блок |
|---|------|
| 1 | Описание того, что должно было произойти |
| 2 | Конфигурация для генерации артефактов |
| 3 | Сгенерированные артефакты |
| 4 | Описание сгенерированных артефактов |
| 5 | Описание того, что реально произошло в мире |

**World update** выполняется **только при полностью заполненном state** (все пять блоков 1–5): тогда state применяется к миру, контент мира обновляется, state сохраняется. Иначе World update не выполняется, state снимается с обработки.

---

## 6. Среда: два узла

**Среда (Environment)** в графе мира — **два последовательных узла**:

| Узел | Вход | Условие / Действие |
|------|------|---------------------|
| **World update** | State | Выполняется **только если state полностью заполнен** (все 5 блоков). Тогда — применить state к миру, сохранить. Иначе — пропустить. |
| **Development of the world** | Опционально Action | Безусловно: читать мир; с учётом Action (если есть) или без него генерировать описание; создавать **новый state** с блоком 1. |

После Development новый state идёт в Архитектор → Творец → Философ → Автор → Среда. Цикл повторяется.

---

## 7. Action и передача state пользователем

- **Action** поступает в **Development of the world** как **контекст для языковой модели**. Action **опционален**: при его отсутствии Development выполняется **безусловно** и создаёт следующий эпизод по текущему состоянию мира.
- **Пользователь не передал state** (или пустой state): на **первой итерации** пропускаются **Философ**, **Автор** и **World update**. Цикл **начинается с Development of the world** — он создаёт **первый state** в мире (блок 1); затем state идёт в Архитектор → Творец → … и т.д.
- **Передача state пользователем** (первая итерация или внешний вход): этап выполняется только при заполненных нужных блоках; **World update — только при полностью заполненном state** (все 5 блоков). Только блок 1 или блоки 1–2 — Философ и Автор пропускаются, **World update не выполняется**. Блоки 1–2–3 — Философ, затем Автор → блок 5 → World update. Блоки 1–2–3–4 — Автор → блок 5 → World update. Блоки 1–2–3–4–5 — World update. Подробно: [Scheme.md](Scheme.md) §4.8.
- **Со второй итерации** (когда state уже есть): после Development state с блоком 1 идёт по цепочке Архитектор → Творец → Философ → Автор → Среда. **Мир развивается итеративно сам**, без участия пользователя.

---

## 8. Жизненный цикл (один проход)

1. **Development of the world** (опционально Action) → новый state с блоком 1.
2. **Архитектор** → блок 2 (конфигурация).
3. **Творец** → блок 3 (артефакты).
4. **Философ** → только описывает блок 3 (содержимое артефактов), результат в блок 4.
5. **Автор** → по блокам 1–4 генерирует нарратив «что реально произошло» (блок 5); при только блоке 1 — копия блока 1 в блок 5.
6. **Среда:** **World update** (при блоке 5 — применить к миру, сохранить state); **Development of the world** → новый state с блоком 1.
7. Переход к шагу 1; цикл повторяется.

---

## 9. Сводка снизу вверх

| Уровень | Сущность |
|---------|----------|
| **Основание** | Два начала: материальное (хранит, несёт) и идеальное (связи, порядок). |
| **Фундамент** | Abstract Base Block (материя), Abstract Graph Node (идея); правило «блок → узел». |
| **Принцип** | Lego: всё из блоков, свобода сборки. |
| **Мир** | Циклический граф: Философ → Автор → Среда → Архитектор → Творец. |
| **State** | Пять блоков; World update только при блоке 5. |
| **Среда** | Два узла: World update (State → мир при блоке 5), Development of the world (Action как контекст для LLM, безусловно → новый state с блоком 1). |
| **Режим** | Мир один; может развиваться сам, итеративно, без Action. |

**Сериализация:** мир полностью сериализуем в конфиг/шаблон; загрузка, генерация из шаблона, обученный мир — [World_Serialization.md](World_Serialization.md).

Детали операционной схемы — [Scheme.md](Scheme.md). Философская проработка блоков и узлов — [Philosophy.md](Philosophy.md).
