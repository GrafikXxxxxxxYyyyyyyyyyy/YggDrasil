# TODO 02: Узлы-задачи (Abstract Task Nodes) и уровень графа (Graph)

Пошаговый список того, **что должно быть реализовано**, **как**, **что должно поддерживаться** и **как это соотносится со всем проектом** — для **полной реализации уровня над фундаментом и первого исполняемого уровня (граф)**. Учтены: любые модели (LLM, VLM, диффузия, любая архитектура), полная обучаемость, полная сериализуемость, Lego-сборка, автоматизация и удобство для пользователя.

**Канон:** [Abstract_Task_Nodes.md](Abstract_Task_Nodes.md), [Graph_Level.md](Graph_Level.md). Фундамент: [TODO_01_FOUNDATION.md](TODO_01_FOUNDATION.md). Сериализация: [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md). Обучаемость: [TRAINABILITY_AT_ALL_LEVELS.md](TRAINABILITY_AT_ALL_LEVELS.md). Масштабируемость: [SCALABILITY_AND_EXTENSIBILITY.md](SCALABILITY_AND_EXTENSIBILITY.md). Multi-endpoint: [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md).

**Границы этого TODO:** (1) Абстрактные узлы-задачи — все типы, контракты портов, типичные связи, регистрация; (2) Граф — сборка через AddNode (с авто-связыванием по ролям), рёбра, исполнитель, входы/выходы графа, сериализация структуры и весов, загрузка из чекпоинта, обучение подмножества узлов, сборка из конфига/шаблона, валидация. Всё как Lego, всё сериализуемо, всё обучаемо, удобно и автоматизировано.

**Учёт нового канона:** (1) **Модели через API** ([LLM_API_SUPPORT.md](LLM_API_SUPPORT.md)) — узлы-задачи типа LLM (и при расширении VLM, эмбеддинги и т.д.) должны поддерживать режим «только API»; регистрация типов вида `llm/api`, `llm/openai`, `llm/anthropic`; контракт портов единый для локального и API. (2) **Повторное использование моделей** ([MODEL_REUSE.md](MODEL_REUSE.md)) — при сборке графа один checkpoint_ref/model_id → один экземпляр блока. (3) **Обучение при reuse и API:** [TRAINING_REUSE_AND_API_SCENARIOS.md](TRAINING_REUSE_AND_API_SCENARIOS.md).

### Пункты к реализации на этапе 02 (новый канон)

- [ ] **Узлы LLM (и др.) через API:** регистрация блоков с `backend: "api"` под типами `llm/api`, `llm/openai`, `llm/anthropic` (и при необходимости vlm/api, embedding/api и т.д.); конфиг узла с `provider`, `model_id`; при add_node(block_type, config=...) блок создаётся без загрузки весов, forward — вызов API.
- [ ] **Пул при сборке графа:** при add_node(block_type, config) и при from_config: если в config указан тот же checkpoint_ref или model_id, что и у уже существующего узла графа, не создавать новый блок — использовать существующий (пул ref→блок на уровне графа или переданный в add_node/from_config).
- [ ] **Сериализация ref в конфиге узла:** в to_config() для каждого узла сохранять checkpoint_ref/model_id, чтобы при from_config пул применялся корректно; при load_from_checkpoint один ref → один load_state_dict (для API state_dict может быть пустым).

---

## Связь с остальным проектом

| Компонент | Как опирается на этот уровень |
|-----------|-------------------------------|
| **Фундамент (TODO_01)** | Узлы-задачи наследуют Abstract Base Block; граф состоит из узлов (блок в обёртке узла) и рёбер. Без фундамента нет блоков и портов. |
| **Пайплайн** | Узлы пайплайна = **целые графы**; каждый граф имеет контракт входа/выхода задачи; пайплайн соединяет графы по этим портам. Граф — единица развёртывания (один граф = один эндпоинт). |
| **Этап / Мир** | Этап = граф пайплайнов; мир = граф этапов. Внутри этапов — пайплайны и графы; state течёт между этапами. Цикл мира (Философ, Автор, Среда, Архитектор, Творец) на верхнем уровне опирается на графы как исполняемые единицы. |
| **Сериализация на всех уровнях** | Граф сериализует структуру (узлы, рёбра, I/O) и веса (все блоки узлов); загрузка графа из чекпоинта; без этого невозможна сериализация пайплайна и мира. |
| **Обучаемость** | На уровне графа обучается выбранное подмножество узлов (блоков); граф даёт топологию и вызов forward; оптимизатор получает параметры выбранных узлов. LoRA/адаптеры — узлы графа; заморозка/разморозка по конфигу. |
| **Любые модели (LLM, VLM, диффузия, любая архитектура)** | Backbone, Conditioner, Codec и т.д. — абстракции; конкретная реализация (трансформер, UNet, VAE, CLIP) подключается как блок с контрактом портов. Граф не зависит от внутренней архитектуры блока. |
| **Multi-endpoint** | Граф — естественная единица развёртывания: один граф = одна задача = один эндпоинт; контракт входа/выхода графа задаёт API сервиса. |
| **Lego, автоматизация, UX** | AddNode с авто-связыванием по ролям; сборка графа в несколько строк; from_config/from_template; валидация и подсказки при ошибках. |

Итого: уровень узлов-задач и графа — **первый уровень, на котором система исполняется** и на котором пользователь собирает задачу как конструктор; от него зависят пайплайн, этап, мир, сериализация, обучение и развёртывание.

---

# ЧАСТЬ A: Абстрактные узлы-задачи (Abstract Task Nodes)

## A.1 Общие требования к уровню узлов-задач

### A.1.1 Что реализовать

- [ ] **Двойное наследование:** каждая абстракция узла-задачи — одновременно Block (хранит, выполняется, порты, block_type, block_id, state_dict) и концептуально Node (роль в графе, типичные связи). В коде: класс наследует Abstract Base Block и объявляет **роль** (backbone, solver, codec, …) и **типичные связи** с другими ролями.
- [ ] **Спецификация задачи для каждого типа:** семантика узла (что узел «делает»), контракт портов (имена, типы, направление, опциональность), семантика выполнения (один вызов = что именно), типичные связи (с какими типами узлов соединяется, какие порты с какими).
- [ ] **Реестр типов:** все конкретные реализации (UNet2D, DDIMSolver, AutoencoderKL, CLIPEncoder, BPE, LoRA, …) регистрируются под строковым идентификатором (например, `backbone/unet2d`, `solver/ddim`, `codec/vae`). Создание из конфига: по `block_type` из реестра создаётся экземпляр; конфиг передаётся в конструктор. Поддержка **любых моделей**: пользователь регистрирует свой класс под своим типом — граф собирается из конфига без изменения ядра.
- [ ] **Сериализуемость:** каждый узел-задача — блок; конфиг блока (block_type, параметры) и state_dict сериализуемы; загрузка из чекпоинта на уровне блока (TODO_01) применяется к каждому узлу-задаче. Никаких «особых» форматов только для узлов-задач — только расширение контракта блока.
- [ ] **Обучаемость:** каждый узел-задача с обучаемыми параметрами предоставляет `trainable_parameters()` (или эквивалент); заморозка/разморозка по конфигу или по API; LoRA и адаптеры — такие же узлы, обучаются на уровне графа выборочно.

### A.1.2 Как реализовать

- Абстрактные классы: `AbstractBackbone(AbstractBaseBlock)`, `AbstractSolver(AbstractBaseBlock)`, … Каждый объявляет `block_type` (базовый, например `"backbone"`), объявляет порты через `declare_ports()` (или статический список), реализует `forward(inputs)` по контракту. Конкретные классы (UNet2D, DDIM, …) наследуют абстрактный тип, задают подтип (например `"backbone/unet2d"`), заполняют хранилище и логику.
- **Таблица типичных связей (role rules):** по роли узла (backbone, solver, codec, conditioner, tokenizer, adapter, guidance) система знает: какой порт данного узла с каким портом какого другого типа узла типично соединяется. Например: backbone.pred → solver.pred; conditioner.embedding → backbone.condition; solver.next_latent → backbone.latent (в цикле). Эта таблица используется для **авто-связывания** при AddNode (см. часть B).
- **Lego:** пользователь может добавить узел любого зарегистрированного типа; при добавлении опционально автоматически создаются рёбра по типичным связям к уже существующим узлам подходящего типа. Явное `add_edge` всегда доступно для нестандартных связей.

### A.1.3 Что должно поддерживаться

- [ ] **Любые модели:** LLM (как backbone или conditioner с соответствующей семантикой портов), VLM, любая диффузионная модель, любая нейросетевая архитектура — подключаются как реализации абстрактного типа с контрактом портов. Внутренняя архитектура инкапсулирована в блоке.
- [ ] **Расширяемость без изменения ядра:** новый тип блока (новый backbone, новый solver) — новый класс + регистрация в реестре; граф и конфиг сразу поддерживают его.
- [ ] **Удобство для пользователя:** сборка графа в несколько вызовов AddNode с минимумом ручного указания рёбер за счёт авто-связывания по ролям.

---

## A.2 Abstract Backbone

- [ ] **Определение и контракт:** узел выполняет **шаг предсказания** модели. Порты: входы `latent` (или `x`), `timestep` (или `t`), `condition` (опционально); выход `pred` (или `noise`, `x0`). Типы — тензор (и словарь для condition при необходимости). Семантика выполнения: один forward pass по текущему состоянию → предсказание.
- [ ] **Типичные связи:** latent от Codec или Solver; timestep от расписания/Solver; condition от Conditioner; pred в Solver или во внешний выход. Участвует в цикле Backbone ↔ Solver (N шагов).
- [ ] **Реализации:** регистрация под типами вида `backbone/unet2d`, `backbone/transformer`, `backbone/dit` и т.д. Поддержка диффузии, flow-matching, consistency, а также не-диффузионных backbone (например, классификация) через единый контракт портов.
- [ ] **Обучаемость и сериализация:** веса backbone сериализуются; загрузка из чекпоинта; trainable_parameters(); опционально слот для адаптеров (LoRA, ControlNet) — порт `adapter_features` или эквивалент.

---

## A.3 Abstract Solver

- [ ] **Определение и контракт:** узел выполняет **один шаг дискретизации** по времени. Порты: входы `latent`, `timestep`, `pred` (модель от Backbone); выходы `next_latent`, `next_timestep`. Семантика: по формуле схемы (DDIM, Euler, …) вычислить следующее состояние.
- [ ] **Типичные связи:** latent, timestep от предыдущего Solver или от начального состояния; pred от Backbone; next_latent, next_timestep в следующий вызов Backbone и снова в Solver (цикл) или во внешний выход.
- [ ] **Реализации:** DDIM, DDPM, Euler, Heun, flow-matching solver и т.д.; регистрация под `solver/ddim`, `solver/euler` и т.д. Обычно без обучаемых весов; конфиг и опционально кэш расписания сериализуемы.
- [ ] **Совместимость с любым процессом:** солвер не привязан к одной диффузии; контракт «latent, timestep, pred → next_latent, next_timestep» универсален.

---

## A.4 Abstract Codec

- [ ] **Определение и контракт:** узел выполняет **encode** и/или **decode** (переход между пространствами, например пиксели ↔ латенты). Порты: для encode — вход `image`/`pixels`, выход `latent`; для decode — вход `latent`, выход `image`/`pixels`. Может быть один узел с разными портами/режимами или два узла (encode_codec, decode_codec).
- [ ] **Типичные связи:** encode: image от внешнего входа или предыдущего узла, latent в Solver/Backbone; decode: latent от Solver (финальное состояние), image во внешний выход.
- [ ] **Реализации:** VAE (AutoencoderKL), VQ-VAE, кодек для видео/аудио; регистрация под `codec/vae`, `codec/vqgan` и т.д. Полная сериализация весов и загрузка из чекпоинта; обучаемость при необходимости.
- [ ] **Lego:** один граф может содержать несколько кодеков (например, для разных разрешений или модальностей), если контракт портов соблюдён.

---

## A.5 Abstract Conditioner

- [ ] **Определение и контракт:** узел **кодирует условие** (текст, изображение, аудио и т.д.) в форму для Backbone/Adapter. Порты: вход `input` (или `text`, `image`, `prompt`, `token_ids`); выход `embedding` (или `encoder_hidden_states`, `condition`). Может быть несколько выходных портов (pooled + hidden states).
- [ ] **Типичные связи:** input от внешнего входа графа или от Tokenizer (token_ids); embedding в Backbone (condition), в Adapter или в несколько потребителей.
- [ ] **Реализации:** CLIP text/image, T5, BERT, любой энкодер условия; регистрация под `conditioner/clip`, `conditioner/t5` и т.д. Поддержка LLM/VLM как энкодеров условия через тот же контракт. Сериализация и обучаемость.
- [ ] **Любые модели:** новые энкодеры подключаются как реализации Conditioner с объявленными портами.

---

## A.6 Abstract Tokenizer

- [ ] **Определение и контракт:** узел преобразует **текст ↔ токены**. Порты: encode — вход `text`, выходы `token_ids`, опционально `attention_mask`; decode — вход `token_ids`, выход `text`. Один узел может использоваться для нескольких потребителей (один словарь для нескольких Conditioner’ов).
- [ ] **Типичные связи:** text от внешнего входа; token_ids в Conditioner или в LLM. Явная граница текст↔токены упрощает сериализацию словаря и конфиг мира.
- [ ] **Реализации:** BPE, SentencePiece, WordPiece; регистрация под `tokenizer/bpe`, `tokenizer/sentencepiece` и т.д. Хранилище: словарь, мержи; сериализуемы (конфиг + опционально файлы словаря). Обычно без обучаемых весов.
- [ ] **Сериализуемость:** словарь и мержи входят в конфиг узла или в отдельные файлы, чтобы мир/граф воспроизводились на другой машине.

---

## A.7 Abstract Adapter

- [ ] **Определение и контракт:** узел **адаптирует** сигнал (LoRA, ControlNet, инжектор стиля и т.д.). Порты: входы `condition` (или `control`, `style`), опционально `hidden` (активации); выход `adapted` (или delta для сложения с hidden в другом узле).
- [ ] **Типичные связи:** condition от Conditioner или внешнего входа; hidden от Backbone (промежуточные слои); adapted обратно в Backbone или в агрегирующий узел.
- [ ] **Реализации:** LoRA, ControlNet, T2I-Adapter, IP-Adapter и т.д.; регистрация под `adapter/lora`, `adapter/controlnet` и т.д. Обучаемость: часто обучаются только адаптеры при замороженном backbone; полная сериализация весов и загрузка из чекпоинта.
- [ ] **Lego и LoRA-мир:** механизм «LoRA на весь мир» (LORA_WORLD_LIGHTWEIGHT_CUSTOM) опирается на то, что адаптеры — такие же узлы графа; их можно добавлять ко всем нужным блокам и обучать выборочно.

---

## A.8 Abstract Guidance

- [ ] **Определение и контракт:** узел **корректирует предсказание** (CFG, PAG, reward-based и т.д.). Порты: входы `pred_cond`, `pred_uncond`, опционально `scale`; выход `pred_guided`. Варианты: один вход pred + condition и внутренняя логика.
- [ ] **Типичные связи:** pred_cond, pred_uncond от двух вызовов Backbone (условный и безусловный); pred_guided в Solver или во внешний выход.
- [ ] **Реализации:** CFG block, PAG, FreeU, SAG и т.д.; регистрация под `guidance/cfg`, `guidance/pag` и т.д. Сериализация конфига; при наличии весов — state_dict.
- [ ] **Опциональность:** граф может быть без Guidance (например, без CFG); порт опциональный или узел не добавляется.

---

## A.9 Дополнительные абстрактные типы (по необходимости)

- [ ] **Abstract NoiseSchedule:** расписание шума (sigma, alpha по таймстепу). Порты: вход `timestep`; выходы `sigma`, `alpha` и т.д. Реализации: linear, cosine, sigmoid; регистрация; сериализуемость конфига.
- [ ] **Abstract PositionEmbedder:** позиционное кодирование для таймстепа/позиции. Порты: вход indices/timestep; выход embedding. Реализации: sinusoidal, RoPE, learned. Сериализация весов при наличии.
- [ ] **Abstract Pooler / Abstract Projection:** при необходимости для агрегации последовательности или изменения размерности; контракт портов и регистрация по тому же принципу.

Все перечисленные типы должны следовать одному правилу: **двойное наследование Block + роль**, **контракт портов**, **типичные связи** для авто-связывания, **полная сериализуемость и обучаемость**, **поддержка любых конкретных реализаций** через реестр.

---

## A.10 Таблица типичных связей (Role Rules) для авто-связывания

- [ ] **Реализовать таблицу (или конфиг) правил:** для каждой пары (роль_источника, роль_приёмника) — какие порты источника с какими портами приёмника соединять по умолчанию. Примеры: (tokenizer, conditioner) → tokenizer.token_ids → conditioner.input; (conditioner, backbone) → conditioner.embedding → backbone.condition; (backbone, solver) → backbone.pred → solver.pred; (solver, backbone) → solver.next_latent → backbone.latent, solver.next_timestep → backbone.timestep. При добавлении узла с `auto_connect=True` система ищет в графе узлы с подходящими ролями и добавляет рёбра по этим правилам.
- [ ] **Разрешение неоднозначности:** если несколько кандидатов (несколько conditioner’ов), политика: соединять с «первым подходящим», или с узлом с заданным node_id, или не соединять автоматически и требовать явного add_edge. Должно быть документировано и при необходимости конфигурируемо.
- [ ] **Циклы:** правило для (solver, backbone) и (backbone, solver) задаёт цикл; при авто-связывании не создавать дублирующих рёбер; порядок добавления узлов может требовать двух проходов (сначала все узлы, затем авто-связывание по ролям) или инкрементального обновления при каждом AddNode.

---

# ЧАСТЬ B: Уровень графа (Graph)

## B.1 Граф — одна цельная задача

- [ ] **Определение:** граф = контейнер узлов (каждый узел = блок + node_id + рёбра) и рёбер. **Один граф = одна законченная задача** (text-to-image, image-to-video, upscale, распознавание, текст→текст и т.д.). Внутри графа — полная реализация задачи (все нужные узлы-задачи); комбинирование нескольких задач — на уровне пайплайна (узлы пайплайна = графы).
- [ ] **Состав:** узлы — экземпляры узлов-задач (Backbone, Solver, Codec, Conditioner, Tokenizer, Adapter, Guidance, …); рёбра соединяют порты узлов. Граф не привязан к одной модальности или одной архитектуре: любые зарегистрированные типы блоков могут входить в граф при соблюдении контракта портов.
- [ ] **Связь с проектом:** граф — первый исполняемый уровень; пайплайн, этап, мир строятся поверх графов; сериализация графа (структура + веса) и загрузка из чекпоинта обязательны для сериализации на всех уровнях и для multi-endpoint (один граф = один эндпоинт).

---

## B.2 Сборка графа: AddNode и рёбра

### B.2.1 Что реализовать

- [ ] **AddNode(block_or_type, node_id=None, config=None, auto_connect=True):** добавить узел в граф. Варианты: (1) передать готовый экземпляр блока (block_or_type — блок), тогда node_id задаётся или генерируется; (2) передать тип (строка block_type) и опционально config — тогда блок создаётся через реестр, узел создаётся с этим блоком. Если `auto_connect=True`, по таблице типичных связей (role rules) автоматически создаются рёбра к уже существующим узлам подходящих ролей (порты совместимы по типам).
- [ ] **AddEdge(source_node_id, source_port, target_node_id, target_port):** явно добавить ребро. Валидация: узлы существуют, порты существуют, типы совместимы. Обязательно поддерживается для нестандартных связей и для полного контроля пользователя.
- [ ] **Уникальность node_id:** каждый узел в графе имеет уникальный node_id (строка или ID); при добавлении без node_id генерировать уникальный (например, role + счётчик или uuid).
- [ ] **Удобство (Lego, UX):** сборка графа для типовой задачи (например, text-to-image) в несколько строк: AddNode(Tokenizer), AddNode(Conditioner), AddNode(Backbone), AddNode(Solver), AddNode(Codec) с auto_connect=True; при необходимости один или несколько add_edge для переопределения. Документация и примеры для типовых сценариев.

### B.2.2 Как реализовать

- Граф хранит: словарь node_id → Node (узел содержит block, in_edges/out_edges или граф хранит список рёбер централизованно). AddNode: создать блок (если передан тип — через Registry.build(config)), создать узел, добавить в граф; если auto_connect — вызвать функцию применения role rules (найти узлы по роли, для каждой пары (новая_роль, существующая_роль) проверить таблицу правил, добавить рёбра с проверкой типов портов).
- Роли узлов определяются по block_type (префикс или полное совпадение: backbone, solver, codec, conditioner, tokenizer, adapter, guidance). Таблица правил: (role_src, role_dst) → [(port_src, port_dst), …].

### B.2.3 Что должно поддерживаться

- [ ] **Любые комбинации узлов:** граф может содержать несколько Backbone’ов, несколько Conditioner’ов, адаптеры, guidance или без него — в зависимости от задачи. Валидация только по портам и типам, без жёсткого шаблона «ровно один backbone».
- [ ] **Циклы:** граф может содержать цикл (Backbone ↔ Solver на N итерациях). Исполнитель должен поддерживать итеративное выполнение по циклу (фиксированное число шагов или до условия). Топологическая сортировка при наличии циклов — по особым правилам (выделение сильно связных компонент, порядок обхода по циклу задаётся явно или по типу узлов).
- [ ] **Внешние входы и выходы графа:** явно помечать порты узлов как «вход графа» или «выход графа» (expose_input(node_id, port_name), expose_output(node_id, port_name)); или выводить автоматически: вход = порт без входящего ребра от другого узла, выход = порт без исходящего ребра или помеченный. Контракт графа как единицы: список имён входных портов и список имён выходных портов (с привязкой к node_id.port_name).

---

## B.3 Исполнитель графа (Executor)

- [ ] **Run(graph, inputs) -> outputs:** входы — словарь по именам внешних входов графа (или по (node_id, port_name)); выходы — словарь по именам внешних выходов. Исполнитель: (1) топологическая сортировка узлов (с учётом циклов: узлы в цикле обрабатываются итеративно); (2) для каждого узла собрать значения на входных портах из кэша (результаты предыдущих узлов и внешние входы); (3) вызвать block.forward(inputs) узла; (4) записать выходы в кэш по исходящим рёбрам; (5) для цикла — повторять шаги 2–4 для узлов цикла N раз (N задаётся конфигом графа или параметром run). Возврат: значения на внешних выходах графа.
- [ ] **Поддержка циклов:** параметр `num_steps` или `denoise_steps` для цикла backbone–solver; начальные латенты и таймстеп подаются снаружи или от кодеков; после N шагов выход — финальные латенты (и затем decode в кодеке, если в графе). Реализация: выделить подграф цикла, в run вызывать его N раз, передавая состояние (latent, timestep) между итерациями.
- [ ] **Режимы train/eval:** при выполнении графа блоки могут переключать режим (train/eval); исполнитель принимает опциональный параметр `training=True/False` и передаёт его в блоки или граф устанавливает режим до run.
- [ ] **Удобство:** один вызов run с минимальными аргументами (например, только prompt и num_steps для text-to-image); остальные параметры (размер, seed и т.д.) из конфига графа или из значений по умолчанию. Опционально: прогресс-бар, хуки на каждый шаг для отладки и кастомной логики.

---

## B.4 Сериализация графа и загрузка из чекпоинта

- [ ] **Сериализация структуры:** граф сохраняется в конфиг (YAML/JSON): список узлов (для каждого: node_id, block_type, config блока), список рёбер (source_node, source_port, target_node, target_port), внешние входы и выходы графа (список (node_id, port_name)). Из конфига можно восстановить граф без весов (блоки создаются через реестр).
- [ ] **Сериализация весов:** веса графа = совокупность state_dict всех блоков в узлах. Формат: один файл с объединённым state_dict (ключи с префиксом node_id или block_id) или каталог с файлами по узлам. Выбор формата конфигурируем (один файл удобен для переноса, каталог — для инкрементального сохранения). Соответствие [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md): на уровне графа веса сериализуются полностью.
- [ ] **Загрузка графа из чекпоинта:** API `Graph.load_from_checkpoint(config_path, checkpoint_path)` или `Graph.load_from_checkpoint(checkpoint_dir)` (если конфиг встроен в каталог): (1) загрузить конфиг графа; (2) для каждого узла создать блок через реестр по block_type и config; (3) создать рёбра; (4) загрузить чекпоинт весов в каждый блок (по node_id/block_id). После загрузки граф готов к run и к обучению.
- [ ] **Сохранение графа:** `graph.save_config(path)`, `graph.save_checkpoint(path)` или `graph.save(path_dir)` (конфиг + чекпоинт в каталог). Полная воспроизводимость: конфиг + чекпоинт достаточны для восстановления графа на другой машине.

---

## B.5 Обучаемость на уровне графа

- [ ] **Выбор обучаемых узлов:** конфиг или API задаёт, какие узлы (node_id) trainable, какие frozen. Пример: train только adapter и conditioner, backbone и codec заморожены. Метод `graph.trainable_parameters()` возвращает параметры только выбранных узлов (для передачи в оптимизатор).
- [ ] **Обучение:** внешний Trainer или пользовательский цикл: forward по графу (executor.run в режиме training), вычисление loss по выходам графа или по выходам выбранных узлов, backward по trainable параметрам, step оптимизатора. Граф не обязан содержать узел Loss — loss может вычисляться снаружи по выходам графа. При необходимости узел Loss может быть добавлен как блок с портами (target, prediction) и выходом loss; тогда граф с loss-узлом обучается одним вызовом run (если исполнитель поддерживает градиенты).
- [ ] **Чекпоинты при обучении:** сохранение графа (конфиг + веса) после эпохи или по расписанию; возобновление обучения из чекпоинта (загрузка графа + загрузка состояния оптимизатора при необходимости). Соответствие [TRAINABILITY_AT_ALL_LEVELS.md](TRAINABILITY_AT_ALL_LEVELS.md): на уровне графа обучается любое подмножество узлов с полной сериализуемостью.

---

## B.6 Сборка из конфига и шаблонов (автоматизация, UX)

- [ ] **From_config:** `Graph.from_config(config)` или `Graph.from_yaml(path)` — создать граф из словаря/файла: узлы по списку (block_type, config, node_id), рёбра по списку, внешние I/O. Конфиг полностью сериализуем; пользователь может редактировать YAML/JSON без кода. Поддержка включения подконфигов (например, конфиги блоков в отдельных файлах).
- [ ] **From_template:** `Graph.from_template(template_name, **kwargs)` — предопределённые шаблоны (например, `text_to_image`, `image_to_video`, `upscale`) собирают граф из зарегистрированных узлов с типовыми параметрами; kwargs подставляются в конфиг (например, model_id, resolution, num_steps). Шаблон = функция или конфиг-генератор, возвращающий конфиг графа; сборка через from_config. Удобство: одна строка для типовой задачи.
- [ ] **Валидация при загрузке:** при from_config проверять существование block_type в реестре, совместимость портов на рёбрах, наличие обязательных входов; при ошибке — понятное сообщение и, по возможности, подсказка (похожие имена типов, типичные исправления). Автоматизация и удобство: пользователь получает быструю обратную связь.

---

## B.7 Валидация графа

- [ ] **При добавлении ребра:** проверка существования узлов и портов, совместимость типов портов (и при необходимости shape/dtype). Опционально: предупреждение, если обязательный вход узла остаётся без входящего ребра после сборки.
- [ ] **Перед run (опционально):** полная проверка: все обязательные входы графа заданы; все обязательные входы узлов имеют входящее ребро или значение по умолчанию; циклы разрешены и заданы параметры (num_steps). При несоответствии — явная ошибка с указанием узла/порта.
- [ ] **Связь с типичными связями:** валидатор может проверять соответствие графа «шаблону» задачи (например, наличие хотя бы одного backbone, solver, codec для диффузии изображений), но не должен запрещать нестандартные графы — только предупреждать при необходимости.

---

## B.8 Multi-endpoint и граф как единица развёртывания

- [ ] **Контракт графа как сервиса:** входы и выходы графа образуют контракт API: один вызов сервиса = передача входов (например, prompt, image, num_steps) и получение выходов (image, latents, …). Сериализация входов/выходов (JSON, бинарные артефакты по ссылкам или base64) должна быть определена для типа портов (см. [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md)).
- [ ] **Развёртывание одного графа на эндпоинт:** при развёртывании на несколько эндпоинтов каждый граф может быть экспортирован как отдельный сервис (конфиг графа + чекпоинт загружаются на сервер; API = run(graph, inputs) -> outputs). Реализация этого сервиса (HTTP/gRPC) может быть в отдельном модуле; данный TODO требует только того, чтобы граф имел чёткий контракт входа/выхода и был полностью сериализуем.

---

## B.9 Критерии приёмки (узлы-задачи + граф)

- [ ] Все абстрактные типы (Backbone, Solver, Codec, Conditioner, Tokenizer, Adapter, Guidance + опционально NoiseSchedule, PositionEmbedder) реализованы как абстракции с контрактом портов и типичными связями; конкретные реализации регистрируются в реестре; создание из конфига по block_type работает.
- [ ] Граф собирается через AddNode (с опциональным auto_connect) и add_edge; исполнитель выполняет граф (run с учётом циклов); внешние входы и выходы графа заданы; граф реализует одну целевую задачу.
- [ ] Граф полностью сериализуем (структура в конфиг, веса в чекпоинт) и загружается из чекпоинта; после загрузки граф готов к run без потери функциональности.
- [ ] На уровне графа можно выбрать подмножество узлов как trainable; обучение (forward, loss, backward, step) возможно с сохранением и загрузкой чекпоинтов.
- [ ] Сборка из конфига (from_config/from_yaml) и из шаблона (from_template) поддерживается; валидация даёт понятные ошибки; типовой граф (например, text-to-image) собирается в несколько строк кода или одной строкой from_template.
- [ ] Поддержка любых моделей: новые типы блоков регистрируются и участвуют в графе без изменения ядра; контракт портов и ролей соблюдается. Всё как Lego, всё сериализуемо, всё обучаемо, автоматизировано и удобно для пользователя.

После выполнения этого TODO уровень узлов-задач и графа готов для построения пайплайна (граф графов), этапа и мира с сохранением всех требований проекта.
