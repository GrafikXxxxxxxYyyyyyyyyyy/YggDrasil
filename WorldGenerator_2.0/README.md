# World Generator 2.0

**Свежий старт:** полный рефакторинг и расширение концепции World Generator. Старый каталог `WorldGenerator` сохранён как архив; здесь — целостная модель с нуля, без накопленных противоречий.

---

## Зачем 2.0

- **WorldGenerator_2.0** — один канон: один цикл мира, Автор как два узла (обновление и развитие мира), state из пяти блоков. Вся операционная схема собрана в **[Scheme.md](Scheme.md)**. Философия (Lego, блок/узел, идея/материя) перенесена без изменений в **[Philosophy.md](Philosophy.md)**.

---

## Структура документации

| Документ | Назначение |
|----------|------------|
| **[README.md](README.md)** | Этот файл: цель 2.0, навигация. |
| **[Philosophy.md](Philosophy.md)** | Философская основа (перенесена из WorldGenerator): идея/материя, Block/Node, Lego, World как цикл из пяти звеньев. Не трогаем при операционных правках. |
| **[Scheme.md](Scheme.md)** | **Единый источник правды:** цикл мира, пять переходов, Автор = два узла, state (пять блоков), жизненный цикл, Action/State, граница с артефактами. Всё в одном месте. |
| **[System.md](System.md)** | **Система с основания:** от двух начал (материя/идея) и блока/узла графа до полного цикла мира. Один файл, снизу вверх. |
| **[Abstract_Block_And_Node.md](Abstract_Block_And_Node.md)** | **Полное техническое описание** Abstract Base Block и Abstract Graph Node: что хранят/задают, контракты, порты, рёбра, преобразование блок→узел, примеры, замечания для реализации. |
| **[Abstract_Task_Nodes.md](Abstract_Task_Nodes.md)** | **Уровень над фундаментом:** Abstract Backbone, Solver, Codec, Adapter, Conditioner, Tokenizer, Guidance. Двойное наследование Block+Node, спецификация задачи, порты, выполнение, типичные связи, сборка графа, сериализация. |
| **[Graph_Level.md](Graph_Level.md)** | **Уровень графа:** один граф = **одна цельная задача** (text-to-image, upscale, image-to-video и т.д.). Сборка через Graph.AddNode(...); узлы знают свою роль. |
| **[Pipeline_Level.md](Pipeline_Level.md)** | **Уровень пайплайна:** граф, **узлами которого являются другие графы**; для **комбинированных задач** (текст→картинка→апскейл→видео и т.д.). |
| **[Stage_Level.md](Stage_Level.md)** | **Уровень этапа (Stage):** этап — **граф пайплайнов** (узлы = пайплайны; пайплайн может из одного графа); контракт по state, какие задачи решает. |
| **[World_Level.md](World_Level.md)** | **Уровень мира (World):** мир — **граф этапов**; узлы мира = этапы, по рёбрам передаётся state; цикл (Философ → Автор → Среда → Архитектор → Творец). |
| **[World_Serialization.md](World_Serialization.md)** | **Сериализация мира:** мир как верхняя абстракция полностью задаётся конфигом/шаблоном; из конфига — загрузка, из шаблона — генерация мира, конфиг + чекпоинт — обученный мир. Формат конфига, шаблон, загрузка. |
| **[LLM_API_SUPPORT.md](LLM_API_SUPPORT.md)** | **Поддержка LLM через API:** полная поддержка использования больших языковых моделей только через удалённый API — без скачивания и загрузки весов, без локальной инициализации. Модели класса QwenMax, ChatGPT/GPT-5.x, Opus и т.д. |
| **[MODEL_REUSE.md](MODEL_REUSE.md)** | **Повторное использование одной модели:** механизм, при котором один и тот же чекпоинт (модель) не создаётся в нескольких копиях — при использовании в нескольких узлах/графах (например, text-to-image и image-to-image с одним backbone в пайплайне) в памяти один экземпляр, без лишнего расхода памяти. Для всех типов моделей (диффузия, LLM, VLM). |
| **[LORA_WORLD_LIGHTWEIGHT_CUSTOM.md](LORA_WORLD_LIGHTWEIGHT_CUSTOM.md)** | **Механизм LoRA на весь мир:** заморозка всех весов базового мира, подключение LoRA-адаптеров ко всем необходимым частям, обучение только адаптеров → лёгкие кастомные миры. |
| **[TODO_01_FOUNDATION.md](TODO_01_FOUNDATION.md)** | **TODO: фундаментальный уровень** — пошаговый список реализации ядра (Block, Node, порты, рёбра, сериализация весов, загрузка из чекпоинта, реестр). |
| **[TODO_02_TASK_NODES_AND_GRAPH.md](TODO_02_TASK_NODES_AND_GRAPH.md)** | **TODO: узлы-задачи и граф** — полная реализация Abstract Task Nodes (все типы, контракты, role rules), граф (AddNode, авто-связывание, исполнитель, сериализация, обучение, from_config/from_template), любые модели, Lego, UX. |
| **[TODO_03_GRAPH_ENGINE.md](TODO_03_GRAPH_ENGINE.md)** | **TODO: графовый движок** — реализация движка уровня графа: структура данных графа, Graph Builder API (AddNode/AddEdge, expose_input/expose_output), валидация (порты, циклы, SCC), исполнитель (топология, буфер, run, циклы с N итерациями), обучение (trainable узлы), сериализация конфига и весов, загрузка из чекпоинта, from_config/from_template, контракт графа для пайплайна и multi-endpoint. |
| **[TODO_04_PIPELINE.md](TODO_04_PIPELINE.md)** | **TODO: уровень пайплайна** — полная реализация пайплайна (граф графов): структура данных, Pipeline Builder (AddGraph/AddEdge, expose_input/expose_output), валидация (DAG, контракты графов), исполнитель (топология, буфер, run), сериализация конфига и весов (агрегация чекпоинтов графов), загрузка из чекпоинта, обучение (trainable графы), from_config/from_template, multi-endpoint (удалённые графы), контракт пайплайна для этапа и мира. |
| **[TODO_05_STAGE.md](TODO_05_STAGE.md)** | **TODO: уровень этапа (Stage)** — полная реализация этапа (граф пайплайнов): структура данных, Stage Builder (AddPipeline/AddEdge, контракт по state, маппинг state↔порты, условия выполнения по Scheme), валидация (DAG, state schema), исполнитель (топология, буфер, run(stage, state)→state), сериализация конфига и весов (агрегация чекпоинтов пайплайнов), загрузка из чекпоинта, обучение (trainable пайплайны), from_config/from_template, multi-endpoint, связь с миром и Scheme (Философ, Автор, Среда, Архитектор, Творец). |
| **[TODO_06_WORLD.md](TODO_06_WORLD.md)** | **TODO: уровень мира (World)** — полная реализация мира (граф этапов): структура данных (этапы, цикл, state_schema, storage, initial_world), World Builder (AddStage, SetCycle, set_state_schema, set_storage), валидация, исполнитель (run по циклу, execution_condition по Scheme, первая итерация при пустом state §4.8, Action в Среда, сохранение state при World update), сериализация конфига и весов (агрегация чекпоинтов этапов), загрузка из чекпоинта, обучение (trainable этапы, LoRA-world), from_config/from_template, multi-endpoint, строгое соответствие Scheme (цикл, Среда = World update + Development, мир один). |
| **[TODO_07_FUTURE_AND_IMPROVEMENTS.md](TODO_07_FUTURE_AND_IMPROVEMENTS.md)** | **TODO: дальнейшее развитие фреймворка** — что реализовать дальше, как развивать другой проект, что добавить и технически улучшить: поддержка VLM, видео, аудио, мультимодальность, стриминг; бэкенды (ONNX, vLLM, TGI), async, батчинг, распределённое обучение; наблюдаемость (трейсинг, метрики, тесты); API-сервер, CLI, SDK, UI; экосистема (Hugging Face, плагины, примеры); надёжность, безопасность, воспроизводимость; производительность; MLOps; документация и версионирование. |
| **[EXPANSION_UNIVERSE_GRAPH_OF_WORLDS.md](EXPANSION_UNIVERSE_GRAPH_OF_WORLDS.md)** | **Расширение выше мира:** приблизительные подсказки по расширению от уровня Мир (World) к уровню **Вселенная (Universe)** — **граф миров (Graph of Worlds)**, т.е. счёт миров (count of worlds): узлы = миры, рёбра = связи между мирами; обход графа, payload_spec, сериализация и run. Подробное сопоставление с мифологией Иггдрасиля (древо, девять миров, корни и ветви, источник Урд, норны, орёл и змей, Рататоск). Не входит в канон; направление расширения без изменения Scheme/Philosophy. |
Дополнительные документы (иерархия уровней, пайплайны, контракты API) добавляются по мере расширения и ссылаются на Scheme.md и Philosophy.md.

---

## Принципы 2.0

1. **Один канон** — операционная схема мира не размазана по файлам; она в Scheme.md.
2. **Один цикл** — порядок выполнения всегда: Философ → Автор → Среда → Архитектор → Творец. Никаких «двух направлений» графа.
3. **Автор = два узла** — World update (State → обновление контента мира) и Development of the world (Action → чтение мира → новый state с блоком 1).
4. **Мир один** — обновляется применением state; новый state создаётся в Development of the world.
5. **Расширение** — новые сущности и возможности вводятся так, чтобы не ломать Scheme.md и Philosophy.md; при противоречии сначала обновляется канон.

---

## С чего начать

1. **[System.md](System.md)** — если нужна картина системы с самого основания (от блока/узла до цикла мира).
2. **[Philosophy.md](Philosophy.md)** — если нужна идеологическая база (Lego, блок/узел, идея/материя).
3. **[Scheme.md](Scheme.md)** — если нужна полная операционная картина: цикл, state, обновление и развитие, жизненный цикл.

Язык — **русский**.
