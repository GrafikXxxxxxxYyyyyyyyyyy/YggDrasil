# Философия проекта World Generator (Yggdrasil)

**Единый канон проекта:** [CANON.md](CANON.md) — всеобъемлющий референс архитектуры; этому документу и остальным документам канона необходимо следовать.

**Главный ориентир при проектировании всей системы.** Идея и идеология проекта; далее — уточнения и правки.

---

## 1. Идея проекта

Проект строится на представлении мира как **набора связанных блоков** — по аналогии с конструктором Lego. Блоки соединяются не только физически (потоками данных), но и **идеей**: общая логика и правила связывания задают, как материальные сущности образуют целое. Таким образом, система является одновременно:

- **конструктором** — всё собирается из блоков;
- **средой с идеей** — связи и композиция подчиняются единой философии и правилам преобразования.

Цель — дать **максимальную свободу создания** для разработчиков и пользователей при сохранении ясной и единой основы: всё, что есть в проекте, опирается на одни и те же фундаментальные сущности и принципы. Yggdrasil — не только Lego-конструктор, но и **многомерный граф**: на каждом уровне представления сущности одновременно материальны и идеальны; их природа проявляется **во взаимодействии идеи с материей и материи с идеей**.

---

## 2. Философская основа: Идеальное и Материальное

Мир в проекте разделяется на два взаимосвязанных начала:

| Начало | Сущность в проекте | Смысл |
|--------|--------------------|--------|
| **Материальное** | То, что **хранит** и **несёт**: параметры, тензоры, ссылки, данные, веса, конфигурацию. Всё, что можно назвать «носителем» состояния и структуры. | Материя = то, из чего собирается система и что передаётся по цепочкам. |
| **Идеальное** | То, что задаёт **связи**, **порядок** и **логику превращения** материальных сущностей в элементы целого. Упорядочивание блоков в граф, правила соединения, семантика узлов и рёбер. | Идея = форма, в которую складывается материя; логика преобразования блока в узел графа. |

- **Материальное** воплощается в **блоке** (Lego-кирпиче): нечто, что можно положить в граф и соединить с другим.
- **Идеальное** воплощается в **узле графа** и в **логике превращения**: любой блок может стать узлом; сама эта возможность и правила превращения и есть идеальная составляющая.

Вся архитектура держится на этом разделении: с одной стороны — единый материальный «атом» (базовый блок), с другой — единая идеальная «форма» (узел графа и правило: блок → узел).

---

## 3. Первый и главный принцип: Lego-подобие

Вся система должна быть **Lego-подобной** и собираться как конструктор.

- **Любой блок с любым блоком.** Нет жёстко заданных «единственно верных» пар; совместимость определяется портами и типами, а не фиксированным списком связей.
- **Абсолютная гибкость сборки.** Порядок добавления блоков и их количество не предписаны сверху. Конструктор, а не жёсткий пайплайн.
- **Реальная песочница.** Всё можно соединять со всем в рамках правил графа (совместимость портов, направление потоков). Порядок — любой, количество блоков — любое.
- **Полноценный Lego-конструктор.** Максимальная свобода создания для разработчиков: добавление своих блоков, своих типов узлов, своих правил преобразования без переписывания ядра.

Итог: **максимальная свобода** при **единой основе** — материальный блок и идеальная логика «блок → узел графа».

---

## 4. Фундаментальный уровень: Abstract Base Block и Abstract Graph Node (подробно)

Всё в проекте строится из двух фундаментальных сущностей: **Abstract Base Block** (материальное начало) и **Abstract Graph Node** (идеальное начало). Ниже они разобраны по отдельности и в связи друг с другом.

---

### 4.1 Abstract Base Block (абстрактный базовый блок) — материальное начало

**Определение.** Абстрактный базовый блок — это **Lego-кирпич** системы: минимальная единица, которая что-то хранит и что-то вычисляет. **Любой объект в проекте может быть представлен как базовый блок** (или обёрнут в него). На фундаментальном уровне это единственная сущность, которая воплощает **материю** — то, что имеет параметры, состояние и может быть выполнено.

#### Что блок хранит (материальное содержание)

- **Параметры и конфигурация:** конфиг (YAML, словарь), гиперпараметры, идентификаторы (`block_id`, `block_type`). Всё, что задаёт «кто этот блок» и «с какими настройками он работает».
- **Тензоры и веса:** обучаемые веса, кэш, промежуточные данные. Всё, что занимает память и участвует в вычислениях (в т.ч. в диффузионных и языковых моделях).
- **Ссылки:** на другие блоки, ресурсы, граф (если блок уже помещён в граф). Связи «указатель на что-то» тоже считаются материальной частью блока.
- **Состояние:** всё, что нужно для воспроизводимости, сохранения и загрузки (state_dict, конфиг при сохранении).

То есть блок — это **носитель**: он не только «кирпич», но и **хранилище** всего перечисленного. Без блока нет материального воплощения сущности в пайплайне.

#### Контракт блока (как он участвует в системе)

- Блок **объявляет интерфейс**: какие у него входы и выходы (порты — имена, типы, опциональность). Это описание «что блок принимает и отдаёт» без привязки к конкретному графу.
- Блок **выполняется**: по входным данным (по портам) выдаёт выходные. Выполнение — материальный акт (вычисления, тензоры, данные).
- Блок **идентифицируется**: `block_type`, `block_id` — чтобы граф и другие блоки могли ссылаться на него и различать блоки между собой.

Таким образом, блок на фундаментальном уровне — это **атом сборки**: модели, кодекы, кондиционеры, солверы, сэмплеры, пайплайны и т.д. в основе своей суть базовые блоки (или композиции из них). Ничего материального в системе нет вне блоков.

#### Итог по Abstract Base Block

- **Фундаментальная материальная сущность** = Abstract Base Block.
- Блок = хранилище (параметры, тензоры, ссылки, состояние) + исполняемая единица (контракт: порты, выполнение) + идентичность (block_type, block_id).
- В философском смысле блок — **материя**: то, из чего собирается система и что передаётся по цепочкам выполнения.

---

### 4.2 Abstract Graph Node (абстрактный узел в графе) — идеальное начало

**Определение.** Абстрактный узел в графе — это **место** или **роль** в графе, которому может соответствовать **любой** абстрактный базовый блок. Узел не «хранит» материю сам по себе: он задаёт **положение** и **связи** в графе. То, что помещено в узел, — всегда блок (материя); узел — это **идеальная форма**, в которую блок помещается.

#### Что задаёт узел (идеальное содержание)

- **Положение в графе:** имя узла, уникальность среди других узлов. Узел отвечает на вопрос «где в графе эта сущность» — не «что там лежит», а «какое место она занимает».
- **Связи с другими узлами:** входящие и исходящие рёбра (edges): от какого узла и порта к какому узлу и порту идёт поток данных. Узел участвует в рёбрах; тем самым задаётся **порядок** и **направление** потоков — идея композиции.
- **Семантика портов на уровне графа:** какие порты блока «торчат наружу» и к чему они подключаются. Узел не подменяет порты блока, а задаёт, как эти порты встроены в граф (входы графа, выходы графа, связи между узлами).

Узел, таким образом, не дублирует блок: он задаёт **как блок встроен в целое**. Целое — граф; идея целого — связи и порядок. Поэтому узел относится к **идеальному** началу.

#### Любой блок может стать узлом

- **Abstract Graph Node** не привязан к одному конкретному типу блока. **Любой** Abstract Base Block может быть помещён в узел графа. Один и тот же класс блоков может использоваться в разных графах и в разных узлах; узел задаёт не тип блока, а **роль в данном графе**.
- Преобразование «блок → узел» означает: взять материальную сущность (блок) и **назначить ей место и связи** в графе (идея). После этого блок выступает как узел при выполнении графа: исполнитель обращается к узлам по имени и передаёт данные по рёбрам; содержимое узла — по-прежнему блок.

#### Итог по Abstract Graph Node

- **Фундаментальная идеальная сущность** = Abstract Graph Node (место/роль в графе, которое может занять любой блок).
- Узел задаёт: положение в графе, связи (рёбра), участие портов блока в графе. Он не хранит параметры и тензоры — это делает блок внутри узла.
- В философском смысле узел — **идея**: форма, порядок, композиция; логика «где и с чем соединено».

---

### 4.3 Логика преобразования «блок → узел» и единство фундаментального уровня

Фундаментальный уровень замкнут двумя сущностями и одним правилом:

- **Материя:** Abstract Base Block — что хранится и выполняется.
- **Идея:** Abstract Graph Node — где и как это встроено в граф.
- **Правило:** **любой Abstract Base Block может быть превращён в узел графа** (помещён в граф как узел с именем и рёбрами). Это преобразование и есть «логика блок → узел»: материя получает идеальную форму (место и связи), не переставая быть блоком.

Система как целое: **граф, узлы которого — блоки; рёбра задают потоки данных между портами блоков.** Содержимое узлов — материя (блоки); структура графа — идея (узлы, рёбра, порядок). Фундаментальный уровень не решает, что «важнее» — блок или узел: оба необходимы, и они работают только вместе — блок как содержимое, узел как положение и связи.

---

### 4.4 Аналогия с фермионами и бозонами

На фундаментальном уровне можно провести **аналогию с двумя классами элементарных частиц** в физике:

| В физике | В Yggdrasil (фундаментальный уровень) | Смысл аналогии |
|----------|----------------------------------------|----------------|
| **Фермионы** (электроны, кварки и т.д.) | **Abstract Base Block** | **«Частицы вещества»**: то, из чего складывается «материя» системы. Фермионы — носители массы, заряда, «кирпичи» вещества; блок — носитель параметров, тензоров, состояния. И те и другие — то, что **хранится** и **переносится** по системе (в физике — по полям и взаимодействиям, в графе — по рёбрам между узлами). |
| **Бозоны** (фотоны, глюоны, W, Z и т.д.) | **Abstract Graph Node** (и рёбра графа) | **«Переносчики взаимодействия»**: то, что задаёт **связи** и **обмен**. Бозоны переносят взаимодействия между фермионами; узел графа задаёт положение и связи блока с другими блоками. Узел не «хранит» содержимое — он задаёт **как** блок участвует в целое (куда подключён, откуда и куда идут потоки). |

Таким образом: **блок — фермионоподобная сущность** (материальное содержание узла), **узел — бозоноподобная сущность** (форма взаимодействия, место в графе). Логика «блок → узел» аналогична тому, что «вещество» (фермион) помещается в поле взаимодействий (бозонное поле): материя получает положение и связи, не переставая быть носителем содержания. Два начала — материя и взаимодействие — необходимы вместе, как в физике, так и в архитектуре Yggdrasil.

---

## 5. Сводная схема фундаментального уровня

Ниже — сводная схема двух сущностей и логики преобразования (подробно они разобраны в п. 4.1–4.3).

```
МАТЕРИАЛЬНОЕ                          ИДЕАЛЬНОЕ
─────────────────────────────────────────────────────────────
Abstract Base Block                  Abstract Node in the Graph
(Lego-кирпич)                        (форма блока в графе)
     │                                        │
     │  хранит:                               │  задаёт:
     │  • параметры, конфиг                   │  • положение в графе
     │  • тензоры, веса                       │  • связи с другими узлами
     │  • ссылки                              │  • порядок и семантику
     │                                        │
     └──────────────┬─────────────────────────┘
                    │
                    ▼
         Логика преобразования:
         «любой Base Block → Node in the Graph»
                    │
                    ▼
         Система как целое: граф из блоков,
         собранный по правилам (идея) из кирпичей (материя).
```

- **Материальная основа:** Abstract Base Block.  
- **Идеальная основа:** узел в графе + правило превращения блока в узел.  
- **Сборка системы:** граф, узлы которого — блоки; связи и порядок — идея; содержимое узлов — материя.

---

## 6. Уровень над фундаментом: абстрактные специализированные блоки (узлы-задачи)

Сразу над фундаментальным уровнем располагается уровень **абстрактных специализированных сущностей**: Abstract Backbone, Abstract Solver, Abstract Codec, Abstract Adapter, Abstract Conditioner, Abstract Tokenizer, Abstract Guidance и т.д. Каждая такая сущность одновременно **наследуется от Abstract Base Block и от Abstract Graph Node** и задаёт **спецификацию задачи** (роль узла в графе). Из конкретных реализаций этих абстрактных блоков **собирается граф**. Полное техническое описание уровня: [Abstract_Task_Nodes.md](Abstract_Task_Nodes.md).

---

## 7. Промежуточные уровни (заглушки развития идеи)

**Уровень графа** — первый **исполняемый** уровень; **один граф = одна цельная задача** (text-to-image, image-to-video, upscale и т.д.). [Graph_Level.md](Graph_Level.md). **Уровень пайплайна** — граф, **узлами которого являются другие графы**; для **комбинированных задач**. [Pipeline_Level.md](Pipeline_Level.md). **Уровень перехода (Stage)** — **Stage есть граф пайплайнов**, реализующий **один переход** (метаморфозу state: материя ↔ идея; [Scheme.md](Scheme.md) §1.0). Задаёт звено в цикле мира (Философ, Автор, Среда, Архитектор, Творец), контракт по state. [Stage_Level.md](Stage_Level.md). **Уровень мира (World)** — **мир есть цепочка переходов** ([World_Level.md](World_Level.md)): узлами мира являются переходы, по рёбрам передаётся state; в каноне — циклический граф. *Дополнительно — в [Graph_Stage_Level.md](Graph_Stage_Level.md), [Level_Hierarchy.md](Level_Hierarchy.md) при наличии.*

---

## 8. Верхний уровень: World (Мир)

**World (Мир)** — **непрерывная цепь крупномасштабных переходов** ([World_Level.md](World_Level.md)): узлами мира являются **переходы** (transitions), по рёбрам передаётся state. Каждый переход — **метаморфоза состояния** (материя ↔ идея; см. [Scheme.md](Scheme.md) §1.0). **Циклический граф из пяти переходов:** Философ → Автор → Среда → Архитектор → Творец:

**Философ → Автор → Среда → Архитектор → Творец**

- **Философ (Philosopher)** — получает state с блоками 1–3; только описывает блок 3 (содержимое артефактов) → блок 4; не генерирует по блоку 2 (это Творец).
- **Автор (Author)** — в ядре языковая модель (LLM). Контекст — **неизменённый мир** (до World update); **контекст задаётся state**. Генерирует **описание** — нарратив «что реально произошло в мире» (блок 5).
- **Среда (Environment)** — (1) **World update** — выполняется **только при полностью заполненном state** (все 5 блоков); (2) **Development of the world** — Action как контекст для LLM, безусловно создаёт новый state с блоком 1.
- **Архитектор (Architect)** — в ядре языковая модель (LLM). Контекст — **изменённый мир** (уже обновлён); **контекст задаётся state**. Генерирует **конфигурацию** (блок 2) по описанию (блок 1).
- **Творец (Creator)** — генерация артефактов (блок 3) по конфигурации (блок 2); замыкание цикла.

Мир можно запускать (launch) и обучать (train). Операционная схема (state, пять блоков, жизненный цикл) задаётся в [Scheme.md](Scheme.md).

---

## 9. Использование документа

Этот файл — **главный ориентир** при проектировании. Операционная модель мира (цикл, state, обновление и развитие) — в [Scheme.md](Scheme.md). Дальнейшие уточнения философии вносятся в этот документ.
