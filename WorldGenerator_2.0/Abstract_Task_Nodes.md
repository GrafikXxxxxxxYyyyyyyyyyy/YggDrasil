# Уровень над фундаментом: абстрактные узлы-задачи (Abstract Task Nodes)

Полное техническое описание **уровня над фундаментальным**: абстрактные специализированные сущности — Backbone, Solver, Codec, Adapter, Conditioner, Tokenizer, Guidance и др. Каждая из них одновременно **наследник Abstract Base Block и Abstract Graph Node** и задаёт **спецификацию задачи** (роль узла в графе). Из конкретных реализаций этих абстракций **собирается граф**.

Фундаментальный уровень: [Abstract_Block_And_Node.md](Abstract_Block_And_Node.md). Система целиком: [System.md](System.md). Граф как первый исполняемый уровень: [Graph_Level.md](Graph_Level.md).

---

## 1. Положение уровня в иерархии

| Уровень | Сущность | Описание |
|---------|----------|----------|
| **Фундамент** | Abstract Base Block, Abstract Graph Node | Материя и идея; блок хранит и выполняется; узел задаёт место и связи. Любой блок можно поместить в узел. |
| **Над фундаментом** | Abstract Backbone, Abstract Solver, Abstract Codec, Abstract Adapter, Abstract Conditioner, Abstract Tokenizer, Abstract Guidance, … | **Узлы-задачи:** каждая сущность — одновременно блок и узел с **фиксированной задачей**. Задаёт контракт портов и семантику выполнения. Конкретные модели — реализации этих абстракций. |
| **Граф (первый исполняемый)** | Конкретный граф | Узлы = экземпляры узлов-задач; рёбра = связи портов. По графу выполняется run/forward. Подробно: [Graph_Level.md](Graph_Level.md). |
| **Пайплайн** | Конкретный пайплайн | Узлы = **целые графы**; рёбра = связи между внешними входами/выходами графов. [Pipeline_Level.md](Pipeline_Level.md). |
| **Этап (Stage)** | Граф пайплайнов | Узлами этапа являются пайплайны. [Stage_Level.md](Stage_Level.md). |
| **Мир (World)** | Граф этапов | Узлами мира являются этапы; по рёбрам передаётся state. [World_Level.md](World_Level.md). |

На уровне над фундаментом **не вводятся новые независимые сущности**: каждая абстракция — это **ограничение и специализация** пары (Block, Node). Узел не «просто узел», а узел типа «backbone», «solver», «codec» и т.д.; блок внутри такого узла не «просто блок», а блок, реализующий соответствующую задачу.

---

## 2. Двойное наследование и спецификация задачи

### 2.1 Двойное наследование

Каждая абстрактная сущность уровня над фундаментом **одновременно**:

1. **Наследует (или реализует) Abstract Base Block** — хранит параметры, тензоры, конфиг, состояние; объявляет порты; выполняет `forward`/`run`; идентифицируется `block_type` и `block_id`.
2. **Наследует (или реализует) Abstract Graph Node** — имеет положение в графе (имя узла), участвует в рёбрах, задаёт отображение портов на связи графа.

Таким образом, **узёл-задача** — это блок, для которого зафиксирована **решаемая задача** (backbone, solver, codec, adapter и т.д.), и узел, для которого эта задача задаёт **роль в графе** и **ожидаемые связи** с другими узлами.

### 2.2 Спецификация задачи

**Спецификация задачи** для каждого типа узла задаёт:

| Элемент | Содержимое |
|---------|------------|
| **Семантика узла** | Что узел «понимает» о себе: например, backbone — «я делаю шаг предсказания модели», solver — «я делаю шаг дискретизации по времени». |
| **Контракт портов** | Имена и типы входных и выходных портов, их назначение (что приходит, что уходит). Опциональность портов. |
| **Семантика выполнения** | Что происходит при вызове `forward`/`run`: один шаг деноisingа, один шаг солвера, encode/decode и т.д. |
| **Типичные связи** | С какими типами узлов данный узел обычно соединяется (например, backbone получает условие от conditioner, предсказание потребляется solver’ом). |

Конкретная **реализация** (конкретный класс, например `UNet2DBackbone`, `DDIMSolver`) заполняет хранилище блока (архитектура, веса), реализует логику выполнения и соблюдает контракт портов абстракции.

---

## 3. Abstract Backbone (абстрактный бэкбон)

### 3.1 Определение и задача

**Abstract Backbone** — узел графа, отвечающий за **ядро модели**: предсказание шума, один шаг деноisingа, предсказание в латентном пространстве (или аналог в не-диффузионных схемах). Backbone «понимает», что он выполняет **шаг предсказания** по текущему состоянию (латенты, таймстеп, условие) и выдаёт предсказание (шум, x0, остаток и т.д.).

### 3.2 Что хранит (материальное содержание)

| Категория | Содержимое |
|-----------|------------|
| Параметры и конфигурация | Архитектура (тип сети: UNet, трансформер, DiT и т.д.), размерности, число слоёв, конфиг внимания и т.д. `block_type` = `"backbone"` (или подтип). |
| Тензоры и веса | Обучаемые веса модели (параметры сети). Кэш промежуточных активаций при необходимости. |
| Ссылки | Опционально: на кодек (для размерностей латентного пространства), на расписание (для эмбеддингов таймстепа). |
| Состояние | state_dict для сохранения/загрузки чекпоинта. |

### 3.3 Контракт портов

| Порт | Направление | Тип (типично) | Назначение |
|------|-------------|---------------|------------|
| **latent** (или **x**) | Вход | Тензор | Текущее латентное состояние (или пиксели в pixel-space моделях). |
| **timestep** (или **t**) | Вход | Тензор или скаляр | Текущий шаг времени / уровень шума. |
| **condition** (или **context**, **emb**) | Вход | Тензор, словарь | Условие от conditioner’ов (текст, изображение, эмбеддинги). Может быть опциональным. |
| **pred** (или **noise**, **x0**) | Выход | Тензор | Предсказание модели (шум ε, или x0, или v в v-parameterization). |

Имена портов и наличие дополнительных портов (например, **encoder_hidden_states**, **attention_mask**) задаются конкретной реализацией; абстракция фиксирует **семантику**: вход — состояние + таймстеп + условие, выход — предсказание.

### 3.4 Выполнение (семантика)

- **Вход:** латенты, таймстеп, условие (и опционально прочие входы).
- **Действие:** один прямой проход модели (forward pass): предсказание шума/значения по текущему состоянию.
- **Выход:** тензор предсказания.

Один вызов backbone = **один шаг предсказания**, без дискретизации по времени (дискретизация — задача Solver).

### 3.5 Типичные связи в графе

- **Вход latent:** от выхода Codec (decode) или от выхода Solver на предыдущем шаге; или внешний вход графа (начальные латенты).
- **Вход timestep:** от расписания (schedule) или от Solver.
- **Вход condition:** от узлов Conditioner (текст, изображение и т.д.).
- **Выход pred:** в Solver (для выполнения одного шага дискретизации) или во внешний выход графа.

### 3.6 Примеры конкретных реализаций

- UNet 2D (диффузия изображений).
- Трансформер (DiT, SD3 и т.д.).
- UNet 3D (видео).
- Любая модель, реализующая контракт: (latent, timestep, condition) → pred.

---

## 4. Abstract Solver (абстрактный солвер)

### 4.1 Определение и задача

**Abstract Solver** — узел графа, отвечающий за **шаг дискретизации** по времени: по текущему состоянию (латенты, таймстеп) и предсказанию модели (от Backbone) выдаёт **следующее состояние** (латенты на следующем таймстепе). Solver «понимает», что он выполняет один шаг схемы интегрирования (DDIM, DDPM, Heun, Euler и т.д.).

### 4.2 Что хранит

| Категория | Содержимое |
|-----------|------------|
| Параметры и конфигурация | Тип схемы (DDIM, Euler, …), параметры расписания (beta, sigma и т.д.), число шагов. `block_type` = `"solver"`. |
| Тензоры и веса | Обычно солвер не содержит обучаемых весов (это детерминированная схема); возможны кэши (например, расписание сигм). |
| Ссылки | Опционально на расписание шума (noise schedule). |
| Состояние | Конфиг и опционально кэш расписания для save/load. |

### 4.3 Контракт портов

| Порт | Направление | Тип | Назначение |
|------|-------------|-----|------------|
| **latent** (или **x**) | Вход | Тензор | Текущее латентное состояние. |
| **timestep** (или **t**) | Вход | Тензор или скаляр | Текущий таймстеп. |
| **pred** (или **model_output**) | Вход | Тензор | Предсказание от Backbone (шум, x0 или v). |
| **next_latent** (или **x_next**) | Выход | Тензор | Латенты на следующем таймстепе. |
| **next_timestep** (или **t_next**) | Выход | Тензор или скаляр | Следующий таймстеп (для многократного вызова в цикле). |

### 4.4 Выполнение (семантика)

- **Вход:** latent, timestep, pred.
- **Действие:** по формуле выбранной схемы вычислить следующее состояние x_next и опционально t_next.
- **Выход:** next_latent, next_timestep.

Один вызов solver = **один шаг** дискретизации (один шаг по времени).

### 4.5 Типичные связи

- **latent, timestep:** от предыдущего шага Solver или от начального состояния (внешний вход / Codec).
- **pred:** от Backbone (выход backbone подключается к входу solver’а pred).
- **next_latent, next_timestep:** в следующий вызов Backbone (и затем снова в Solver) или во внешний выход (финальное изображение после N шагов).

### 4.6 Примеры реализаций

- DDIM Solver.
- DDPM (стохастический шаг).
- Euler, Heun.
- Flow matching solver.

---

## 5. Abstract Codec (абстрактный кодек)

### 5.1 Определение и задача

**Abstract Codec** — узел графа, отвечающий за **кодирование и декодирование представления**: переход между пространствами (например, пиксели ↔ латенты). Codec «понимает», что он выполняет **encode** (например, пиксели → латенты) или **decode** (латенты → пиксели), или оба в зависимости от конфигурации/порта.

### 5.2 Что хранит

| Категория | Содержимое |
|-----------|------------|
| Параметры и конфигурация | Тип кодера/декодера (VAE, VQ и т.д.), размерности латентного пространства, scaling factor. `block_type` = `"codec"`. |
| Тензоры и веса | Веса энкодера и декодера. |
| Ссылки | Опционально на конфиг (разрешение, нормализация). |
| Состояние | state_dict для чекпоинта. |

### 5.3 Контракт портов

Типично кодек имеет **два режима** (или два набора портов):

**Encode:**
| Порт | Направление | Тип | Назначение |
|------|-------------|-----|------------|
| **image** (или **pixels**) | Вход | Тензор | Изображение в пиксельном пространстве. |
| **latent** | Выход | Тензор | Закодированные латенты. |

**Decode:**
| Порт | Направление | Тип | Назначение |
|------|-------------|-----|------------|
| **latent** | Вход | Тензор | Латенты. |
| **image** (или **pixels**) | Выход | Тензор | Декодированное изображение. |

В графе могут быть два узла (encode_codec и decode_codec) или один узел с разными портами/режимами вызова.

### 5.4 Выполнение (семантика)

- **Encode:** один проход энкодера: image → latent (возможно с добавлением шума по расписанию в обучении).
- **Decode:** один проход декодера: latent → image.

### 5.5 Типичные связи

- **Encode:** вход image — внешний вход графа или от предыдущего узла; выход latent — в Solver (начальное состояние) или в Backbone/Conditioner.
- **Decode:** вход latent — от выхода Solver (финальные латенты); выход image — во внешний выход графа или в последующую постобработку.

### 5.6 Примеры реализаций

- VAE (AutoencoderKL).
- VQ-VAE.
- Кодек для видео (пространственно-временной).

---

## 6. Abstract Adapter (абстрактный адаптер)

### 6.1 Определение и задача

**Abstract Adapter** — узел графа, отвечающий за **адаптацию**: внедрение внешнего сигнала (условие, стиль, контроль) в пайплайн без замены всей модели. Adapter «понимает», что он **модифицирует** входные или промежуточные активации другого блока (чаще всего Backbone) с учётом дополнительного условия (LoRA, инжектор, control net и т.д.).

### 6.2 Что хранит

| Категория | Содержимое |
|-----------|------------|
| Параметры и конфигурация | Тип адаптера (LoRA, injection, control), места инжекции, ранг и т.д. `block_type` = `"adapter"`. |
| Тензоры и веса | Обучаемые веса адаптера (LoRA-матрицы, веса инжекторных слоёв и т.д.). |
| Ссылки | На блок, к которому применяется адаптация (часто Backbone). |
| Состояние | state_dict. |

### 6.3 Контракт портов

| Порт | Направление | Тип | Назначение |
|------|-------------|-----|------------|
| **condition** (или **control**, **style**) | Вход | Тензор, изображение, словарь | Внешнее условие (эмбеддинг, карта контроля, стиль). |
| **hidden** (или **activations**) | Вход | Тензор | Промежуточные активации блока, который адаптируется. |
| **adapted** (или **output**) | Выход | Тензор | Модифицированные активации (hidden + вклад адаптера). |

Варианты: adapter может не принимать hidden, а только condition, и выдавать «дополнение», которое граф складывает с hidden в другом узле — зависит от архитектуры.

### 6.4 Выполнение (семантика)

- Принимает condition и опционально hidden.
- Вычисляет вклад адаптера и возвращает adapted (или delta для сложения с hidden).

### 6.5 Типичные связи

- **condition:** от Conditioner или от внешнего входа (control image, style).
- **hidden:** от Backbone (промежуточные слои) или от узла, агрегирующего активации.
- **adapted:** обратно в Backbone (подмена или сложение активаций) или в следующий слой.

### 6.6 Примеры реализаций

- LoRA.
- ControlNet, T2I-Adapter.
- IP-Adapter (инжекция по эмбеддингу изображения).
- Style injection.

---

## 7. Abstract Conditioner (абстрактный кондиционер)

### 7.1 Определение и задача

**Abstract Conditioner** — узел графа, отвечающий за **подготовку условия**: преобразование сырого ввода (текст, изображение, аудио и т.д.) в форму, пригодную для Backbone (эмбеддинги, скрытые состояния). Conditioner «понимает», что он **кодирует условие** для последующего использования в модели.

### 7.2 Что хранит

| Категория | Содержимое |
|-----------|------------|
| Параметры и конфигурация | Тип энкодера (CLIP, T5, и т.д.), размерность выхода, пулинг. `block_type` = `"conditioner"`. |
| Тензоры и веса | Веса энкодера условия. |
| Состояние | state_dict. |

### 7.3 Контракт портов

| Порт | Направление | Тип | Назначение |
|------|-------------|-----|------------|
| **input** (или **text**, **image**, **prompt**) | Вход | Строка, тензор, токены | Сырое условие (промпт, изображение для кодирования). |
| **embedding** (или **encoder_hidden_states**, **condition**) | Выход | Тензор, словарь | Закодированное условие для Backbone. |

Может быть несколько выходных портов (например, pooled embedding + hidden states).

### 7.4 Выполнение (семантика)

- Вход: сырой ввод (текст, изображение).
- Один проход энкодера условия.
- Выход: эмбеддинги/скрытые состояния.

### 7.5 Типичные связи

- **input:** внешний вход графа (промпт пользователя, референс) или выход Tokenizer (token_ids), если текстовая ветка идёт через отдельный узел Tokenizer.
- **embedding:** в Backbone (порт condition), в Adapter или в несколько потребителей.

### 7.6 Примеры реализаций

- CLIP text encoder.
- T5, BERT для текста.
- CLIP image encoder (для IP-Adapter и аналогов).

---

## 8. Abstract Tokenizer (абстрактный токенайзер)

### 8.1 Определение и задача

**Abstract Tokenizer** — узел графа, отвечающий за **преобразование дискретного сырого ввода в токены и обратно**: текст (или иная последовательность символов/единиц) → идентификаторы токенов; при необходимости decode: токены → текст. Tokenizer «понимает», что он **нормализует и сегментирует** ввод в последовательность токенов для потребления узлами вниз по графу (Conditioner, языковые модели и т.д.). Вынесение токенайзера в отдельный узел даёт явную границу текст↔токены, единый контракт портов и сериализацию словаря/мержей в конфиге мира.

### 8.2 Что хранит

| Категория | Содержимое |
|-----------|------------|
| Параметры и конфигурация | Тип (BPE, SentencePiece, WordPiece и т.д.), путь к словарю/мержам, специальные токены, max_length. `block_type` = `"tokenizer"`. |
| Данные | Словарь (vocab), мержи (для BPE), модель (для SentencePiece) — то, что нужно для воспроизводимого encode/decode. |
| Состояние | Конфиг и опционально кэш для save/load. |

### 8.3 Контракт портов

| Порт | Направление | Тип | Назначение |
|------|-------------|-----|------------|
| **text** (или **input_text**, **prompt**) | Вход | Строка или список строк | Сырой текст (промпт, подпись и т.д.). |
| **token_ids** (или **input_ids**) | Выход | Тензор целых, [batch, length] | Идентификаторы токенов для Conditioner или иного потребителя. |
| **attention_mask** (опционально) | Выход | Тензор | Маска длины последовательности. |

Для **decode**: опциональные порты **token_ids** (вход) и **text** (выход), если узел поддерживает обратное преобразование.

### 8.4 Выполнение (семантика)

- **Encode:** вход — текст; действие — нормализация, разбиение на токены, отображение в ID; выход — token_ids (и при необходимости attention_mask).
- **Decode:** вход — token_ids; действие — отображение ID → токены, склейка в строку; выход — текст.

Один вызов = один encode или один decode (режим задаётся вызовом соответствующего порта или флагом).

### 8.5 Типичные связи в графе

- **Вход text:** внешний вход графа (промпт пользователя) или выход другого узла (например, генератор подписей).
- **Выход token_ids:** в Conditioner (текстовый энкодер ожидает токены), в языковую модель или в несколько потребителей при общем токенайзере.
- Один узел Tokenizer может использоваться для нескольких Conditioner’ов с одним и тем же словарём (например, один BPE для CLIP и для T5 в одном пайплайне).

### 8.6 Примеры конкретных реализаций

- BPE (Byte Pair Encoding), например GPT-2/CLIP style.
- SentencePiece (Unigram, BPE).
- WordPiece (BERT-style).
- Специализированные токенайзеры (например, для кода, для мультиязычных моделей).

---

## 9. Abstract Guidance (абстрактный гайданс)

### 9.1 Определение и задача

**Abstract Guidance** — узел графа, отвечающий за **коррекцию предсказания** по дополнительному сигналу (классификатор, энергия, reward и т.д.): модификация выхода Backbone или Solver с учётом guidance-функции. Используется в CFG (classifier-free guidance), в reward-based guidance и т.д.

### 9.2 Что хранит

- Конфиг (сила guidance, тип: CFG, reward и т.д.); опционально веса (если guidance — модель). `block_type` = `"guidance"`.

### 9.3 Контракт портов (типично)

| Порт | Направление | Назначение |
|------|-------------|------------|
| **pred_cond** | Вход | Предсказание условной модели. |
| **pred_uncond** | Вход | Предсказание безусловной модели. |
| **scale** | Вход | Коэффициент guidance (опционально). |
| **pred_guided** | Выход | Комбинированное предсказание (например, pred_uncond + scale * (pred_cond - pred_uncond)). |

Варианты: один узел Guidance может принимать только pred и condition и вычислять скорректированное предсказание по своей логике.

### 9.4 Выполнение и связи

- Вычисление скорректированного предсказания; выход идёт в Solver или во внешний выход.
- Примеры: CFG block, PAG, reward-based guidance.

---

## 10. Дополнительные абстрактные типы (кратко)

| Тип | Задача | Типичные порты (идея) |
|-----|--------|------------------------|
| **Abstract NoiseSchedule** | Задаёт расписание шума (sigma, alpha и т.д.) по таймстепу. | Вход: timestep. Выход: sigma, alpha, … |
| **Abstract PositionEmbedder** | Позиционное кодирование (sinusoidal, learned) для таймстепа или позиции. | Вход: indices/timestep. Выход: embedding. |
| **Abstract Pooler** | Агрегация последовательности (pooling) в один вектор. | Вход: sequence. Выход: vector. |
| **Abstract Projection** | Линейное (или иное) отображение размерности (например, condition → размер входа backbone). | Вход: tensor. Выход: tensor другой размерности. |

Каждый из них задаётся по той же схеме: двойное наследование Block + Node, спецификация задачи, контракт портов, семантика выполнения, типичные связи.

---

## 11. Сборка графа из узлов-задач

### 11.1 Граф — одна цельная задача

**Граф реализует одну законченную цель** (одну задачу): например, text-to-image, image-to-video, upscale, image-to-image, распознавание. Граф не обязан быть «куском» пайплайна: внутри одного графа собирается полная реализация задачи (Tokenizer, Conditioner, Backbone, Solver, Codec и т.д.). Комбинирование нескольких задач (например, текст → картинка → апскейл → видео) делается на уровне **пайплайна**, где узлами являются целые графы. См. [Graph_Level.md](Graph_Level.md), [Pipeline_Level.md](Pipeline_Level.md).

### 11.2 Сборка через AddNode; узлы знают свою роль

- **Граф собирается добавлением узлов-задач:** Graph.AddNode(Backbone), Graph.AddNode(Codec), Graph.AddNode(Solver), Graph.AddNode(Conditioner), Graph.AddNode(Tokenizer) и т.д. Каждый узел — экземпляр соответствующей абстракции (например, UNet2D, DDIM, AutoencoderKL, CLIP encoder, BPE tokenizer).
- **Узлы автоматически понимают, где они находятся:** по типу узла-задачи (Backbone, Solver, Codec, Conditioner, Tokenizer, …) система выводит типичные связи с другими узлами (какие порты с какими соединять). Пользователю не обязательно задавать каждое ребро вручную — достаточно добавить нужные узлы, и граф для задачи (например, text-to-image) можно собрать **в несколько строк кода**.
- **Рёбра** соединяют порты согласно контрактам узлов-задач: выход Tokenizer → вход Conditioner; выход Conditioner → вход Backbone (condition); выход Backbone → вход Solver (pred); выход Solver (next_latent) → вход Backbone (latent) на следующей итерации; и т.д.
- **Порядок выполнения** задаётся топологией графа; при цикле (solver ↔ backbone) — итеративная схема (N шагов солвера).

### 11.3 Реестр типов (registry)

- По строке **block_type** (например, `"backbone"`, `"solver"`, `"unet2d"`, `"ddim"`) фабрика создаёт экземпляр нужного класса. Конкретные реализации регистрируются под своими подтипами (например, `backbone.unet2d`, `solver.ddim`).
- Конфиг узла в сериализации мира (или пайплайна) содержит `block_type` и `config`; при загрузке по `block_type` создаётся блок, конфиг передаётся в конструктор.

### 11.4 Валидация графа

- При сборке проверять: типы портов на концах рёбер совместимы; обязательные порты имеют ровно одно входящее ребро (или заданную политику); циклы разрешены только где ожидаются (например, backbone–solver loop).
- Спецификация каждого абстрактного типа задаёт **ожидаемые** связи; валидатор может проверять соответствие графа шаблону пайплайна (например, «диффузия изображений»).

---

## 12. Сериализация уровня над фундаментом

- В **конфиге мира** (или конфиге пайплайна) каждый узел задаётся, например: `node_id`, `block_type` (строка, соответствующая абстрактному типу или конкретной реализации), `config` (словарь конфига блока).
- **Чекпоинт** сохраняет state_dict каждого блока (в том числе backbone, codec, conditioner, tokenizer, adapter); при загрузке конфига и чекпоинта узлы создаются, веса загружаются.
- Абстрактный тип (backbone, solver, codec, …) не сериализуется отдельно — он задан в коде и в схеме конфига; сериализуются **экземпляры** с их block_type и config.

---

## 13. Сводные таблицы

### 13.1 Узлы-задачи (семантика)

| Абстрактный тип | Задача | Ключевые входы | Ключевые выходы |
|-----------------|--------|----------------|------------------|
| **Backbone** | Шаг предсказания модели | latent, timestep, condition | pred |
| **Solver** | Шаг дискретизации по времени | latent, timestep, pred | next_latent, next_timestep |
| **Codec** | Encode/decode представления | image или latent | latent или image |
| **Adapter** | Адаптация по условию | condition, [hidden] | adapted |
| **Conditioner** | Кодирование условия | text/image/token_ids | embedding |
| **Tokenizer** | Текст ↔ токены | text | token_ids [, attention_mask] |
| **Guidance** | Коррекция предсказания | pred_cond, pred_uncond, [scale] | pred_guided |

### 13.2 Иерархия уровней

| Уровень | Сущности |
|---------|----------|
| Фундамент | Abstract Base Block, Abstract Graph Node |
| Над фундаментом | Abstract Backbone, Solver, Codec, Adapter, Conditioner, Tokenizer, Guidance, … (узлы-задачи) |
| Конкретные реализации | UNet2D, DDIMSolver, AutoencoderKL, LoRA, CLIPEncoder, … |
| Граф | Узлы = экземпляры реализаций; рёбра = связи портов |

Связь с фундаментом: [Abstract_Block_And_Node.md](Abstract_Block_And_Node.md). Сериализация мира (конфиг узлов): [World_Serialization.md](World_Serialization.md).
