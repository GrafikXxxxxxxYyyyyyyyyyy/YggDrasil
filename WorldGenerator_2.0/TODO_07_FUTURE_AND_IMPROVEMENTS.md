# TODO 07: Дальнейшее развитие фреймворка — что можно реализовать, добавить и улучшить

Документ описывает **направления развития проекта как фреймворка** после реализации ядра (TODO_01 … TODO_06): что можно реализовать дальше, как развивать другой проект на этой базе, что добавить, какие технические улучшения внедрить, как расширить поддержку моделей и модальностей (в т.ч. **VLM**, видео, аудио, мультимодальность, стриминг), как модернизировать и улучшить фреймворк в целом. Цель — максимально полно наметить возможности модификации, модернизации и расширения без нарушения канона ([Scheme.md](Scheme.md), [Philosophy.md](Philosophy.md)).

**Канон и база:** [SCALABILITY_AND_EXTENSIBILITY.md](SCALABILITY_AND_EXTENSIBILITY.md), [Abstract_Task_Nodes.md](Abstract_Task_Nodes.md), [TODO_01_FOUNDATION.md](TODO_01_FOUNDATION.md) … [TODO_06_WORLD.md](TODO_06_WORLD.md).

**Границы:** это не обязательный план реализации, а **каталог возможностей** — что можно добавить, улучшить и поддержать поверх уже описанной архитектуры. Реализация по пунктам — по приоритету и ресурсам.

---

## 1. Поддержка моделей и модальностей (LLM, VLM, видео, аудио, мультимодальность)

### 1.1 VLM (Vision–Language Models)

- [ ] **Явная поддержка VLM как типа блока/узла:** абстракция узла-задачи для «визуально-языковых» моделей: входы — image (+ опционально text), выход — text (или структурированный ответ). Контракт портов: `image`, `prompt`/`text` (опционально), `output` (текст/токены). Реализации: блоки-обёртки над CLIP-like, LLaVA, Qwen-VL, GPT-4V-style API и т.д.; регистрация в реестре под типами `conditioner/vlm`, `backbone/vlm` и т.п. Использование в графе: описание изображений (Философ), ответы по картинке в цикле мира, image captioning в пайплайнах. Связь с [SCALABILITY_AND_EXTENSIBILITY.md](SCALABILITY_AND_EXTENSIBILITY.md) (VLM уже упомянуты; добавить стандартные контракты портов и примеры).
- [ ] **Типы данных портов для изображений:** в контракте портов явно поддерживать тип «image» (тензор, PIL, путь, base64, URL) с опциональной нормализацией/препроцессингом на границе блока; единый формат обмена между узлами (например, тензор фиксированного формата после препроцессинга). Документировать соглашения для VLM-узлов.
- [ ] **Референсные реализации VLM-блоков:** один или несколько готовых блоков (например, на базе Hugging Face `transformers` или локального API) с конфигом и примером графа «image → VLM → text» для быстрого старта другого проекта.

### 1.2 Видео (Video)

- [ ] **Узлы-задачи для видео:** абстракции и контракты портов для видео-входов/выходов: например, `video` (тензор [B,T,C,H,W] или путь к файлу/URL), `video_latent`, `num_frames`, `fps`. Типы узлов: backbone для видео-диффузии (3D UNet, DiT для видео), codec для видео (encode/decode видео↔латент), conditioner для видео (текст/изображение → условие для видео-модели). Регистрация под типами `backbone/video`, `codec/video` и т.д.
- [ ] **Графы и пайплайны для видео-задач:** image-to-video, text-to-video, video-to-video, видео-апскейл — как композиции существующих абстракций с видео-портами. Шаблоны графов/пайплайнов для типовых видео-сценариев; документировать в [Graph_Level.md](Graph_Level.md) и в примерах.
- [ ] **Сериализация и чекпоинты для видео-моделей:** большие чекпоинты (разбиение на части, lazy loading); поддержка ссылок на внешние артефакты (URL хранилища) в конфиге графа/блока. Совместимость с [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md).

### 1.3 Аудио (Audio)

- [ ] **Узлы для аудио:** контракты портов для аудио (waveform, mel-spectrogram, аудио-эмбеддинги); узлы-задачи: conditioner для аудио, codec (audio encode/decode), backbone для аудио-генерации. Типы `conditioner/audio`, `codec/audio` и т.д. Поддержка text-to-speech, speech-to-text как графы с такими блоками.
- [ ] **Форматы и длительность:** явная поддержка переменной длины (padding/masking, chunking) в контракте портов для аудио и видео; документировать ограничения по длительности в конфиге блока.

### 1.4 Мультимодальность и комбинированные условия

- [ ] **Мультимодальные conditioner’ы:** один узел с несколькими входами (text, image, audio) и общим выходом (condition embedding); контракт портов с опциональными входами и политикой объединения (concat, cross-attention, adapter). Регистрация и примеры графов (текст+картинка → один condition → backbone).
- [ ] **Единый тип «multimodal_input» в схеме портов:** словарь или структурированный объект с полями по модальностям; валидация на уровне графа (совместимость типов при AddEdge) с учётом мультимодальных типов.
- [ ] **Расширение state в мире:** при необходимости расширить схему state (пять блоков) мультимодальными слотами (артефакты = изображения + видео + аудио + текст); обратная совместимость с каноном (пять блоков остаются ядром). Документировать в [Scheme.md](Scheme.md) или в отдельном расширении.

### 1.5 Стриминг (streaming) выводов

- [ ] **Стриминг токенов/чанков на уровне блока:** контракт блока с опциональным режимом «stream»: выход — итератор/генератор токенов или чанков (для LLM, TTS, частично для генерации изображений по чанкам). Исполнитель графа поддерживает run(..., stream=True) и проброс стриминговых выходов в следующие узлы (буферизация или потоковая передача по контракту).
- [ ] **Стриминг на уровне графа и пайплайна:** выход графа/пайплайна может быть потоковым (например, текст по токенам, аудио по чанкам); контракт get_output_spec поддерживает флаг streamable; API run возвращает итератор или callback для поточной выдачи. Удобно для чат-интерфейсов и длинных генераций.
- [ ] **Backpressure и таймауты:** при стриминге между узлами задать политику буферизации, таймауты и отмену; документировать контракт для блоков с потоковым выводом.

---

## 2. Бэкенды и рантаймы (инференс, обучение)

### 2.1 Несколько бэкендов для одного типа модели

- [ ] **Абстракция бэкенда (Backend):** блок может быть собран с разными бэкендами выполнения: «native» (PyTorch/JAX в процессе), «ONNX», «OpenVINO», «vLLM», «TGI» (Text Generation Inference), «TensorRT» и т.д. Конфиг блока включает `backend: "onnx"` или `backend: "vllm"` с параметрами (путь к модели, URL, опции). Один и тот же логический узел (например, LLM для Автора) можно развернуть как локальный PyTorch или как вызов vLLM/TGI на другом эндпоинте. Связь с [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md).
- [ ] **Реестр бэкендов:** по типу блока и backend выбирается фабрика создания (загрузка ONNX, подключение к vLLM API и т.д.); сериализация конфига и чекпоинта учитывает бэкенд (разные пути/форматы для разных бэкендов). Документировать поддерживаемые пары (block_type, backend).
- [ ] **Квантизация и оптимизация:** конфиг блока поддерживает опции квантизации (int8, int4, GPTQ, AWQ и т.д.) и компиляции (torch.compile, XLA); при загрузке чекпоинта применение выбранной квантизации/оптимизации. Совместимость с загрузкой из чекпоинта на каждом уровне.

### 2.2 Асинхронное выполнение и батчинг

- [ ] **Async run:** опциональный API `run_async(...)` для графа/пайплайна/этапа/мира — неблокирующее выполнение с возвратом Future/Coroutine; полезно для серверов и UI. Внутри — асинхронные вызовы блоков (если блок поддерживает async forward) или вынос в пул потоков/процессов.
- [ ] **Батчинг на уровне графа:** run(graph, inputs_batch) где inputs_batch — список словарей входов; исполнитель по возможности батчит вызовы одинаковых узлов (несколько запросов через один forward для одного блока). Политика батчинга (авто, фиксированный размер, таймаут сбора батча) задаётся в конфиге или в run(..., batch_size=...). Документировать ограничения (не все графы допускают простой батчинг из-за топологии).
- [ ] **Очереди и воркеры:** опциональный режим «граф как воркер»: входы поступают из очереди (Redis, RabbitMQ, внутренняя очередь), результаты пишутся в другую очередь; масштабирование числом воркеров. Описание в разделе «Развёртывание» или отдельный документ.

### 2.3 Распределённое обучение и инференс

- [ ] **DataParallel / DistributedDataParallel на уровне графа:** при обучении графа поддержка обёртки графа в DDP (или аналог для JAX); конфиг обучения с world_size, rank, backend. Градиенты и синхронизация остаются на совести фреймворка (PyTorch/JAX); фреймворк передаёт в оптимизатор trainable_parameters() графа/пайплайна/этапа/мира.
- [ ] **Pipeline parallelism и model parallelism:** для очень больших моделей — разбиение одного блока (или графа) на несколько устройств/процессов; контракт «блок-часть» и сборка распределённого блока из конфига. Документировать как расширение; референсная реализация опциональна.
- [ ] **Спекулятивная декодирование (speculative decoding):** для LLM-узлов опциональная поддержка драфт-модели + верификационной модели; конфиг блока с draft_model_ref и policy. Ускоряет инференс текста; не меняет контракт портов.

---

## 3. Наблюдаемость, отладка, тестирование

### 3.1 Трейсинг и метрики

- [ ] **Структурированное логирование и трейсинг:** единый формат логов (уровень, stage_id/graph_id/node_id, phase, duration, payload_size); интеграция с OpenTelemetry или аналогом (traces, spans на уровень вызова run графа/пайплайна/этапа/мира и при необходимости на уровень узла/блока). Опционально передача trace_id через run(..., trace_context=...).
- [ ] **Метрики:** счётчики вызовов, гистограммы задержек, объём данных на портах; экспорт в Prometheus/StatsD или callback. Хуки (callbacks) уже предусмотрены в TODO_03–06; расширить контракт хуков до «метрика + лог + трейс».
- [ ] **Профилирование:** режим run(..., profile=True) с сбором профиля (cProfile, PyTorch profiler, torch.compile profile); сохранение артефакта профиля в указанный путь. Документировать для отладки производительности.

### 3.2 Валидация и тесты

- [ ] **Схемы конфигов (JSON Schema / Pydantic):** формальное описание схемы конфига графа, пайплайна, этапа, мира (и при необходимости блоков); валидация при from_config и from_yaml с понятными ошибками. Генерация схем из кода или ручное описание в репозитории; опционально генерация документации из схем.
- [ ] **Контрактные тесты:** тесты на соответствие контракту портов (типы, обязательность) для всех стандартных узлов-задач; регрессия при изменении абстракций. Набор тестов для исполнителя графа (топология, циклы, буфер, run → outputs).
- [ ] **Интеграционные тесты:** прогон канонического цикла мира с моками или лёгкими моделями (маленький граф, один этап на граф); проверка условий выполнения по Scheme §4.8 (таблица «что передал пользователь → что выполняется»). Тесты на сериализацию/десериализацию на каждом уровне (конфиг + чекпоинт).
- [ ] **Регрессия воспроизводимости:** фиксированные сиды и версии; тесты «конфиг + чекпоинт + вход → один и тот же выход» для референсных графов/пайплайнов.

### 3.3 Визуализация и отладка

- [ ] **Визуализация графа/пайплайна/этапа/мира:** экспорт в DOT/GraphML или аналог для отрисовки графа (узлы, рёбра, подписи портов); опционально веб-инструмент для просмотра конфига и топологии. Удобно для отладки и документации.
- [ ] **Dry run и пошаговый режим:** уже упомянуты в TODO_03–06; расширить: пошаговое выполнение с паузами между узлами, вывод промежуточных значений буфера (по флагу или в отладочном режиме). Логирование состояния state после каждого этапа в run мира.
- [ ] **Диффы конфигов и миграции:** утилита сравнения двух конфигов (старая/новая версия) и рекомендации по миграции при изменении schema_version; документировать правила обратной совместимости.

---

## 4. Фреймворк как продукт: API, CLI, SDK, UI

### 4.1 REST / gRPC API сервер

- [ ] **Единый API сервер для графа/пайплайна/этапа/мира:** поднять сервер (FastAPI, Flask, gRPC), который по конфигу загружает граф (или пайплайн/этап/мир) и экспонирует эндпоинты: POST /run с телом { inputs } и ответом { outputs }; опционально /run/stream для потокового вывода. Конфиг сервера: путь к конфигу графа/пайплайна, порт, CORS, лимиты. Соответствие [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md) (каждый граф на своём эндпоинте = один такой сервер на граф).
- [ ] **OpenAPI/Swagger:** генерация спецификации API из контракта графа (get_input_spec, get_output_spec); документирование типов и примеров запросов/ответов. Клиенты и UI могут генерироваться из OpenAPI.
- [ ] **Аутентификация и лимиты:** опциональная проверка API-ключа или JWT; rate limiting по IP или по ключу; конфиг в настройках сервера. Без изменения контракта run.

### 4.2 CLI (Command Line Interface)

- [ ] **Команды для сборки и запуска:** например, `yggdrasil run --config graph.yaml --input prompt="..." --output-dir ./out`; `yggdrasil build --template text_to_image --param resolution=1024`; `yggdrasil validate --config pipeline.yaml`. Единая точка входа (entrypoint) с подкомандами run, build, validate, export, serve и т.д.
- [ ] **Сервер из CLI:** `yggdrasil serve --config graph.yaml --port 8000` — запуск API сервера для данного графа/пайплайна. Параметры: device, workers, log level.
- [ ] **Экспорт и упаковка:** `yggdrasil export --config graph.yaml --checkpoint ./ckpt --format onnx` (если поддерживается); упаковка графа + чекпоинт в один артефакт (zip/tar) для переноса. Документировать форматы.

### 4.3 Python SDK и высокоуровневый API

- [ ] **Удобные фасады:** например, `World.from_template("storytelling", style="fantasy").run(state=None, action="...")`; `Pipeline.from_preset("text_to_video").run(inputs)`. Пресеты и шаблоны зарегистрированы; SDK скрывает детали конфига там, где пользователь хочет «просто запустить».
- [ ] **Типизация (type hints):** полная аннотация публичного API (run, from_config, get_input_spec и т.д.) для IDE и mypy/pyright; опционально дженерики для типов state/inputs/outputs по конфигу. Улучшение DX без изменения поведения.
- [ ] **Документация API:** автогенерация из docstrings (Sphinx, MkDocs, pdoc); примеры кода в docstring и отдельные tutorials. Раздел «Quick start» и «Migration from 1.x» при необходимости.

### 4.4 Веб-UI и студия (опционально)

- [ ] **Минимальный веб-интерфейс:** форма с полями по input_spec графа/пайплайна, кнопка Run, отображение outputs (текст, превью изображений/видео). Вызовы к локальному или удалённому API серверу. Полезно для демо и ручной отладки.
- [ ] **Студия конфигов:** редактор YAML/JSON конфига с подсветкой и подсказками по схеме; визуализация графа по текущему конфигу; кнопка Validate и Run. Можно реализовать как отдельное приложение (Electron, React + бэкенд) или простой single-page app. Не входит в ядро фреймворка; описать как возможное расширение.

---

## 5. Экосистема и переиспользование

### 5.1 Интеграция с Hugging Face и другими реестрами

- [ ] **Загрузка моделей и конфигов с Hugging Face Hub:** конфиг блока может ссылаться на `hf://org/repo` или `hf://org/repo@revision`; при загрузке графа/пайплайна подтягивание конфига и чекпоинта с Hub. Реестр типов блоков может включать «стандартные» типы с дефолтной реализацией из Hugging Face (transformers, diffusers).
- [ ] **Публикация артефактов:** утилита или скрипт загрузки графа/пайплайна/мира (конфиг + чекпоинт) на Hub как модель/датасет; карточка с описанием, тегами, примером использования. Другие проекты могут подключать мир/граф по ссылке.
- [ ] **Каталог шаблонов и пресетов:** репозиторий или раздел документации с перечнем шаблонов (text-to-image, text-to-video, storytelling world, …) и параметрами; ссылки на конфиги и при необходимости на чекпоинты. Обновление каталога по мере добавления новых шаблонов.

### 5.2 Плагины и расширения

- [ ] **Плагинная загрузка блоков и шаблонов:** механизм регистрации блоков и шаблонов из внешних пакетов (entry points, например `yggdrasil.blocks`, `yggdrasil.templates`); установка пакета `pip install yggdrasil-vlm` добавляет VLM-блоки в реестр без изменения кода ядра. Документировать контракт плагина (какие функции/классы экспортировать).
- [ ] **Версионирование плагинов и совместимость:** при загрузке плагина проверка совместимости версии ядра; в конфиге графа опционально указывать требуемые плагины и их версии. Предупреждение при отсутствии плагина для зарегистрированного типа блока.

### 5.3 Примеры и учебные материалы

- [ ] **Минимальные воспроизводимые примеры:** по одному примеру на уровень: граф (одна задача), пайплайн (две задачи подряд), этап (один пайплайн), мир (минимальный цикл из 5 этапов с моками). Каждый пример — конфиг + скрипт run + ожидаемый вывод или тест.
- [ ] **Cookbook:** сценарии «как добавить свой блок», «как собрать граф из конфига», «как развернуть граф на эндпоинте», «как обучить только LoRA мира»; пошаговые инструкции с кодом. Ссылки из основного README.
- [ ] **Миграция и лучшие практики:** документ «как перенести проект с другой стека на Yggdrasil»; рекомендации по именованию, структуре конфигов, версионированию чекпоинтов.

---

## 6. Надёжность, безопасность, воспроизводимость

### 6.1 Воспроизводимость

- [ ] **Сид и генераторы случайности:** конфиг run поддерживает `seed`; при установке сида все блоки (и фреймворк) получают детерминированное поведение, где это возможно (PyTorch, numpy, random). Документировать, какие части графа могут оставаться недетерминированными (например, внешние API).
- [ ] **Версионирование зависимостей и конфига:** в метаданных конфига/чекпоинта записывать версию фреймворка и опционально версии ключевых библиотек (torch, transformers, …); при загрузке предупреждать о несовпадении версий. Рекомендация фиксировать зависимости в requirements.txt / environment.yaml по мажорной версии.

### 6.2 Безопасность и санитизация

- [ ] **Валидация входов на границе API:** при приёме inputs в run и в REST API проверка типов и размеров (по контракту); отклонение запросов с неверным форматом. Защита от переполнения (лимит размера payload, числа элементов в батче).
- [ ] **Изоляция выполнения:** опциональный режим запуска графа в подпроцессе или sandbox (например, для непроверенных конфигов); таймаут на run. Документировать ограничения sandbox.
- [ ] **Секреты в конфиге:** не хранить пароли и API-ключи в конфиге в открытом виде; поддержка переменных окружения или внешнего секрет-менеджера (например, `ref: env:HF_TOKEN`). Предупреждение в документации.

### 6.3 Устойчивость к сбоям

- [ ] **Повторные попытки и таймауты:** при вызове удалённого эндпоинта (multi-endpoint) настраиваемые retry и timeout; экспоненциальный backoff. Конфиг пайплайна/этапа: retry_policy, timeout_per_node.
- [ ] **Чекпоинтинг длинных run:** при длительном run мира (много шагов) опционально периодическое сохранение промежуточного state и возможность возобновления с последнего чекпоинта. Реализация опциональна; описать в разделе «Продвинутое использование».

---

## 7. Производительность и оптимизация

### 7.1 Вычисление и память

- [ ] **Mixed precision (FP16/BF16):** конфиг блока и run поддерживают dtype (float16, bfloat16); автоматическая кастование тензоров на границах узлов при совместимости. Снижение памяти и ускорение на GPU.
- [ ] **Компиляция графа (torch.compile, JAX jit):** опционально обёртка «весь граф как одна функция» с компиляцией для снижения накладных расходов; ограничения (динамические формы, условные ветви) документировать. Экспериментальная опция.
- [ ] **Кэширование неподвижных узлов:** при многократных run с одинаковыми входами для части графа кэшировать выходы неизменяемых узлов (по хешу входов). Полезно для conditioner’ов при нескольких шагах солвера. Конфиг: cache_policy per node или global.

### 7.2 Хранение и передача данных

- [ ] **Ленивая загрузка тяжёлых артефактов:** порт может содержать «ссылку» (URI, путь) вместо самого тензора/изображения; блок загружает данные по требованию. Уменьшение передачи по сети при multi-endpoint и объёма буфера.
- [ ] **Сжатие и кодирование на рёбрах:** при передаче между эндпоинтами опциональное сжатие (gzip, бинарный протокол); сериализация больших тензоров в эффективный формат (например, numpy.savez_compressed, или streaming). Конфиг транспорта для пайплайна/этапа.

---

## 8. MLOps и эксперименты

### 8.1 Эксперименты и логирование

- [ ] **Интеграция с MLflow / Weights & Biases / Neptune:** опциональный callback или адаптер, который при run (обучение или инференс) логирует параметры, метрики, артефакты (конфиг, чекпоинт, примеры выходов). Конфиг: experiment_tracking: { backend: "mlflow", uri: "...", run_name: "..." }. Не менять ядро run; только хуки.
- [ ] **Версионирование экспериментов:** связка «конфиг + чекпоинт + git commit + метрики» для воспроизводимости экспериментов; скрипт или команда CLI для регистрации run в трекере. Документировать рекомендуемый workflow.

### 8.2 Реестр моделей и артефактов

- [ ] **Реестр графов/пайплайнов/миров:** внутренний или внешний реестр (каталог конфигов + чекпоинтов с версиями и метаданными); API «загрузить граф по имени и версии». Совместимо с Hub или с внутренним хранилищем (S3, артефакт-сервер).
- [ ] **A/B тестирование конфигов:** утилита или режим run, при котором один и тот же вход прогоняется через несколько конфигов (например, две версии мира) и результаты сравниваются; вывод метрик сравнения. Опциональная фича для продакшена.

---

## 9. Документация и канон

### 9.1 Актуализация канона при расширениях

- [ ] **Расширение Scheme и World_Level при новых модальностях:** если в state или в этапах вводятся новые типы артефактов (видео, аудио), описать в Scheme или в отдельном «Extension» документе без ломки существующих пяти блоков. Обратная совместимость: старые конфиги продолжают работать.
- [ ] **Глоссарий и индекс:** единый глоссарий терминов (Block, Node, Graph, Pipeline, Stage, World, State, Port, …) и индекс по документам; обновлять при добавлении новых сущностей. Разместить в README или в docs/.

### 9.2 Версионирование документации и API

- [ ] **Версия API фреймворка:** семантическое версионирование (например, 2.0.0); в конфигах и чекпоинтах указывать schema_version или api_version. Правила обратной совместимости: минорная версия — добавления без ломки; мажорная — возможные breaking changes с миграцией. Документировать в CHANGELOG.
- [ ] **Deprecation policy:** помечать устаревшие параметры/методы как deprecated с указанием замены и срока удаления; предупреждения в логах при использовании. Стабильность для сторонних проектов, строящихся на фреймворке.

---

## 10. Сводная таблица направлений

| Направление | Примеры задач | Связь с каноном |
|-------------|----------------|-----------------|
| **VLM, видео, аудио, мультимодальность** | Контракты портов, узлы-задачи, референсные блоки, стриминг | [SCALABILITY_AND_EXTENSIBILITY.md](SCALABILITY_AND_EXTENSIBILITY.md); расширение без ломки абстракций |
| **Бэкенды и рантаймы** | ONNX, vLLM, TGI, async, батчинг, DDP, speculative decoding | [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md); тот же контракт run |
| **Наблюдаемость** | Трейсинг, метрики, профилирование, валидация схем, тесты | Улучшение DX и надёжности; не меняет Scheme |
| **API, CLI, SDK, UI** | REST/gRPC сервер, CLI, типизованный SDK, веб-интерфейс | Фреймворк как продукт; контракт по get_input_spec/get_output_spec |
| **Экосистема** | HF Hub, плагины, каталог шаблонов, примеры, cookbook | [World_Serialization.md](World_Serialization.md), реестр типов из TODO_01 |
| **Надёжность и безопасность** | Воспроизводимость, валидация входов, секреты, retry | Продакшен-готовность |
| **Производительность** | Mixed precision, кэш, ленивая загрузка, сжатие | Оптимизация без смены семантики |
| **MLOps** | MLflow/W&B, реестр моделей, A/B тесты | Обучение и развёртывание поверх фреймворка |
| **Документация и версии** | Глоссарий, CHANGELOG, deprecation, миграции | Соответствие Philosophy и Scheme при эволюции |

Итого: фреймворк можно **модифицировать, модернизировать и расширять** по всем перечисленным направлениям; канон ([Scheme.md](Scheme.md), [Philosophy.md](Philosophy.md)) и иерархия уровней (граф → пайплайн → этап → мир) сохраняются. Реализация пунктов — по приоритету; каждый пункт можно развивать в отдельном проекте или модуле поверх ядра Yggdrasil/World Generator 2.0.
