# TODO 05: Уровень этапа (Stage) — полная реализация

Полный, технически грамотный и согласованный TODO по **реализации уровня этапа (Stage)** — следующего после пайплайна: этап как «граф пайплайнов», структура данных, построение, валидация, исполнитель, **контракт по state**, условия выполнения (в т.ч. по [Scheme.md](Scheme.md)), сериализация (конфиг + веса), загрузка из чекпоинта, обучение, конфиг и шаблоны, multi-endpoint и связь с миром. Учтены вся база проекта, [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md), [TRAINABILITY_AT_ALL_LEVELS.md](TRAINABILITY_AT_ALL_LEVELS.md), [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md), [World_Serialization.md](World_Serialization.md), [Scheme.md](Scheme.md), [World_Level.md](World_Level.md).

**Канон:** [Stage_Level.md](Stage_Level.md), [Pipeline_Level.md](Pipeline_Level.md), [World_Level.md](World_Level.md), [Scheme.md](Scheme.md). Предшествующие уровни: [TODO_01_FOUNDATION.md](TODO_01_FOUNDATION.md) … [TODO_04_PIPELINE.md](TODO_04_PIPELINE.md).

**Границы этого TODO:** этап — **граф, узлами которого являются пайплайны** (пайплайн может состоять из одного графа); рёбра этапа соединяют **внешние выходы одного пайплайна с внешними входами другого**; по рёбрам передаётся **state** (в каноне — контейнер из пяти блоков); контракт этапа задаётся по **state** (входные/выходные блоки state); выполнение — по топологии с **условиями выполнения** по заполненности блоков state (Scheme); сериализация этапа = структура + агрегация чекпоинтов пайплайнов; загрузка из чекпоинта; обучение выбранных пайплайнов; конфиг и шаблоны; связь с миром (этап как узел мира).

---

## Зависимости от предыдущих уровней

| Компонент | Откуда берётся | Как используется этапом |
|-----------|----------------|--------------------------|
| **Пайплайн (Pipeline)** | TODO_04 | Узел этапа = целый пайплайн. Этап хранит отображение `stage_node_id → Pipeline`. Выполнение узла = `pipeline.run(inputs)`; контракт пайплайна (get_input_spec, get_output_spec) задаёт порты для рёбер этапа; данные на границе этапа интерпретируются как **state** (или мапятся в/из state). |
| **Контракт пайплайна** | TODO_04 | Входы/выходы пайплайна (имена и типы). Рёбра этапа связывают (source_node_id, source_port) с (target_node_id, target_port). При добавлении ребра проверяется совместимость по контрактам пайплайнов. **Маппинг state ↔ порты пайплайна:** этап задаёт, какие блоки state подаются на какие входы пайплайна и какие выходы пайплайна записываются в какие блоки state. |
| **Сериализация пайплайна** | TODO_04 | Конфиг пайплайна (графы, рёбра, exposed I/O); чекпоинт пайплайна = чекпоинты графов. Конфиг этапа содержит конфиги пайплайнов (вложенные или ref); чекпоинт этапа = совокупность чекпоинтов пайплайнов. |
| **Загрузка пайплайна из чекпоинта** | TODO_04 | При загрузке этапа из чекпоинта для каждого пайплайна-узла вызывается загрузка структуры и весов. |
| **State (схема)** | Scheme, World_Level | State — контейнер с блоками (в каноне пять блоков). Этап объявляет **контракт по state:** какие блоки требуются на входе, какие блоки заполняются на выходе; **условия выполнения** этапа (выполнять только если заполнены нужные блоки — по Scheme: Философ при 1,2,3; Автор при 1–4; World update при всех 5; Development безусловно и т.д.). |
| **Мир** | World_Level | Мир — граф этапов; узел мира = этап. Контракт этапа (вход/выход по state) используется миром для передачи state между этапами и для проверки условий выполнения. |

Без реализованного уровня пайплайна (TODO_04) этап не может ни хранить пайплайны, ни выполнять их, ни сериализовать/загружать; при реализации этапа предполагается, что пайплайн имеет стабильный контракт и API run/save/load. Схема state и условия выполнения берутся из [Scheme.md](Scheme.md).

---

## 1. Структура данных этапа

### 1.1 Что реализовать

- [ ] **Этап (Stage)** — контейнер с: (1) **узлы:** отображение `stage_node_id: str → Pipeline` (каждый узел — целый пайплайн); (2) **рёбра этапа:** список рёбер вида `(source_node_id, source_port, target_node_id, target_port)`, где порты — **внешние** порты пайплайнов; (3) **внешний контракт этапа по state:** описание входов/выходов этапа в терминах **state** — какие блоки state (или поля state) подаются на этап, какие блоки/поля этап заполняет на выходе; при необходимости **маппинг** «блок state ↔ (stage_node_id, port_name)» для граничных пайплайнов; (4) **роль этапа** `stage_id` / `role` (например, `creator`, `author`, `philosopher`, `architect`, `environment`) для идентификации в цикле мира; (5) **условие выполнения** (опционально привязанное к этапу): при каком состоянии state этап выполняется (например, «только если заполнены блоки 1,2,3» по Scheme); (6) метаданные (версия схемы, описание).
- [ ] **Инварианты:** каждый stage_node_id в рёбрах присутствует в узлах; source_port и target_port — имена из get_output_spec(source_pipeline) и get_input_spec(target_pipeline); типы совместимы. Внешние входы этапа (по state) мапятся на входы граничных пайплайнов; внешние выходы этапа — на выходы граничных пайплайнов.
- [ ] **Индексы:** по stage_node_id быстро получать входящие и исходящие рёбра этапа (in_edges, out_edges) для исполнителя и валидации.

### 1.2 Вырожденный случай: этап из одного пайплайна

- [ ] Этап может состоять из **одного узла** (одного пайплайна). Рёбер между пайплайнами нет; контракт этапа по state = маппинг state ↔ контракт этого пайплайна. Выполнение: один вызов pipeline.run(inputs), где inputs получены из входящего state по маппингу. Это типичный случай для многих фаз цикла мира (например, Творец = один пайплайн из одного графа text-to-image). Связь с [Stage_Level.md](Stage_Level.md) §2–3.

### 1.3 Контракт по state

- [ ] **State schema:** описание структуры state (в каноне — пять блоков; при расширении — дополнительные поля). Этап объявляет: **input_state_spec** — какие блоки (или поля) обязательны на входе; **output_state_spec** — какие блоки этап заполняет на выходе; при необходимости **partial state** (этап читает только часть state и дополняет её).
- [ ] **Маппинг state → входы пайплайнов:** для граничных пайплайнов (имеющих входящие рёбра от внешнего входа этапа) задаётся соответствие: блок state (или поле) → имя входа пайплайна. Аналогично **выходы пайплайнов → блоки state** для граничных пайплайнов. Реализация: при run(stage, state) из state собираются значения по input_state_spec и маппятся в словарь inputs для пайплайнов; после выполнения выходы пайплайнов по маппингу записываются в результирующий state.
- [ ] **Связь с Scheme:** условия выполнения этапа (Философ — только при 1,2,3; Автор — только при 1–4; World update — только при всех 5; Development — безусловно) могут быть заданы в конфиге этапа или в конфиге мира; исполнитель этапа или мир проверяет заполненность state перед вызовом stage.run(). См. п. 4 и 10.

### 1.4 Критерии

- [ ] По этапу однозначно определены множество пайплайнов-узлов, множество рёбер этапа, контракт по state (input/output state spec, маппинг state ↔ порты), роль и опционально условие выполнения; запрос in/out рёбер по stage_node_id выполняется без полного перебора.

---

## 2. API построения этапа (Stage Builder)

### 2.1 Добавление пайплайна как узла

- [ ] **AddPipeline(pipeline_or_config, stage_node_id=None):**
  - **Вариант A:** `pipeline_or_config` — экземпляр Pipeline. Тогда `stage_node_id` обязателен или генерируется (например, pipeline.pipeline_id или `"pipeline_" + str(len(nodes))`). Узел этапа = этот пайплайн; контракт берётся из пайплайна.
  - **Вариант B:** `pipeline_or_config` — словарь конфига пайплайна (или путь к YAML/JSON). Пайплайн создаётся через `Pipeline.from_config(config)`; stage_node_id задаётся или из конфига, или генерируется.
  - **Уникальность stage_node_id:** при добавлении проверять, что идентификатор не занят; иначе ошибка или генерация уникального.
- [ ] **Связь с проектом:** пайплайн — единственная исполняемая единица внутри этапа; этап не собирает пайплайны «из графов», только принимает готовый пайплайн или собирает из конфига (делегируя Pipeline.from_config).

### 2.2 Добавление ребра этапа

- [ ] **AddEdge(source_node_id, source_port, target_node_id, target_port):**
  - Проверить: source_node_id и target_node_id есть в этапе. source_port — из get_output_spec(source_pipeline); target_port — из get_input_spec(target_pipeline); типы совместимы. Добавить ребро; обновить индексы.
- [ ] **Связь с миром:** мир на своём уровне задаёт рёбра между этапами (передача state); этап внутренне задаёт рёбра между пайплайнами по портам пайплайнов.

### 2.3 Контракт этапа по state и маппинг

- [ ] **set_state_contract(input_blocks, output_blocks, mapping_input=None, mapping_output=None):** задать, какие блоки state требуются на входе этапа и какие блоки этап заполняет на выходе; опционально явный маппинг: для граничных узлов список пар (блок state или поле, stage_node_id, port_name). Если маппинг не задан — автовывод: внешние входы этапа (пайплайны без входящих рёбер от других пайплайнов) мапятся на input_blocks по порядку или по именам; внешние выходы этапа — на output_blocks.
- [ ] **set_execution_condition(condition):** опционально привязать к этапу условие выполнения (например, «только если заполнены блоки [1,2,3]»). Значение — функция (state) -> bool или конфиг (список обязательных блоков). Используется миром или исполнителем этапа перед вызовом run; если условие ложно, этап может быть пропущен (state передаётся дальше без выполнения этапа). Связь с [Scheme.md](Scheme.md) §4.
- [ ] **Роль этапа:** при создании или в конфиге задаётся `stage_id` / `role` (creator, author, philosopher, architect, environment) для использования в цикле мира и в шаблонах.

### 2.4 Внешние входы/выходы этапа (по state)

- [ ] Внешний «вход» этапа — state (или часть state), подаваемая извне (от предыдущего этапа мира или от пользователя). Внешний «выход» этапа — state (или обновлённый state) после выполнения этапа. API run: `run(stage, state, *, action=None, ...) -> state` — state на входе, state на выходе; опционально **action** пробрасывается в пайплайны (например, в Среда/Development of the world по Scheme). Контракт этапа (get_state_input_spec, get_state_output_spec или аналог) для мира и оркестрации.

### 2.5 Критерии приёмки (Builder)

- [ ] Этап можно собрать программно: AddPipeline (пайплайн или конфиг), AddEdge между внешними портами пайплайнов; задание контракта по state и опционально условия выполнения и роли. Уникальность stage_node_id; валидация портов при AddEdge.

---

## 3. Валидация этапа

### 3.1 При добавлении ребра

- [ ] Существование source_node_id и target_node_id; source_port в get_output_spec(source_pipeline), target_port в get_input_spec(target_pipeline); совместимость типов.

### 3.2 Полная валидация

- [ ] **Топология:** граф этапа (вершины = пайплайны, рёбра = рёбра этапа) должен быть **DAG** — циклы между пайплайнами на уровне этапа не допускаются. При обнаружении цикла — ошибка.
- [ ] **Достижимость:** каждый пайплайн-узел достижим от входа этапа (state или граничный пайплайн) и ведёт к выходу этапа; иначе предупреждение.
- [ ] **Контракт по state:** input_state_spec и output_state_spec согласованы с маппингом (все указанные блоки имеют соответствующие порты граничных пайплайнов); типы данных state (если заданы) совместимы с типами портов.
- [ ] **Внутренняя валидность пайплайнов:** опционально для каждого пайплайна вызвать pipeline.validate(); ошибки агрегировать с указанием stage_node_id.
- [ ] **Условие выполнения:** если задано, проверить, что оно ссылается на существующие блоки state (по state schema).

### 3.3 Реализация

- [ ] Метод `Stage.validate(strict=True) -> ValidationResult` с перечисленными проверками; при strict=False только предупреждения.

---

## 4. Исполнитель этапа (Executor)

### 4.1 Топологический порядок и буфер

- [ ] Этап — DAG пайплайнов; **топологическая сортировка** узлов. **Буфер:** ключ — (stage_node_id, port_name) для внешних выходов пайплайнов; значение — результат пайплайна по этому порту. Вход этапа (state) по маппингу преобразуется в значения для граничных пайплайнов и кладётся в буфер; после выполнения всех пайплайнов выходы по маппингу собираются в **исходящий state**.
- [ ] **Сигнатура run:** `run(stage, state, *, action=None, training=False, device=None, callbacks=None, **kwargs) -> state`. state — входящий state (словарь блоков или объект State); action — опционально передаётся в пайплайны (например, в узел Development); training, device, kwargs пробрасываются в pipeline.run(); callbacks — хуки на начало/конец выполнения каждого пайплайна-узла. Возвращается новый state (или обновлённый объект state) после выполнения этапа.

### 4.2 Условие выполнения этапа (по Scheme)

- [ ] **Проверка до run:** если у этапа задано execution_condition (например, «только при заполненных блоках 1,2,3»), вызывающий (мир или оркестратор) **до** вызова stage.run(state) проверяет условие по state. Если условие ложно — этап **пропускается**: stage.run() не вызывается, входящий state передаётся дальше без изменений (или с документированной семантикой «пропуск»). Это реализуется на уровне **мира** (исполнитель мира проверяет условие для каждого этапа по Scheme) или этап может принимать флаг `skip_if_condition_not_met` и возвращать state без выполнения. Документировать: Философ — только при 1,2,3; Автор — только при 1–4; World update — только при всех 5; Development — безусловно; Архитектор/Творец — по потоку всегда в нужном виде. Связь с [Scheme.md](Scheme.md) §4, §4.8.

### 4.3 Критерии приёмки (Executor)

- [ ] Исполнитель по этапу и state выполняет пайплайны в топологическом порядке; данные между пайплайнами передаются через буфер; входящий state мапится на входы граничных пайплайнов, выходы мапятся в исходящий state. Поддержка action, training, device, callbacks. Условие выполнения этапа обрабатывается вызывающим (мир) или опционально внутри run (пропуск).

---

## 5. Сериализация этапа (структура — конфиг)

### 5.1 Схема конфига этапа

- [ ] **Версия:** schema_version / stage_version.
- [ ] **Узлы (пайплайны):** список записей; каждая: stage_node_id, конфиг пайплайна (вложенный или ref). Конфиг пайплайна в формате TODO_04.
- [ ] **Рёбра этапа:** список { source_node, source_port, target_node, target_port }.
- [ ] **Контракт по state:** input_state_spec, output_state_spec (список блоков или схема полей); опционально mapping_input, mapping_output (блок/поле ↔ stage_node_id, port_name).
- [ ] **Роль и условие:** stage_id / role; опционально execution_condition (список обязательных блоков или ссылка на правило по имени, например "philosopher", "author", "world_update").
- [ ] **Метаданные:** описание, default device, endpoint_url по узлам для multi-endpoint.
- [ ] **Формат:** YAML или JSON; UTF-8.

### 5.2 Сохранение и загрузка структуры

- [ ] **save_config(path)** / **to_dict():** сериализовать этап в конфиг (пайплайны с вложенными конфигами или ref, рёбра, state contract, роль, условие, метаданные). Веса не входят.
- [ ] **load_config(path)** / **from_dict(d):** прочитать конфиг; для каждого узла Pipeline.from_config(node_config); добавить рёбра; задать контракт по state, роль, условие. Получается этап без загруженных весов. Соответствие [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md).

### 5.3 Вложенность и ссылки

- [ ] Поддержка вложенных конфигов пайплайнов и ref на файлы; при сохранении опция «вложенно» или «ref». При загрузке разрешать ref.

---

## 6. Сериализация весов этапа и загрузка из чекпоинта

### 6.1 Формат чекпоинта этапа

- [ ] **Веса этапа = совокупность весов всех пайплайнов-узлов.** Чекпоинт этапа — **агрегация чекпоинтов пайплайнов** (каталог по stage_node_id или архив). Метаданные этапа (stage_id list, версия) в stage_meta.json или аналог.

### 6.2 Сохранение весов

- [ ] **save_checkpoint(path, format="dir"|"archive"):** для каждого пайплайна-узла вызвать pipeline.save_checkpoint(subpath); сохранить метаданные этапа.
- [ ] **save(save_dir):** конфиг этапа в save_dir/config.yaml; чекпоинт в save_dir/checkpoints/ (или один архив). Полная воспроизводимость.

### 6.3 Загрузка из чекпоинта

- [ ] **load_from_checkpoint(checkpoint_path, config_path=None):** если этап уже создан из конфига — загрузить веса всех пайплайнов из соответствующих подпутей. Если передан config_path — сначала from_config, затем загрузка весов.
- [ ] **load(save_dir):** по соглашению имён в save_dir загрузить конфиг и чекпоинты; вернуть экземпляр Stage. Соответствие [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md); мир при загрузке вызывает загрузку этапов-узлов.

### 6.4 Версионирование

- [ ] При сохранении записывать версию схемы этапа; при загрузке проверять совместимость.

---

## 7. Обучение на уровне этапа

### 7.1 Выбор trainable пайплайнов

- [ ] Этап задаёт, какие пайплайны-узлы **trainable**. Конфиг: список stage_node_id с флагом trainable. При обучении этапа оптимизатор получает параметры только от trainable пайплайнов (pipeline.trainable_parameters() по каждому). Соответствие [TRAINABILITY_AT_ALL_LEVELS.md](TRAINABILITY_AT_ALL_LEVELS.md).
- [ ] **Forward:** run(stage, state, training=True); градиенты при backward текут через пайплайны; замороженные не обновляются. Чекпоинты при обучении — полный save этапа или только trainable по политике.

### 7.2 Конфиг обучения

- [ ] В конфиге этапа или отдельно: trainable_nodes, lr (глобально или по узлам), freeze_others. Сериализуемость конфига обучения.

### 7.3 Критерии приёмки (обучение)

- [ ] Можно задать подмножество пайплайнов этапа как trainable; run(..., training=True) и backward обновляют только их; чекпоинт этапа сохраняет и загружает веса всех пайплайнов корректно.

---

## 8. Конфиг и шаблоны этапа

### 8.1 From_config

- [ ] **Stage.from_config(config)** / **Stage.from_yaml(path):** config с полями pipelines (узлы с конфигами), edges, state_contract (input/output spec, mapping), role, execution_condition, metadata. Для каждого узла Pipeline.from_config(); добавить рёбра; установить контракт по state, роль, условие. Валидация после сборки (опционально). Разрешение ref на конфиги пайплайнов.

### 8.2 From_template

- [ ] **Stage.from_template(template_name, **kwargs):** шаблон возвращает конфиг этапа; kwargs подставляются (например, роль, список пайплайнов, условие выполнения). Регистрация шаблонов (например, "creator_stage", "author_stage", "environment_stage" по Scheme); документировать параметры. Связь с [World_Serialization.md](World_Serialization.md) (шаблоны мира могут включать шаблоны этапов).

### 8.3 Валидация после загрузки

- [ ] После from_config вызывать stage.validate(); понятные ошибки с указанием stage_node_id и state/порта.

---

## 9. Multi-endpoint: этап с удалёнными пайплайнами

### 9.1 Реестр эндпоинтов

- [ ] В конфиге этапа для каждого пайплайна-узла можно задать локальный пайплайн или **endpoint_url**. При загрузке этапа узел с endpoint_url хранит дескриптор удалённого сервиса; при run исполнитель вызывает удалённый API вместо pipeline.run(). Сериализация/десериализация по контракту пайплайна. Соответствие [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md).
- [ ] **Гибридный режим:** часть узлов локальные пайплайны, часть — удалённые; порядок и буфер те же; state между этапами при распределённом мире передаётся сериализованно.

### 9.2 Критерии приёмки (multi-endpoint)

- [ ] В конфиге этапа можно указать endpoint_url для выбранных узлов; при run эти узлы выполняются запросом к эндпоинту; данные и state передаются через буфер после десериализации.

---

## 10. Связь с миром и Scheme

### 10.1 Этап как узел мира

- [ ] **Мир (World)** — граф этапов ([World_Level.md](World_Level.md)). Узел мира = этап. Контракт этапа по state (get_state_input_spec, get_state_output_spec) используется миром для передачи state между этапами и для проверки условий выполнения. Мир вызывает stage.run(state) для каждого этапа в порядке цикла; при необходимости мир проверяет execution_condition этапа и пропускает этап, если условие не выполнено. Связь с [Scheme.md](Scheme.md) §4, §4.8.

### 10.2 Условия выполнения по Scheme

- [ ] Документировать и при необходимости кодировать канонические условия: **Философ** — только при заполненных 1,2,3; **Автор** — только при 1–4; **World update** (внутри Среда) — только при всех 5; **Development of the world** — безусловно; **Архитектор**, **Творец** — по потоку всегда получают state в нужном виде. Этап может хранить execution_condition как конфиг (список блоков или имя пресета); мир при выполнении цикла проверяет эти условия перед вызовом этапа. Сводная таблица из [Stage_Level.md](Stage_Level.md) §5 и [Scheme.md](Scheme.md) §4 — единый источник правил.

### 10.3 State и цикл

- [ ] По рёбрам мира между этапами передаётся state; этап читает state, выполняет пайплайны, возвращает обновлённый state. Цикл замыкается через этап Среда (Development of the world создаёт новый state с блоком 1 → следующий этап по графу мира). Контракт этапа достаточен для маппинга state без знания внутренней структуры пайплайнов.

### 10.4 Документирование контракта

- [ ] Явно описать: входной и выходной контракт этапа по state (какие блоки, типы), маппинг state ↔ порты пайплайнов на границе, условия выполнения (по имени роли или по списку блоков), чтобы мир и оркестраторы могли подключать этапы корректно.

---

## 11. Дополнительные требования

### 11.1 Устройство и опции

- [ ] **to(device):** перенос всех пайплайнов-узлов на устройство (pipeline.to(device)). Проброс device и kwargs в pipeline.run() при run(stage, ...).

### 11.2 Хуки и отладка

- [ ] Регистрация хуков перед/после выполнения каждого пайплайна-узла (stage_node_id, state_in, state_out). **Сухой прогон** run(..., dry_run=True) — порядок и наличие данных без вызова pipeline.run().

### 11.3 Производительность

- [ ] Кэширование топологического порядка; инвалидация при add_pipeline/add_edge/remove. Буфер без лишних копий по контракту.

---

## 12. Критерии приёмки уровня этапа (сводка)

- [ ] **Структура:** этап = пайплайны-узлы (stage_node_id → Pipeline), рёбра этапа (между внешними портами пайплайнов), контракт по state (input/output spec, маппинг state ↔ порты), роль, опционально execution_condition; индексы in/out.
- [ ] **Построение:** AddPipeline (пайплайн или конфиг), AddEdge, задание state contract и маппинга, set_execution_condition, роль; вырожденный случай — один пайплайн.
- [ ] **Валидация:** при AddEdge и полная validate(); DAG, достижимость, согласованность state contract и маппинга; опционально валидация пайплайнов.
- [ ] **Исполнитель:** топологическая сортировка, буфер, run(stage, state, action=..., training=..., **kwargs) → state; маппинг state ↔ входы/выходы пайплайнов; поддержка условия выполнения (пропуск этапа при невыполненном условии — на стороне мира или опционально в run).
- [ ] **Сериализация:** конфиг этапа (пайплайны, рёбра, state contract, роль, условие, версия); чекпоинт = агрегация чекпоинтов пайплайнов; save_config, save_checkpoint, save; load_config, load_from_checkpoint, load.
- [ ] **Загрузка из чекпоинта:** восстановление этапа из конфига + загрузка весов всех пайплайнов. Соответствие [SERIALIZATION_AT_ALL_LEVELS.md](SERIALIZATION_AT_ALL_LEVELS.md).
- [ ] **Обучение:** выбор trainable пайплайнов; trainable_parameters() этапа; сохранение/загрузка чекпоинта. Соответствие [TRAINABILITY_AT_ALL_LEVELS.md](TRAINABILITY_AT_ALL_LEVELS.md).
- [ ] **Конфиг и шаблоны:** from_config/from_yaml; from_template(name, **kwargs); ref на конфиги пайплайнов; валидация после загрузки.
- [ ] **Multi-endpoint:** endpoint_url по узлам; выполнение удалённых пайплайнов через API. Соответствие [MULTI_ENDPOINT_DEPLOYMENT.md](MULTI_ENDPOINT_DEPLOYMENT.md).
- [ ] **Связь с миром и Scheme:** контракт этапа по state для мира; условия выполнения по [Scheme.md](Scheme.md) (Философ, Автор, World update, Development, Архитектор, Творец); этап как узел мира. Соответствие [World_Level.md](World_Level.md), [Stage_Level.md](Stage_Level.md), [Scheme.md](Scheme.md).

После выполнения этого TODO уровень этапа реализован полностью и согласован с пайплайном (TODO_04), сериализацией, обучаемостью, multi-endpoint, Scheme и миром (World).
