# Уровень пайплайна: графы как узлы для комбинированных задач

Пайплайн — это **граф, узлами которого являются другие графы** («граф графов»; см. [Graph_Level.md](Graph_Level.md) про граф как одну задачу). Он нужен для **комбинированных задач**: цепочка (или ветвление) из нескольких **целых задач**, каждая — своим графом. Один граф = одна задача (text-to-image, upscale, image-to-video и т.д.); пайплайн соединяет такие графы. **Пайплайн может состоять и из одного графа** — тогда он задаёт единый интерфейс «вход/выход пайплайна» для одной задачи, что удобно на уровне этапа ([Stage_Level.md](Stage_Level.md)), где между этапами передаётся **state**: то, что течёт по пайплайну (данные между графами), на уровне этапов и мира становится частью state.

Ниже: [Graph_Level.md](Graph_Level.md). Выше: [Stage_Level.md](Stage_Level.md), World — [System.md](System.md).

---

## 1. Положение пайплайна в иерархии

| Уровень | Состоит из | Описание |
|---------|------------|----------|
| **Граф** ([Graph_Level.md](Graph_Level.md)) | Узлов-задач (Backbone, Solver, Codec, Conditioner, Tokenizer, …) | **Одна цельная задача**. Граф собирается через Graph.AddNode(...). Между узлами текут данные (порты). |
| **Пайплайн** | **Целых графов (один или несколько)** | **Граф, узлами которого являются графы.** Пайплайн **может состоять из одного графа** (вырожденный случай: одна «вершина»). Между графами текут данные; на уровне этапа это часть **state**. |
| **Выше** | **Этап (Stage)** ([Stage_Level.md](Stage_Level.md)) | Граф пайплайнов; между этапами передаётся state. **Мир (World)** ([World_Level.md](World_Level.md)) — граф этапов. |

Итого: **граф** = одна задача; **пайплайн** = граф графов (в т.ч. из одного графа); по пайплайну текут данные между графами — на уровне этапа и мира это и есть то, что входит в **state**.

---

## 2. Определение пайплайна

**Пайплайн (Pipeline)** — это **граф, у которого узлами являются целые графы** (см. [Graph_Level.md](Graph_Level.md)). Создаётся для **комбинированных задач**, когда цель складывается из нескольких шагов (каждый — граф одной задачи). **Пайплайн может состоять из одного графа** — тогда он по сути оборачивает одну задачу в интерфейс пайплайна (один узел, вход/выход пайплайна = вход/выход этого графа).

- **Узлы пайплайна** — целые графы (каждый граф = одна задача: text-to-image, upscale, image-to-video и т.д.); узлов может быть один или несколько.
- **Рёбра пайплайна** — связи между выходами одного графа и входами другого (или с внешним входом/выходом пайплайна). При одном графе рёбер нет (или только внешние вход/выход).
- **Выполнение пайплайна** — по топологии выполняются графы; данные передаются между графами по рёбрам. То, что течёт по пайплайну, на уровне этапа ([Stage_Level.md](Stage_Level.md)) входит в **state**, передаваемый между этапами.

С точки зрения пайплайна каждый граф — «чёрный ящик» с входами и выходами задачи; внутреннее устройство графа (Backbone, Solver, Codec и т.д.) пайплайну не важно.

---

## 3. Граф как целая единица: одна задача, свои входы и выходы

Каждый граф в пайплайне представляет **одну законченную задачу** и имеет **внешние входы и выходы** этой задачи.

### 3.1 Граф-порты (внешний интерфейс графа)

- **Входы графа** — то, что нужно задать для задачи (например, текст для text-to-image, изображение для upscale или image-to-video). Объявляются как внешние порты графа и привязаны к портам внутренних узлов.
- **Выходы графа** — результат задачи (изображение, видео, аудио, латенты и т.д.). Объявляются как внешние порты графа.

Граф в роли узла пайплайна **объявляет контракт задачи**: имена и типы входов/выходов. Пайплайн соединяет выход одного графа с входом другого по этим портам.

### 3.2 Примеры графов как единиц (одна задача = один граф)

- **Граф «text-to-image»:** вход `text`, выход `image`. Внутри — полная реализация: Tokenizer, Conditioner, Backbone, Solver, Codec (decode) и т.д., собранные в один граф. Для пайплайна важен только контракт: текст → изображение.
- **Граф «upscale»:** вход `image` (низкое разрешение), выход `image` (высокое разрешение). Одна задача — апскейл.
- **Граф «image-to-video»:** вход `image`, выход `video`. Одна задача — изображение в видео.
- **Граф «outpainting»**, **«image-to-image»** и т.д. — каждая такая задача реализуется **одним графом**.

Пайплайн **не** разбивает одну задачу на «граф текстового условия», «граф диффузии», «граф декодирования»: эти части принадлежат **внутри** одного графа (например, text-to-image). В пайплайне же соединяются **графы разных задач** (например, text-to-image → upscale → image-to-video).

---

## 4. Состав пайплайна: графы и рёбра между ними

### 4.1 Узлы пайплайна = графы (каждый граф — одна задача)

- Каждый **узел пайплайна** — это **целый граф** одной задачи (см. [Graph_Level.md](Graph_Level.md)). Узлов может быть **один или несколько**; пайплайн из одного графа допустим и удобен, когда этап ([Stage_Level.md](Stage_Level.md)) вызывает одну задачу через единый интерфейс пайплайна.
- У каждого графа в пайплайне есть идентификатор (например, `graph_id` или имя: `text2img`, `upscale`, `img2video`), чтобы соединять его выходы с входами других графов (или с внешним выходом пайплайна).

### 4.2 Рёбра пайплайна

- **Ребро пайплайна** соединяет **выход одного графа** с **входом другого графа** (или с внешним входом/выходом пайплайна).
- Типы и семантика должны совпадать: то, что один граф выдаёт по данному порту, подходит как вход другому графу по указанному порту (тензор, словарь, поток и т.д.).

Таким образом, пайплайн — это **граф над графами**: вершины — целые графы, рёбра — потоки данных между внешними входами/выходами этих графов.

### 4.3 Внешние входы и выходы пайплайна

- У пайплайна как целого могут быть **внешние входы** (то, что подаётся извне: например, промпт, начальное изображение, конфиг) и **внешние выходы** (то, что пайплайн отдаёт наружу: например, итоговое изображение, латенты, эмбеддинги).
- Они отображаются на входы/выходы **первого/последнего** или указанных графов в пайплайне согласно рёбрам.

---

## 5. Выполнение пайплайна

### 5.1 Семантика выполнения

- **Выполнить пайплайн** значит: в порядке, заданном топологией (или явным порядком шагов), выполнять **целые графы**, передавая данные по рёбрам пайплайна.
- На каждом шаге выполняется **один граф целиком**: все его внутренние узлы выполняются (последовательно или по внутренней топологии графа), пока не будут готовы внешние выходы этого графа. Затем результаты по рёбрам пайплайна подаются на входы следующих графов (или во внешний выход).

### 5.2 Порядок выполнения

- **Линейный пайплайн:** граф 1 → граф 2 → … → граф N. Выполняются по очереди; выход предыдущего — вход следующего.
- **Разветвление:** один граф может подавать выходы нескольким графам; несколько графов могут подавать выходы одному графу (если контракт входа это допускает, например конкатенация условий).
- **Условность и циклы:** при расширении можно ввести условное выполнение графов или итерации (например, один граф задачи с внутренним циклом солвера vs. несколько вызовов графа на уровне пайплайна; выбор фиксируется в конфиге/схеме).

Для базового описания достаточно **топологического порядка**: пайплайн выполняется так, что перед выполнением графа все его входящие рёбра уже заполнены результатами предыдущих графов.

### 5.3 Передача данных между графами

- Данные между графами передаются **в памяти** (или через явный буфер/очередь): выходной тензор (или структура данных) одного графа становится входом следующего. Сериализация на границе графов не обязательна, если пайплайн выполняется в одном процессе.
- Формат данных на рёбрах пайплайна задаётся контрактом внешних портов графов (тип, форма, семантика).

---

## 6. Идентичность и конфигурация пайплайна

### 6.1 Идентификация

- Пайплайн идентифицируется именем или `pipeline_id` в контексте мира (или реестра пайплайнов).
- В конфиге пайплайна задаются: список графов (каждый со своим конфигом графа — узлы, рёбра, привязка внешних портов), рёбра пайплайна (какой выход какого графа куда подключается), опционально порядок выполнения или сценарий.

### 6.2 Сериализация

- **Конфиг пайплайна** сохраняет: какие графы входят в пайплайн (ссылки на конфиги графов или вложенные конфиги), как соединены их внешние порты (рёбра пайплайна), внешние входы/выходы самого пайплайна.
- **Чекпоинт пайплайна** — это совокупность чекпоинтов всех входящих в него графов (состояния узлов-задач внутри каждого графа). Пайплайн как таковой не имеет своего отдельного state_dict — состояние распределено по графам.

---

## 7. Сводная таблица: граф и пайплайн

| Аспект | Граф | Пайплайн |
|--------|------|----------|
| **Смысл** | **Одна цельная задача** (text-to-image, upscale, image-to-video, outpainting, image-to-image, распознавание и т.д.). Может быть диффузионной или не-диффузионной. | **Комбинированная задача**: цепочка (или ветвление) из нескольких задач. Граф, узлами которого являются другие графы. |
| **Состоит из** | Узлов-задач (Backbone, Solver, Codec, Conditioner, Tokenizer, Guidance, …); сборка через Graph.AddNode(...). | **Целых графов** (каждый граф = одна задача). |
| **Узлы** | Экземпляры узлов-задач; узлы «знают» свою роль и типичные связи. | Целые графы (каждый — полная реализация одной задачи). |
| **Рёбра** | Связи портов между узлами-задачами. | Связи выходов одного графа с входами другого. |
| **Исполнение** | Один граф = выполнение одной задачи (вход задачи → выход задачи). | Поочерёдное выполнение графов; данные между графами по рёбрам пайплайна. |

---

## 8. Примеры пайплайнов (комбинированные задачи)

Каждый узел пайплайна — **граф одной цельной задачи**. Пайплайн соединяет такие графы, чтобы получить сложный сценарий.

- **Видео из текста:** пайплайн из **трёх графов**. Узел 1 — граф **text-to-image** (текст → изображение). Узел 2 — граф **upscale** (изображение → изображение высокого разрешения). Узел 3 — граф **image-to-video** (изображение → видео). Рёбра: выход графа 1 → вход графа 2; выход графа 2 → вход графа 3. Итог пайплайна: текст → видео (через промежуточные изображения).
- **Аутпейнтинг → апскейл → image-to-image → image-to-video:** пайплайн из **четырёх графов**. Каждый граф — одна задача (outpainting, upscale, image-to-image, image-to-video). Пайплайн даёт пользователю возможность собирать такие **комбинированные диффузионные (и смешанные) сценарии** из готовых графов отдельных задач.
- **Общий принцип:** на уровне **графа** выполняются **простые задачи** (одна цель = один граф). На уровне **пайплайна** пользователь комбинирует **графы этих задач**, получая сложные цепочки (текст → картинка → апскейл → видео и т.д.).

---

## 9. Связь с другими уровнями

- **Граф** ([Graph_Level.md](Graph_Level.md)) — одна задача; между узлами текут данные. **Пайплайн** — граф графов (может из одного графа). **Этап (Stage)** ([Stage_Level.md](Stage_Level.md)) — граф пайплайнов. **Мир (World)** ([World_Level.md](World_Level.md)) — **граф этапов**; по рёбрам передаётся state.

Детали сериализации мира (в т.ч. графы и пайплайны в конфиге): [World_Serialization.md](World_Serialization.md).
