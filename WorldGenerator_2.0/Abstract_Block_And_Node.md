# Abstract Base Block и Abstract Graph Node: полное техническое описание

Всё, что можно задать о двух фундаментальных сущностях системы: определения, контракты, содержимое, правила, преобразование, примеры и замечания для реализации. Связь с философией: [Philosophy.md](Philosophy.md). Краткое место в системе: [System.md](System.md).

---

## 1. Роль двух сущностей

| Сущность | Начало | Роль в системе |
|----------|--------|-----------------|
| **Abstract Base Block** | Материальное | То, что **хранит** (параметры, тензоры, состояние) и **выполняется** (принимает данные по входам, выдаёт по выходам). Атом сборки. |
| **Abstract Graph Node** | Идеальное | То, что задаёт **место** в графе и **связи** с другими узлами (рёбра). Не хранит данные — задаёт, как блок встроен в целое. |

**Правило:** любой Abstract Base Block может быть **помещён в узел графа** (преобразование «блок → узел»). После этого блок остаётся блоком; узел задаёт его положение и соединения. Система = граф, узлы которого содержат блоки; рёбра задают потоки данных между портами блоков.

---

## 2. Abstract Base Block (абстрактный базовый блок)

### 2.1 Определение

**Abstract Base Block** — минимальная единица системы, которая:
1. **что-то хранит** (материальное содержание);
2. **что-то вычисляет** (выполнение по входам → выходы).

Любой объект в проекте (модель, кодек, солвер, кондиционер, пайплайн и т.д.) может быть представлен как базовый блок или обёрнут в него. На фундаментальном уровне **вся материя системы** воплощена в блоках: параметры, тензоры, данные, состояние — всё живёт внутри блоков.

### 2.2 Что блок хранит (материальное содержание)

Блок — **носитель**. Он хранит всё перечисленное ниже; без блока нет материального воплощения сущности в пайплайне.

| Категория | Содержимое | Назначение |
|-----------|------------|------------|
| **Параметры и конфигурация** | Конфиг (YAML, словарь, JSON), гиперпараметры, флаги. Идентификаторы: `block_id`, `block_type`. Всё, что задаёт «кто этот блок» и «с какими настройками работает». | Идентичность и настройки; воспроизводимость запуска. |
| **Тензоры и веса** | Обучаемые веса (например, веса нейросети), кэш, промежуточные буферы. Всё, что занимает память и участвует в вычислениях (в т.ч. в диффузионных и языковых моделях). | Выполнение; обучение; инференс. |
| **Ссылки** | Указатели на другие блоки, на ресурсы (файлы, URI), на граф (если блок уже помещён в граф). Связи «указатель на что-то» считаются материальной частью блока. | Композиция; доступ к внешним ресурсам; навигация по графу. |
| **Состояние** | Всё, что нужно для воспроизводимости, сохранения и загрузки: `state_dict`, снимок конфига при сохранении, опционально версия и метаданные. | Сохранение/загрузка чекпоинтов; воспроизводимость. |

Итого: блок = **хранилище** (параметры, тензоры, ссылки, состояние) + **исполняемая единица** (см. контракт ниже).

### 2.3 Контракт блока (интерфейс и поведение)

Блок участвует в системе через **три аспекта контракта**.

#### 2.3.1 Объявление интерфейса (порты)

- Блок **объявляет** входы и выходы — **порты** (ports).
- У каждого порта: **имя** (уникальное внутри блока), **тип** или схема данных (тензор, словарь, конфиг, поток и т.д.), **опциональность** (обязательный / опциональный).
- Это описание «что блок принимает и отдаёт» **без привязки к конкретному графу**. Блок не знает, откуда придут данные и куда уйдут — только типы и имена портов.
- **Входные порты:** по ним блок получает данные при выполнении. Имена и типы задают контракт входа.
- **Выходные порты:** по ним блок отдаёт результаты. Имена и типы задают контракт выхода.
- Совместимость при соединении узлов в графе проверяется по типам портов (и при необходимости по семантике).

#### 2.3.2 Выполнение (execution)

- Блок **выполняется**: по входным данным (по значениям на входных портах) выдаёт выходные (значения на выходных портах).
- Выполнение — **материальный акт**: вычисления, обращение к тензорам и весам, чтение/запись состояния. Время выполнения и ресурсы (память, GPU/CPU) связаны с блоком.
- Сигнатура выполнения (псевдо): `outputs = block.forward(inputs)` или `block.run(inputs) -> outputs`, где `inputs` и `outputs` — словари по именам портов (или эквивалент).
- Опционально: блок может иметь фазы (например, `train` / `eval`), тогда контракт может различаться по фазам.

#### 2.3.3 Идентификация

- Блок **идентифицируется** так, чтобы граф и другие блоки могли ссылаться на него и различать блоки между собой.
- **block_type** — тип блока (например, строка или enum: `"backbone"`, `"solver"`, `"codec"`). Определяет класс/реализацию.
- **block_id** — уникальный в рамках графа (или в рамках области видимости) идентификатор экземпляра. Позволяет обращаться к конкретному блоку по имени при построении рёбер и при выполнении.

Итого по контракту: блок = **объявление портов** + **выполнение (forward/run)** + **идентичность (block_type, block_id)**.

### 2.4 Порты: детализация

| Аспект | Описание |
|--------|----------|
| **Имена портов** | Строки (или стабильные идентификаторы). Уникальны внутри блока. Используются в рёбрах графа: ребро связывает (узел_A, порт_A) с (узел_B, порт_B). |
| **Типы портов** | Тензор, словарь, конфиг, поток байтов, ссылка на артефакт и т.д. Тип задаёт, что можно передавать по ребру; при валидации графа проверяется совместимость типов источника и приёмника. |
| **Опциональность** | Входной порт может быть обязательным или опциональным. Если опциональный — блок должен корректно работать при отсутствии значения (например, значение по умолчанию или пропуск шага). |
| **Множественность** | Один входной порт может получать данные по нескольким рёбрам (тогда нужна политика агрегации: конкатенация, сумма, выбор одного и т.д.); один выходной порт может быть источником для нескольких рёбер (раздача одного значения). Спецификация зависит от реализации. |

### 2.5 Жизненный цикл блока (по шагам)

1. **Создание** — инстанцирование по конфигу (тип блока, параметры). Блок получает `block_id` (если не задан — генерируется).
2. **Размещение в графе** — блок помещается в узел (преобразование блок → узел). Узел получает имя; рёбра задают связи портов блока с портами других узлов.
3. **Выполнение** — исполнитель графа передаёт на входные порты блока данные (согласно входящим рёбрам); вызывает выполнение блока; забирает данные с выходных портов и передаёт по исходящим рёбрам.
4. **Сохранение/загрузка** — состояние блока (state_dict, конфиг) сериализуется для чекпоинта; при загрузке блок восстанавливается из чекпоинта.

### 2.6 Композиция: блоки из блоков

- Блок может **внутри себя** содержать другие блоки (подблоки). Тогда он сам является композицией: его выполнение сводится к вызову подблоков и передаче данных между ними (внутренний подграф или фиксированный пайплайн).
- Снаружи такой блок по-прежнему соблюдает контракт Abstract Base Block: порты, выполнение, идентичность. Вся материя внутри него — снова блоки.

### 2.7 Примеры блоков (по типу)

| block_type (пример) | Что хранит | Порты (типично) | Выполнение |
|--------------------|------------|------------------|------------|
| **Backbone** | Веса модели (UNet, трансформер и т.д.), конфиг архитектуры. | Вход: латенты, таймстеп, кондиционирование. Выход: предсказание (шум, x0 и т.д.). | Один шаг предсказания модели. |
| **Solver** | Параметры схемы (DDIM, Euler и т.д.), возможно ссылки на backbone. | Вход: латенты, таймстеп, предсказание. Выход: обновлённые латенты. | Один шаг солвера (дискретизация). |
| **Codec** | Веса энкодера/декодера (VAE и т.д.). | Вход: пиксели или латенты. Выход: латенты или пиксели. | Encode или decode. |
| **Conditioner** | Веса энкодера текста/изображения, конфиг. | Вход: текст, изображение и т.д. Выход: эмбеддинги/условие. | Кондиционирование для backbone. |
| **Adapter** | Веса адаптера (LoRA, инжектор и т.д.). | Вход: активации, условие. Выход: модифицированные активации. | Адаптация выхода/входа другого блока. |

### 2.8 Замечания для реализации

- **Базовый класс:** Abstract Base Block задаёт абстрактный класс (интерфейс): методы объявления портов, `forward`/`run`, получение/установка состояния, `block_type` и `block_id`. Конкретные блоки наследуются и заполняют хранилище и логику выполнения.
- **Реестр типов:** удобно иметь реестр (registry) типов блоков: по строке `block_type` создаётся экземпляр нужного класса (фабрика или регистрация классов).
- **Сериализация:** контракт сохранения — выгрузка state_dict и конфига; загрузка — восстановление из них. Порты и имена портов при сериализации графа хранятся на уровне узлов и рёбер, а не только внутри блока.

---

## 3. Abstract Graph Node (абстрактный узел графа)

### 3.1 Определение

**Abstract Graph Node** — это **место** или **роль** в графе, которому может соответствовать **любой** Abstract Base Block. Узел **не хранит** материю сам по себе: он задаёт **положение** в графе и **связи** (рёбра) с другими узлами. То, что помещено в узел, — всегда блок (материя); узел — **идеальная форма**, в которую блок помещается.

### 3.2 Что задаёт узел (идеальное содержание)

| Аспект | Описание |
|--------|----------|
| **Положение в графе** | **Имя узла** — уникальный в рамках графа идентификатор (строка или стабильный ID). Узел отвечает на вопрос «где в графе эта сущность» — не «что там лежит», а «какое место она занимает». По имени узла исполнитель обращается к блоку и к входящим/исходящим рёбрам. |
| **Связи с другими узлами (рёбра)** | **Входящие рёбра:** (источник_узел, источник_порт) → (этот_узел, входной_порт). **Исходящие рёбра:** (этот_узел, выходной_порт) → (приёмник_узел, приёмник_порт). Рёбра задают **порядок** и **направление** потоков данных — идея композиции. Данные по рёбрам передаются при выполнении графа. |
| **Семантика портов на уровне графа** | Какие порты блока «торчат наружу» и к чему они подключаются: какой входной порт узла является входом графа, какой выходной — выходом графа; какие порты соединены с какими узлами. Узел не подменяет порты блока — он задаёт **отображение** портов блока на рёбра графа. |

Узел, таким образом, не дублирует блок: он задаёт **как блок встроен в целое**. Целое — граф; идея целого — связи и порядок.

### 3.3 Рёбра (edges): формат и семантика

- **Ребро** — направленная связь от одного порта к другому. Формат: `(source_node_id, source_port_name) → (target_node_id, target_port_name)`.
- Тип данных на ребре должен совпадать с типом выходного порта источника и типом входного порта приёмника (или быть совместимым по правилам системы).
- Один выходной порт может быть источником **нескольких** рёбер (одно значение раздаётся в несколько узлов). Один входной порт может быть приёмником **одного** или **нескольких** рёбер (в последнем случае нужна политика агрегации на уровне узла/блока).
- **Порядок выполнения** графа определяется топологией: топологическая сортировка по направлению рёбер (от входов графа к выходам). При циклах нужна итеративная или фиксированная схема (например, фиксированное число итераций цикла).

### 3.4 Любой блок может стать узлом

- Abstract Graph Node **не привязан** к одному конкретному типу блока. **Любой** Abstract Base Block может быть помещён в узел графа.
- Один и тот же **класс** блоков может использоваться в **разных графах** и в **разных узлах** одного графа; узел задаёт не тип блока, а **роль в данном графе** (место и связи).
- **Преобразование «блок → узел»:** взять экземпляр блока, назначить ему имя узла и набор рёбер (какие порты с чем соединены). После этого при выполнении графа исполнитель обращается к узлам по имени, передаёт данные по рёбрам; содержимое узла — по-прежнему блок, который вызывается на выполнение при подаче данных на его входные порты.

### 3.5 Входы и выходы графа

- **Вход графа** — входной порт какого-то узла, помеченный как «внешний вход» (или не имеющий входящих рёбер от других узлов и подаваемый извне). Аналогично **выход графа** — выходной порт узла, помеченный как «внешний выход» (или конец цепочки, значение которого отдаётся наружу).
- Узел задаёт участие портов блока в этих входах/выходах графа: какой порт блока подключён к внешнему входу/выходу.

### 3.6 Жизненный цикл узла

1. **Создание узла** — задаётся имя узла (уникальное в графе).
2. **Размещение блока** — в узел помещается блок (экземпляр Abstract Base Block). Узел хранит ссылку на блок; данные хранит блок, не узел.
3. **Задание рёбер** — для узла задаются входящие и исходящие рёбра (связи портов этого узла с портами других узлов).
4. **Выполнение графа** — исполнитель обходит узлы (например, в топологическом порядке), для каждого узла собирает входные данные по входящим рёбрам, вызывает блок узла, раздаёт выходные данные по исходящим рёбрам.

### 3.7 Замечания для реализации

- **Структура графа:** граф можно хранить как список (или словарь) узлов + список рёбер. Узел = (node_id, block_ref, опционально метаданные). Ребро = (source_node, source_port, target_node, target_port).
- **Валидация:** при построении графа проверять совместимость типов портов на концах рёбер; проверять, что все обязательные входные порты узлов имеют ровно одно входящее ребро (или заданную политику).
- **Исполнитель:** компонент, который по графу и внешним входам выполняет топологическую сортировку, по очереди вызывает блоки узлов, передаёт данные по рёбрам (буферы или передача по значению/ссылке).

---

## 4. Преобразование «блок → узел» и единство уровня

### 4.1 Правило

**Любой Abstract Base Block может быть превращён в узел графа:** помещён в граф как узел с именем и набором рёбер. Материя (блок) получает идеальную форму (место и связи), не переставая быть блоком.

### 4.2 Процесс

1. Иметь экземпляр блока (с заданными `block_type`, `block_id`, портами, состоянием).
2. Создать узел с уникальным именем в графе.
3. Поместить блок в узел (узел хранит ссылку на блок).
4. Задать входящие рёбра: от каких (узел, порт) приходят данные на какие входные порты блока.
5. Задать исходящие рёбра: с каких выходных портов блока данные уходят в какие (узел, порт).

После этого блок выступает как узел при выполнении графа: его порты участвуют в рёбрах; выполнение блока вызывается исполнителем при подаче данных на его входы.

### 4.3 Система как целое

- **Граф** = множество узлов (каждый узел содержит ровно один блок) + множество рёбер (связи портов).
- **Потоки данных** — по рёбрам; **вычисления** — в блоках внутри узлов.
- Содержимое узлов — **материя** (блоки); структура графа (узлы, рёбра, порядок) — **идея**. Оба уровня необходимы и работают только вместе.

---

## 5. Сводные таблицы

### 5.1 Abstract Base Block

| Аспект | Содержимое |
|--------|------------|
| **Определение** | Минимальная единица: хранит + вычисляет. Вся материя системы — в блоках. |
| **Хранит** | Параметры, конфиг; тензоры, веса; ссылки; состояние для save/load. |
| **Контракт** | Порты (входы/выходы: имена, типы, опциональность); выполнение (forward/run); идентичность (block_type, block_id). |
| **Жизненный цикл** | Создание → размещение в узле → выполнение (по вызову) → сохранение/загрузка. |
| **Композиция** | Блок может содержать подблоки; снаружи соблюдает тот же контракт. |

### 5.2 Abstract Graph Node

| Аспект | Содержимое |
|--------|------------|
| **Определение** | Место/роль в графе; не хранит данные — задаёт положение и связи. В узле всегда блок. |
| **Задаёт** | Имя узла (уникальное); входящие и исходящие рёбра (связи портов); участие портов во входах/выходах графа. |
| **Рёбра** | (source_node, source_port) → (target_node, target_port); тип данных совместим с портами. |
| **Блок → узел** | Любой блок можно поместить в узел, задать имя и рёбра; узел = форма, блок = содержимое. |
| **Жизненный цикл** | Создание узла → размещение блока → задание рёбер → участие в выполнении графа. |

### 5.3 Вместе

| Вопрос | Ответ |
|--------|--------|
| Кто хранит параметры и тензоры? | Блок. |
| Кто задаёт, куда идут данные? | Узел (рёбра). |
| Кто выполняется? | Блок (при вызове исполнителем графа). |
| Кто задаёт порядок выполнения? | Граф (топология по рёбрам). |
| Можно ли один блок использовать в разных узлах? | Да. Один класс блоков — много экземпляров в разных узлах с разными связями. |

---

## 6. Связь с другими документами

- [Philosophy.md](Philosophy.md) — философская трактовка материи/идеи, блок/узел, аналогия с фермионами/бозонами.
- [System.md](System.md) — место блока и узла в системе «с основания до мира».
- [Abstract_Task_Nodes.md](Abstract_Task_Nodes.md) — уровень над фундаментом: Backbone, Solver, Codec, Adapter, Conditioner, Guidance (узлы-задачи, двойное наследование Block+Node).
- [Scheme.md](Scheme.md) — операционная схема мира (цикл, state); узлы мира (Философ, Автор, Среда, Архитектор, Творец) в реализации являются узлами графа с блоками внутри.
