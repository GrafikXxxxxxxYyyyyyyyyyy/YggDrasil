# Философия проекта Yggdrasil (Universe Generator 3.0)

**Назначение документа:** единый философский ориентир всей системы — от основания до высших представлений. Здесь собрана полная, глобальная и всеобъемлющая философская мысль проекта Yggdrasil: *зачем*, *почему*, *как* и *что именно* лежит в основе каждого уровня, каждой сущности и каждого взаимодействия.

**Архитектурный канон:** папка `../WorldGenerator_2.0/` — референс архитектуры; данный документ извлекает и систематизирует философию, заложенную в каноне, в единый связный текст.

**Язык:** русский.

**Движок Yggdrasil 0.3.0:** система работает не с графом, а с **гиперграфом**. Движок Yggdrasil версии 0.3.0 — это **гиперграф**; на каждом уровне иерархии структура представлена и исполняется как гиперграф (обычный граф — частный случай при гиперрёбрах размера 2).

---

## Часть I. Зачем и что: цель, имя, природа проекта

### 1.1 Зачем существует проект

Проект существует ради **максимальной свободы создания** при **единой и ясной основе**. Разработчики и пользователи должны иметь возможность собирать системы любой сложности — от одного блока до вселенной миров — не изобретая каждый раз новую онтологию: всё опирается на одни и те же фундаментальные сущности и принципы. Система является одновременно **конструктором** (всё собирается из блоков) и **средой с идеей** (связи и композиция подчиняются единой философии и правилам преобразования). Таким образом, Yggdrasil — не только Lego-конструктор, но и **многомерный гиперграф**, в котором на каждом уровне сущности одновременно материальны и идеальны; их природа проявляется **во взаимодействии идеи с материей и материи с идеей**. Проект нацелен на **предельную гибкость и масштабируемость решений**: на каждом шаге, на каждой стадии, на каждом уровне — от обучения моделей до сборки сценариев — должна быть возможность **полной и глубокой настройки** без искусственных ограничений.

### 1.2 Универсальность абстракции: от конкретных решений к устройству любой сложной системы

Yggdrasil **выходит за рамки конкретных решений** и поднимается до уровня **абстракции целой вселенной**. Одна и та же философская позиция призвана описывать **устройство любой сложной системы** — вплоть до **модели вселенной**: один фундамент (блок, узел, гиперграф, синтез материи и идеи), одна иерархия уровней (граф → пайплайн → переход → мир → вселенная), одни принципы превращений и связей. Не «ещё один фреймворк под задачу X», а **единая онтология**, в которой и одна задача (text-to-image), и цепочка миров, и сообщество вселенных суть частные случаи одной и той же структуры. Тем самым проект претендует не на узкую область применимости, а на **универсальность описания**: от минимального исполняемого графа до модели вселенной — одна мысль, одна форма, одна философия.

### 1.3 Три столпа: простота запуска, всеобщая сериализация, абсолютная свобода настройки

Проект сочетает три нераздельных требования.

**Максимальная простота использования.** Буквально **всё** должно быть запускаемо за **минимум кода** — в идеале за **три–пять строк**: создание графа, пайплайна, этапа или мира с полной **автоматизацией согласования** (порты, типы, связи выводятся из спецификаций) и с **простотой**, не требующей от пользователя погружения во внутреннее устройство, если он того не хочет. Один и тот же сценарий — от одной задачи до целого мира — должен собираться и запускаться с минимальным boilerplate.

**Всеобъемлющая сериализация.** На каждом уровне — конфиг структуры и чекпоинт весов; возможность сохранить и загрузить блок, граф, пайплайн, этап, мир, вселенную. Сериализация **объединяет** огромную мощь и многофункциональность решения: сложнейшие конфигурации и обученные модели становятся воспроизводимыми артефактами, переносимыми между средами и сценариями. Ничто не «теряется» между запусками: всё, что можно описать и обучить, можно сериализовать.

**Абсолютная свобода настройки.** При этом система должна поддерживать **абсолютно произвольную** кастомизацию. **Любая** нейросетевая архитектура, **любая** ненейросетевая архитектура; **любые** задачи и **любые** комбинированные сценарии; **любые** переходы состояний; **любые** самые смелые фантазии по устройству мира; **любое** взаимодействие в сообществе пользователей и миров. Никаких «разрешённых» и «запрещённых» вариантов — только контракт (порты, run, сериализация) и совместимость типов. Противоречие между «запуск в три строки» и «абсолютная свобода» снимается единой основой: простой путь — это разумные умолчания и автоматическое согласование; сложный путь — явная сборка из тех же блоков и тех же правил. Один фундамент обслуживает и быстрый старт, и предельную кастомизацию.

### 1.4 Minecraft в мире программирования — но больше

В духе этой двойной цели проект можно охарактеризовать так: **Yggdrasil стремится быть «Minecraft в мире программирования» — но больше**. Как Minecraft даёт конечный набор правил и блоков, из которых игрок может собрать что угодно — от хижины до логической схемы и целого мира, — так и Yggdrasil даёт конечный набор абстракций (блок, узел, гиперграф, уровни иерархии), из которых можно собрать **что угодно**: одну модель, пайплайн, интерактивный мир, вселенную миров, сообщество с обменом и влиянием. «Больше» — потому что система не ограничена игровым миром: она поднимается до уровня **модели вселенной** и **универсальной философской позиции** об устройстве сложных систем; сериализация, обучение на всех уровнях и единый контракт делают собранное не только «поиграть», но и **сохранить, обучить, масштабировать и комбинировать** в любых сценариях.

### 1.5 Песок в бесконечной пустыне: единственное ограничение — фантазия

Фреймворк предлагает пользователю и разработчику **песок в бесконечной пустыне**. В этой пустыне пользователь или разработчик **свободен создавать любые формы, образы, фигуры** — от простой «курицы» до целых песчаных городов; всё, на что хватает фантазии. **Единственное ограничение — сама фантазия.** Фреймворк не предписывает «допустимые» сценарии: он даёт **мощный движок** для воплощения **любых идей и фантазий** разработчиков и пользователей. Задача системы — не сужать выбор, а предоставить **все возможности** в рамках одной основы: один контракт, одна философская мысль, одна структура (гиперграф, блок, узел), из которых собирается бесконечное разнообразие. Так и должно быть: фреймворк — это не набор готовых решений, а **среда полной свободы реализации** при неизменной основе.

### 1.6 Полная кастомизируемость без изменений движка

**Полная кастомизируемость** означает, что пользователь может **придумать любую модель**, **любую задачу**, **любую цепочку задач**; может **менять последовательность переходов** и **сами переходы**; может **менять взаимодействие между мирами**. Полная свобода реализации — при этом **без каких-либо изменений в движке фреймворка**, в его основе, сути и философской мысли. Инструменты фреймворка (реестр типов блоков, контракт портов и run, возможность регистрировать свои узлы-задачи, свои переходы, свои правила обмена между мирами) должны **давать возможность кастомной реализации всего** — любой модели, любого сценария, любой логики переходов и любого взаимодействия миров — **исключительно через реализацию контракта и регистрацию**, без правок ядра, без структурных инъекций в движок, без «манипуляций» с фреймворком. Никаких хаков, никакого форка движка ради новой идеи: **фреймворк изначально предоставляет все возможности**. Если пользователю нужно что-то новое — он реализует блок или переход по тому же контракту и добавляет его в реестр; основа и философия остаются нетронутыми. Движок остаётся **неизменным**; меняется только множество зарегистрированных реализаций и собранные из них конфигурации. В этом смысл «песочницы» и «Minecraft»: мощный двигатель уже заложен в основу; пользователь творит **внутри** данной ему пустыни песка, не пытаясь перестроить сам песок.

### 1.7 Что такое «мир» в проекте

**Мир** в проекте — это не метафора интерфейса, а **непрерывная цепь крупномасштабных переходов**: последовательность фаз (Философ → Автор → Среда → Архитектор → Творец), в каждой из которых состояние системы претерпевает **метаморфозу** — фундаментальное превращение (материя в идею, идея в материю, объект в объект). Мир один; он обновляется применением состояния (state), а новое состояние порождается внутри цикла (Development of the world). Мир может развиваться **сам**, итеративно, без обязательного участия пользователя. Выше мира в расширении стоит **Вселенная** — гиперграф миров, предназначенный в первую очередь для **сообщества**: сравнение миров, развитие через взаимодействие персонажей и миров, обмен, группы миров, творческое и деструктивное влияние на экосистему.

### 1.8 Почему имя Yggdrasil

В скандинавской мифологии **Иггдрасиль** — мировое древо, соединяющее и поддерживающее **несколько миров (реальмов)**. В проекте уровень **Вселенная** — это гиперграф миров: узлы = миры, гиперрёбра = связи между мирами; счёт миров (count of worlds) — число «реальмов» на древе. Один мир — один цикл переходов (один «реальм»); вселенная — целое древо таких миров. Корни и ветви мифа соответствуют рёбрам графа; колодец Урд — общему контексту или хранилищу; обмен между мирами — движению сущностей по рёбрам. Имя закрепляет не только техническую структуру, но и **философскую**: система есть древо, на котором растут миры и связи между ними.

---

## Часть II. Два начала: материальное и идеальное

### 2.1 Разделение двух начал

Вся система держится на двух взаимосвязанных началах:

| Начало | Сущность в проекте | Смысл |
|--------|--------------------|--------|
| **Материальное** | То, что **хранит** и **несёт**: параметры, тензоры, ссылки, данные, веса, конфигурацию, состояние. Всё, что можно назвать «носителем». | Материя — то, из чего собирается система и что передаётся по цепочкам. |
| **Идеальное** | То, что задаёт **связи**, **порядок** и **логику превращения** материальных сущностей в элементы целого. Упорядочивание блоков в граф, правила соединения, семантика узлов и рёбер. | Идея — форма, в которую складывается материя; логика преобразования блока в узел графа. |

Без материи нечего выполнять; без идеи нет структуры и связей. Оба начала необходимы и работают только вместе.

### 2.2 Воплощение в фундаменте

- **Материальное** воплощается в **блоке** (Lego-кирпиче): нечто, что можно положить в граф и соединить с другим; оно хранит и вычисляет.
- **Идеальное** воплощается в **узле графа** и в **логике превращения**: любой блок может стать узлом; сама эта возможность и правила превращения и есть идеальная составляющая.

Вся архитектура замкнута на этом разделении: с одной стороны — единый материальный «атом» (базовый блок), с другой — единая идеальная «форма» (узел гиперграфа и правило: блок → узел).

### 2.3 Гегелевская аналогия: тезис, антитезис, синтез

Описание двух начал и пары Abstract Base Block / Abstract Graph Node можно упорядочить по аналогии с **философией Гегеля** и понятием **синтеза**.

- **Тезис (положительный момент):** **Abstract Base Block** — материальное начало. Блок есть «положительное» в смысле наличного бытия: то, что *есть*, что хранится и выполняется, что обладает содержанием (параметры, тензоры, состояние). Это момент **положенности** (Gesetztsein) материи в системе.
- **Антитезис (отрицательный момент):** **Abstract Graph Node** — идеальное начало. Узел есть «отрицательное» в смысле определения и границы: он не хранит содержание, а задаёт **место** и **связи**; он определяет, *как* блок встроен в целое. Это момент **опосредования** (Vermittlung), форма, в которую материя должна войти.
- **Синтез (снятие — Aufhebung):** Правило **«любой блок может стать узлом гиперграфа»** и сама **гиперграфовая структура** системы суть **синтез** двух моментов. В гегелевском смысле синтез не уничтожает тезис и антитезис, а **снимает** их: сохраняет и поднимает на высший уровень. Гиперграф — это целое, в котором блок (материя) и узел (идея) существуют только вместе: блок получает положение и связи (идеальную форму), узел получает содержание (материю в себе). **Сущность понятия** здесь — единство материального и идеального в единой исполняемой структуре; синтез и есть эта **конкретность** (das Konkrete): не «сначала блок, потом узел», а одна сущность «блок-в-узле» в составе гиперграфа.

Таким образом, два начала не просто сосуществуют — они **снимаются в синтезе**: гиперграф как движок и правило «блок → узел» суть то понятие (Begriff), в котором материальное и идеальное достигают своего единства.

### 2.4 Аналогия с фермионами и бозонами

На фундаментальном уровне допустима **аналогия с двумя классами элементарных частиц**:

| В физике | В Yggdrasil | Смысл аналогии |
|----------|-------------|----------------|
| **Фермионы** (носители вещества) | **Abstract Base Block** | «Частицы вещества»: то, что хранится и переносится по системе; носители параметров, тензоров, состояния. |
| **Бозоны** (переносчики взаимодействия) | **Abstract Graph Node** (и гиперрёбра гиперграфа) | «Переносчики взаимодействия»: то, что задаёт связи и обмен; узел задаёт положение и связи блока с другими блоками, не храня содержимое сам. |

Логика «блок → узел» аналогична тому, что «вещество» помещается в поле взаимодействий: материя получает положение и связи, не переставая быть носителем содержания.

---

## Часть III. Фундамент: блок, узел и правило превращения

### 3.1 Abstract Base Block — материальное начало

**Определение.** Абстрактный базовый блок — **минимальная единица** системы: то, что что-то хранит и что-то вычисляет. Любой объект в проекте может быть представлен как базовый блок или обёрнут в него.

**Что блок хранит (материальное содержание):**

- **Параметры и конфигурация:** конфиг, гиперпараметры, идентификаторы (`block_id`, `block_type`).
- **Тензоры и веса:** обучаемые веса, кэш, промежуточные данные.
- **Ссылки:** на другие блоки, ресурсы, граф.
- **Состояние:** всё, что нужно для воспроизводимости, сохранения и загрузки (state_dict, конфиг при сохранении).

**Контракт блока:** объявление интерфейса (входы/выходы — порты); выполнение по входам → выходы; идентификация (`block_type`, `block_id`). Блок — **атом сборки**: модели, кодекы, солверы, пайплайны в основе суть базовые блоки или композиции блоков. Ничего материального в системе нет вне блоков.

### 3.2 Abstract Graph Node — идеальное начало

**Определение.** Абстрактный узел в гиперграфе — **место** или **роль** в гиперграфе, которому может соответствовать **любой** абстрактный базовый блок. Узел не хранит материю сам: он задаёт **положение** и **связи** (гиперрёбра к другим узлам).

**Что задаёт узел (идеальное содержание):**

- **Положение в гиперграфе:** имя узла, уникальность.
- **Связи с другими узлами:** входящие и исходящие гиперрёбра (источник_узел, источник_порт) → (этот_узел, порт); порядок и направление потоков; гиперрёбра могут связывать более двух узлов (групповые связи).
- **Семантика портов на уровне гиперграфа:** какие порты блока «торчат наружу», участие во входах/выходах гиперграфа.

Узел задаёт **как блок встроен в целое**. Целое — гиперграф; идея целого — связи и порядок.

### 3.3 Правило «блок → узел» и синтез: единство уровня

- **Правило:** **любой Abstract Base Block может быть превращён в узел гиперграфа** (помещён в гиперграф как узел с именем и гиперрёбрами). Материя получает идеальную форму (место и связи), не переставая быть блоком. В гегелевских терминах это и есть **синтез**: снятие (Aufhebung) тезиса (блок) и антитезиса (узел как форма) в единое понятие «блок-в-узле».
- **Система как целое:** **гиперграф**, узлы которого содержат блоки; гиперрёбра задают потоки данных между портами блоков (и при необходимости групповые связи). Содержимое узлов — материя (блоки); структура гиперграфа — идея (узлы, гиперрёбра, порядок). Фундаментальный уровень не ставит одно выше другого: оба начала необходимы и **снимаются в синтезе** — в исполняемом гиперграфе как конкретном единстве материального и идеального.

### 3.4 Порты, композиция, жизненный цикл и исполнение

**Порты** — это **граница** блока: объявление того, что блок принимает и отдаёт, **без привязки к конкретному гиперграфу**. Блок не знает, откуда придут данные и куда уйдут — только имена и типы портов. Философски порты суть **идеальный момент материального блока**: контракт как форма, делающая блок **соединимым** с целым. Совместимость типов при соединении — условие **возможности** связи; валидация гиперграфа проверяет, что идеальная структура **реализуема** (согласована), прежде чем исполнение сделает её актуальной. **Внешние входы и выходы** гиперграфа (exposed inputs/outputs) — порты узлов, выведенные к границе целого; та же логика «блок открыт вовне через порты» поднимается до уровня графа и пайплайна.

**Композиция:** блок может **внутри себя** содержать другие блоки (подблоки); снаружи он по-прежнему соблюдает контракт Abstract Base Block. Вся материя внутри него — снова блоки. Тем самым **онтология рекурсивна**: «атом» может быть составным; один и тот же принцип (хранить + выполнять, порты + run) действует на любом масштабе. Это не отмена фундамента, а его **самоподобие**: единство материи и идеи воспроизводится внутри блока как внутренний подграф или пайплайн.

**Жизненный цикл** блока: создание (по конфигу, с block_type и block_id) → размещение в узле гиперграфа → выполнение (исполнитель подаёт данные на порты, вызывает run, забирает выходы) → сохранение/загрузка. **Исполнение** — это **актуализация** структуры: гиперграф как идеальная форма «происходит» во времени, когда исполнитель обходит узлы и вызывает блоки; без run структура лишь возможна, с run она **осуществляется**. Реестр типов (block_type → класс реализации) связывает **имя** (идея, понятие) с **реализацией** (материя); один и тот же block_type может быть инстанцирован во многих узлах — множество экземпляров при единстве понятия.

---

## Часть IV. Принцип Lego: свобода и единая основа

### 4.1 Суть принципа

Вся система должна быть **Lego-подобной** и собираться как конструктор.

- **Любой блок с любым блоком.** Совместимость определяется портами и типами, а не фиксированным списком связей.
- **Абсолютная гибкость сборки.** Порядок и количество блоков не предписаны сверху.
- **Реальная песочница.** В рамках правил графа (совместимость портов, направление потоков) всё можно соединять со всем.
- **Полноценный конструктор.** Максимальная свобода: свои блоки, свои типы узлов, свои правила преобразования **без переписывания ядра**. Любая модель, любая задача, любая цепочка задач, любая последовательность или набор переходов, любое взаимодействие между мирами реализуются **внутри** фреймворка — через реализацию контракта и регистрацию, без изменений движка, основы и философской мысли.

Итог: **максимальная свобода** при **единой основе** — материальный блок и идеальная логика «блок → узел гиперграфа»; движок предоставляет все возможности, пользователь ничего не допиливает в ядре.

### 4.2 Уровень над фундаментом: абстрактные узлы-задачи

Сразу над фундаментом (блок и узел) располагается уровень **абстрактных узлов-задач** — уровень **сугубо абстрактный**: здесь нет исполняемых экземпляров, только **спецификации** и **роли**. К этому уровню относятся Abstract Backbone, Abstract Solver, Abstract Codec, Abstract Adapter, Abstract Conditioner, Abstract Tokenizer, Abstract Guidance, Abstract Agent и др. Каждая такая сущность **одновременно** наследует Abstract Base Block и Abstract Graph Node и задаёт **спецификацию задачи** — фиксированную роль в гиперграфе, контракт портов (имена, типы, направление), семантику выполнения (что происходит при run) и типичные связи с другими типами узлов. На уровне над фундаментом **не вводятся новые независимые сущности**: каждая абстракция есть **ограничение и специализация** пары (Block, Node). Узел — не «просто узел», а узел типа «backbone», «solver», «codec»; блок внутри такого узла — не «просто блок», а блок, реализующий соответствующую задачу. Конкретные реализации (UNet2D, DDIMSolver, VAE, LoRA, CLIP и т.д.) — это уже **экземпляры**, которые появляются на следующем уровне, при сборке исполняемого гиперграфа.

### 4.3 Аналогия: абстрактные понятия и конкретные решения

Уровень абстрактных узлов-задач можно уподобить **набору абстрактных понятий** (или «ролей»), из которых затем собирается любое конкретное решение:

- **Абстракции** — это конечный перечень **типов** (Backbone, Solver, Codec, Conditioner, Tokenizer, Adapter, Guidance, Agent, …). Каждый тип задаёт только **что** должно быть (контракт портов, семантика), а не **как** именно реализовано (какая архитектура, какие веса).
- **Конкретная реализация** — выбор одной из возможных «наполнений» абстракции (например, Backbone → UNet2D или DiT; Solver → DDIM или Euler). Гиперграф собирается из **экземпляров** таких реализаций, соединённых по портам согласно контрактам абстракций.

**Ключевой принцип:** из **конечного набора абстрактных сущностей** (узлы-задачи) можно собрать **любую конкретную решаемую задачу** — text-to-image, image-to-video, upscale, распознавание, агентный цикл с инструментами и т.д. Конечность набора абстракций не ограничивает разнообразие решений: комбинация ролей, порядок соединения и выбор конкретных реализаций (UNet, VAE, DDIM, …) дают неограниченное множество конкретных гиперграфов. Аналогия: из конечного алфавита можно составить бесконечно много слов; из конечного набора абстрактных ролей (Backbone, Solver, Codec, …) — бесконечно много конкретных пайплайнов и миров. Узлы «знают» свою роль; типичные связи выводятся из типа узла-задачи, поэтому сборка гиперграфа задачи (например, text-to-image) сводится к добавлению нужных узлов и при необходимости явному связыванию портов — в несколько строк или из конфига.

### 4.4 Двойное наследование: одна сущность как материя и форма

Узлы-задачи (Abstract Backbone, Solver, Codec, Adapter, Conditioner, Tokenizer, Guidance и т.д.) **одновременно наследуют** Abstract Base Block и Abstract Graph Node. То есть **одна и та же сущность** в системе выступает и как **блок** (хранит параметры, веса, выполняет вычисления), и как **узел** (задаёт положение и связи в гиперграфе). Философски это — **тождество материи и формы в одном понятии**: не «сначала блок, потом его помещают в узел», а **одно понятие**, в котором момент хранения и вычисления (материя) и момент места и связей (идея) неразделимы. Двойное наследование есть онтологическое утверждение: на уровне задач **атом сборки** уже не «чистый блок» и не «чистый узел», а **блок-как-узел** — синтез, закреплённый в самой типологии (каждый узел-задача по определению и блок, и узел). Тем самым принцип синтеза (часть II–III) поднимается на уровень абстракций: Backbone, Solver, Codec и т.д. суть **конкретные понятия**, в которых материальное и идеальное даны в одном типе сущности.

---

## Часть V. Иерархия уровней: от задачи до вселенной

### 5.1 Общая схема

Мы работаем **не с графом, а с гиперграфом**. На каждом уровне структура устроена как **гиперграф** (обычный граф — частный случай при гиперрёбрах размера 2). Единая модель движка от блока до вселенной — гиперграф.

| Уровень | Состоит из | Что передаётся по связям |
|---------|------------|---------------------------|
| **Граф** | Узлов-задач (Backbone, Solver, Codec, Conditioner, Tokenizer, …) | Данные между портами узлов. **Одна цельная задача** (text-to-image, upscale, image-to-video и т.д.). |
| **Пайплайн** | Целых графов (один или несколько) | Данные между графами. **Комбинированные задачи** (текст → картинка → апскейл → видео). Пайплайн может состоять из одного графа. |
| **Переход (Stage)** | Пайплайнов | **Stage — гиперграф пайплайнов**, реализующий **один переход** (метаморфозу state). Между переходами в мире передаётся **state**. |
| **Мир (World)** | Переходов | **Мир — цепочка переходов.** Узлами мира являются переходы (Философ, Автор, Среда, Архитектор, Творец); по рёбрам передаётся state. Циклический граф. |
| **Вселенная (Universe)** | Миров | **Граф миров.** Узлы = миры, рёбра = связи между мирами; обмен по payload_spec (в т.ч. сущности с состоянием). Счёт миров (count of worlds). |

### 5.2 Первый исполняемый уровень — гиперграф задачи

Ниже уровня «гиперграф задачи» — только спецификации (абстракции блоков и узлов-задач). **Гиперграф задачи** (на этом уровне часто называемый «графом» в смысле одной цельной задачи) — первый уровень, на котором система **исполняется**: один гиперграф = одна задача; по нему передаются данные, выполняется run. Комбинирование нескольких задач делается на уровне **пайплайна** (гиперграф гиперграфов).

### 5.3 Гиперграф и гиперссылки

Вся архитектура устроена как **гиперграф**: гиперрёбра могут соединять любое число узлов (не только два). **Гиперссылки** — связи, указывающие на сущность или контекст; они обеспечивают **связывание контекстов** и **взаимодействие** в масштабе фреймворка (от порта/блока до мира, этапа, артефакта или End World). Контракты уровней допускают хранение и передачу гиперссылок; сериализация и чекпоинты их сохраняют.

### 5.4 Уровень пайплайна

**Пайплайн (Pipeline)** — уровень сразу над гиперграфом задачи: это **гиперграф, узлами которого являются целые гиперграфы задач** (каждый узел — одна цельная задача: text-to-image, upscale, image-to-video и т.д.). Иными словами, пайплайн — **гиперграф гиперграфов**: на уровне задачи мы собираем узлы-задачи (Backbone, Solver, Codec, …) в один исполняемый гиперграф; на уровне пайплайна мы собираем уже **целые такие гиперграфы** как узлы и соединяем их гиперрёбрами.

- **Что течёт по пайплайну:** по гиперрёбрам пайплайна передаются **данные между задачами** — выход одного гиперграфа (например, изображение) становится входом другого (например, апскейл или image-to-video). Контракт задаётся внешними входами и выходами каждого гиперграфа-узла; пайплайн соединяет выход одного узла с входом другого (или с внешним входом/выходом пайплайна).
- **Зачем пайплайн:** один гиперграф = **одна цельная задача**; пайплайн нужен для **комбинированных сценариев** — цепочка или ветвление из нескольких задач. Примеры: текст → картинка → апскейл → видео; или аутпейнтинг → апскейл → image-to-image. Пайплайн не разбивает одну задачу на куски (текст, диффузия, декодирование — всё внутри одного гиперграфа задачи); он **соединяет готовые задачи** в сложный сценарий.
- **Вырожденный случай:** пайплайн может состоять из **одного** гиперграфа. Тогда он задаёт единый интерфейс «вход/выход пайплайна» для одной задачи — это удобно на уровне перехода (Stage), где между переходами передаётся уже state, а не сырые данные между графами.
- **Исполнение:** выполнить пайплайн — значит в порядке топологии (или заданном порядке) выполнять **целые гиперграфы** и передавать результаты по гиперрёбрам пайплайна. Каждый узел пайплайна для внешнего наблюдателя — «чёрный ящик» с входами и выходами задачи; внутреннее устройство (Backbone, Solver, Codec внутри) пайплайну не важно.

Таким образом, уровень пайплайна — это **второй исполняемый уровень** иерархии: первый — гиперграф одной задачи, второй — гиперграф таких гиперграфов. Гиперграф и гиперссылки действуют и здесь: пайплайн представлен как гиперграф (при необходимости с групповыми гиперрёбрами и гиперссылками между графами-узлами или на внешние артефакты). Выше пайплайна идёт уровень **перехода (Stage)** — гиперграф пайплайнов, реализующий одну метаморфозу state.

---

## Часть VI. Переход как метаморфоза: материя ↔ идея

### 6.1 Что такое переход (transition)

**Переход** — фундаментальное изменение состояния системы: **метаморфоза**. Один объект превращается в другой; материя — в идею, идея — в материю. Уровень перехода — уровень именно таких преобразований: не просто передача данных, а качественное превращение state (артефакты → идеализированное описание; описание → конфигурация; конфигурация → артефакты; state → обновлённый мир).

В каноне термин **«этап» (stage)** в контексте мира понимается как **переход**: каждое звено цикла мира реализуется на уровне Stage (граф пайплайнов) и осуществляет одну метаморфозу.

### 6.2 Идеальные задачи пяти переходов мира

| Переход | Идеальная задача |
|---------|------------------|
| **Философ** | Описание и идеализация материального. Вход — артефакты (блок 3); выход — идеализированное описание (блок 4). |
| **Автор** | Глубокий анализ идей Философа и описание в рамках мирового контекста. Идеальное описание (блок 4) → нарратив «что реально произошло» (блок 5). |
| **Среда** | Управление миром: (1) World update — применение state к миру при полном state; (2) Development of the world — порождение нового state (блок 1), опционально с учётом Action. |
| **Архитектор** | Интерпретация развития мира и перевод в техническую структуру. Вход — блок 1; выход — конфигурация генерации (блок 2). |
| **Творец** | Прямая реализация: по конфигурации (блок 2) генерация артефактов (блок 3). |

Цикл в идеальном представлении: новые материальные объекты (блок 3) снова попадают к Философу → идеализация (блок 4) → Автор → блок 5 → Среда (World update при полном state, затем Development → новый блок 1) → Архитектор → Творец → …

---

## Часть VII. Мир: state, пять блоков, жизненный цикл

### 7.0 Мир как непрерывное становление

**Мир (World)** в проекте — это не статичный «объект», а **непрерывная цепь крупномасштабных переходов**: гиперграф, узлами которого являются **переходы** (Философ, Автор, Среда, Архитектор, Творец), по гиперрёбрам передаётся **state**. Каждый переход — **метаморфоза** состояния (материя ↔ идея); порядок выполнения фиксирован, граф циклический. Мир **один**: он обновляется применением state (World update при полном state), а новое состояние рождается внутри цикла (Development of the world). Мир может **развиваться сам**, итеративно, без обязательного действия пользователя (Action опционален). Таким образом, мир — это **процесс**, в котором состояние непрерывно претерпевает превращения и в котором цикл замыкается через Среда: Development порождает новый state с блоком 1 → Архитектор → Творец → Философ → Автор → Среда (World update при полном state, затем снова Development) → …

### 7.1 State — пять блоков

**State** (состояние мира) задаётся **пятью блоками**:

| № | Блок |
|---|------|
| 1 | Описание того, что должно было произойти |
| 2 | Конфигурация для генерации артефактов |
| 3 | Сгенерированные артефакты |
| 4 | Описание сгенерированных артефактов |
| 5 | Описание того, что реально произошло в мире |

**World update** выполняется **только при полностью заполненном state** (все пять блоков): тогда state применяется к миру, контент мира обновляется, state сохраняется. Иначе World update не выполняется.

### 7.2 Среда — два узла

**Среда (Environment)** в графе мира — **два последовательных узла**:

1. **World update** — выполняется только если state полностью заполнен (все 5 блоков); обновляет внутреннее содержание мира, сохраняет state.
2. **Development of the world** — выполняется **безусловно**; читает мир, с учётом Action (если передан) как контекста для LLM или без него создаёт **новый state** с блоком 1. Мир может развиваться сам, итеративно.

### 7.3 Порядок и одна структура

Порядок выполнения **фиксирован**: Философ → Автор → Среда → Архитектор → Творец → … Каждый переход выполняется только при заполненных нужных ему блоках state; World update — только при блоке 5. Между Автором и Архитектором передаётся один и тот же контейнер слотов (артефакты): в материальной форме — данные, в идеальной — описания.

### 7.4 Философские аналогии уровня мира

Описание мира можно упорядочить и углубить с помощью нескольких **философских аналогий**.

- **Становление и поток (Гераклит).** «Всё течёт» — мир в проекте есть именно **течение**: state не застывает, а последовательно проходит через переходы и каждый раз качественно меняется (метаморфоза). Нет «готового» мира как объекта; есть **непрерывное становление** — цикл превращений (идея → конфигурация → артефакт → описание → нарратив → обновление мира → новая идея). Аналогия подчёркивает процессуальную природу мира: мир — это не что, а **как** — способ развёртывания состояния во времени.

- **Цикл и диалектика.** Пять переходов можно увидеть как **диалектический круг**: намерение (блок 1) → техническая форма (блок 2) → материальная реализация (блок 3) → идеальное описание (блок 4) → нарратив «что реально произошло» (блок 5) → снятие в обновлённый мир и новый блок 1. State выступает как **единый носитель** этих моментов; каждый переход «снимает» предыдущий момент и добавляет следующий. World update — момент **объективации** цикла: полный state вписывается в мир, цикл получает продолжение через Development.

- **State как «память» и «план» мира.** Пять блоков state — не просто данные, а **пять измерений** текущего состояния мира: что задумано (1), как технически задано (2), что материально создано (3), как это описано (4), как это вписано в историю мира (5). State — то, что **течёт** между переходами и **сохраняется** при World update; в нём одновременно «память» текущего цикла и «план» следующего шага (блок 1 после Development). Аналогия с душой или сознанием не обязательна, но образ «state как душа мира, проходящая через фазы» передаёт единство и преемственность.

- **Один мир и самодвижение.** Мир **один** — не множество параллельных миров, а единая цепочка переходов с единым state на каждом шаге. Он может **развиваться сам** (Development безусловно создаёт новый блок 1 по текущему состоянию мира). Это роднит модель с идеей **автопоэзиса** (Мaturana, Varela): система воспроизводит сама себя через цикл; внешний Action — лишь опциональный контекст, а не обязательный толчок. Мир как **самодвижущийся процесс** — без обязательного внешнего «часовщика» на каждом витке.

- **Переход как фаза космоса.** Каждый из пяти переходов — не произвольная «функция», а **роль** в целостном цикле: Философ (идеализация материи), Автор (нарратив в контексте мира), Среда (управление миром и порождение следующего шага), Архитектор (идея → техническая структура), Творец (структура → материя). Вместе они образуют замкнутый **космос превращений** — минимум, достаточный для того, чтобы мир мог обновляться, отражать себя в описаниях и порождать новые состояния. Аналогия с «фазами» или «стихиями» цикла подчёркивает неслучайность именно пяти звеньев и их порядка.

### 7.5 Начало без предзаданного state и роль пользователя

**Первая итерация** может начаться **без переданного state**: тогда Философ, Автор и World update пропускаются, цикл фактически **начинается с Development of the world**, который создаёт **первый state** (блок 1) из текущего состояния мира. Философски это — **начало без предзаданного состояния**: мир способен породить первый шаг из себя (из начального содержания или пустоты), без обязательного «внешнего толчка». **Action** (действие пользователя) **опционален**: он поступает в Development как контекст для языковой модели; при его отсутствии Development выполняется безусловно и создаёт следующий эпизод по текущему миру. Пользователь тем самым выступает не как необходимая причина каждого шага, а как **опциональный со-автор**: мир может развиваться сам; участие пользователя обогащает контекст, но не является условием возможности цикла. Передача state пользователем на первом шаге задаёт, какие переходы выполняются или пропускаются (в зависимости от заполненности блоков) — то есть **внешний ввод** встраивается в ту же логику «выполнять переход только при готовности входа», без отдельной онтологии «запуск извне».

---

## Часть VIII. Вселенная: гиперграф миров и этап для сообщества

### 8.1 Этап Вселенной: что это за уровень

**Этап Вселенной (уровень Вселенная, Universe)** — уровень **выше мира**. Один мир — одна цепочка переходов (один цикл, один state); вселенная — **гиперграф, узлами которого являются миры** (world_id → World). По гиперрёбрам между мирами передаётся обмен: state snapshot, артефакты, контекст, события, **сущности** с состоянием (персонажи, агенты). Вселенная есть одновременно **гиперграф миров** (структура связей) и **счёт миров** (множество узлов). Выполнение — обход гиперграфа миров (топологический порядок или фиксированный цикл); после run(world_A) выходы мира A по payload_spec мапятся на входы мира B по входящим гиперрёбрам. Канон одного мира не меняется: вселенная не подменяет мир, а добавляет уровень «над» ним — множество миров и связи между ними.

### 8.2 Структура и выполнение вселенной

- **Узлы:** миры (объектные — развиваются, state обновляется; или End Worlds — фиксированы, только чтение). Каждый мир — самостоятельная единица со своим циклом и своим state.
- **Гиперрёбра:** что передаётся между мирами (payload_spec): направление влияния (A → B, B → A, двунаправленное), момент синхронизации (после run(world_A), после run(world_B), после обхода подграфа). Гиперрёбра могут связывать более двух миров (групповые связи). Гиперссылки — связывание контекстов и ссылки на End Worlds.
- **Общий контекст (опционально):** аналог «колодца Урд» в мифе Иггдрасиль — общее хранилище или каталог (глоссарий, правила, стиль), доступное всем мирам по гиперрёбрам или при инициализации.
- **Выполнение:** run(universe, ...) — обход гиперграфа миров, вызов run(world, ...) для каждого мира, передача данных по гиперрёбрам; при переходе сущностей — обновление state мира-источника и мира-назначения по правилам кросс-мирового влияния.

### 8.3 Этап Вселенной создан прежде всего для сообщества

Уровень Вселенной предназначен **в первую очередь для сообщества пользователей**:

- **Сравнение миров:** пользователи могут **сравнивать свои миры** друг с другом.
- **Развитие через взаимодействие:** развитие миров на основе **взаимодействия персонажей пользователей с мирами других пользователей** — персонаж из мира A переходит в мир B, действует там, влияет на историю B и на свою историю в A.
- **Единая система взаимодействий:** построение **единой системы мировых взаимодействий**, сложных интеграций между мирами (направление влияния, синхронизация, payload_spec).
- **Обмен и совместное творчество:** **делиться результатами с сообществом**, обмениваться идеями, **расширять свои миры** за счёт взаимодействия с мирами других пользователей.
- **Группы миров:** формирование **групп миров** по общим идеям или сюжету.
- **Влияние на экосистему:** возможность **творчески влиять на всю экосистему** и в определённом смысле **деструктивно влиять** на неё — например, **синтезировать новые миры** из взаимодействия группы миров или **аннигилировать миры** в результате тех или иных взаимодействий.

На уровне Вселенной как объединения миров должен существовать **единый поток трансляции (single fluid broadcast)** всех взаимодействий, затрагивающих экосистему. Для этапа Вселенной важны **децентрализация** и **полная распределённость** при сохранении всех возможностей нижележащих уровней и **удобстве для сообщества**.

### 8.4 Взаимодействие между мирами и между сущностями

- **Между мирами:** по гиперрёбрам задаются условия и порядок взаимодействия, направление влияния, момент синхронизации; контракт вселенной описывает, когда мир B получает входы от мира A и как обновляется state мира A (например, при возврате сущности или отражении событий из B).
- **Между сущностями:** сущности могут быть помечены происхождением (origin_world_id); правила мира по-разному обрабатывают «локальных» и «пришлых» сущностей. **Переход сущности по ребру** (из мира A в мир B) и обратное отражение событий в мир A — основа кросс-мирового влияния. **Агентные системы** на уровне вселенной обеспечивают обмен данными между мирами: агенты/персонажи перемещаются между мирами, их действия в мире B влияют на историю B и на свою историю в мире A.

### 8.5 End Worlds (миры-завершения)

**End World** — мир, который **не изменяется** и **фиксирован**; к нему можно привязываться и с ним взаимодействовать (читать контекст). Объектный мир (Near World), связываясь с End World по **гиперссылке**, обогащает свой контекст и истории персонажей; **End World не меняется**. Пример: книга как End World. В гиперграфе миров вершины могут быть типа «объектный мир» или «End World»; гиперссылки из мира/персонажа на End World разрешаются при выполнении (чтение контекста). В сериализации мира выделяются два крупных поля: (1) структура/исполняемая часть, (2) контент мира; End World = только контент, без исполняемой части (без весов и запуска).

### 8.6 Вселенная и миф Иггдрасиль

Уровень Вселенной напрямую сопоставляется с **мифом Иггдрасиль** — мировым древом, соединяющим несколько миров (реальмов). **Гиперграф миров** — структура: узлы = миры (девять реальмов в мифе — счёт миров в модели), гиперрёбра = корни и ветви, соединяющие миры. **Колодец Урд** (источник у корня, норны, судьба) — общий контекст вселенной или хранилище, доступное мирам. **Обмен по гиперрёбрам** — как Белка Рататоск, снующая между орлом на вершине и змеем у корней и переносящая сообщения. Один мир в каноне — один «реальм» на древе (Мидгард, Асгард и т.д.); **вселенная** — целое древо: гиперграф таких миров и связей между ними. Имя Yggdrasil закрепляет не только техническую иерархию, но и то, что этап Вселенной — это уровень, на котором множество миров оказываются **единым целым** по связям и обмену.

---

## Часть IX. Агентные системы и гибкость использования

### 9.1 Полная интеграция агентных систем

Агентные системы — **равноправная часть архитектуры**, не надстройка. Агент — блок с состоянием между вызовами, с возможностью возвращать **tool_calls** и принимать **tool_results**; инструменты — блоки или графы, вызываемые агентом. Граф может содержать узел-агента и узлы-инструменты; выполнение — цикл «агент → tool_calls → выполнение инструментов → агент» (agent_loop). Этап и мир могут содержать этапы-агентов с инструментами; на уровне вселенной агенты/персонажи могут перемещаться между мирами и влиять на историю нескольких миров.

### 9.2 Полная гибкость использования

Движок должен позволять использовать **каждую часть в классических сценариях** при соблюдении канона:

- Только агентные системы (агент + инструменты, без обязательного мира или диффузии).
- Только модель мира (цикл этапов, state, Scheme, без обязательных агентов или диффузии).
- Только языковые модели (инференс/обучение на уровне графа/блоков).
- Только диффузионные модели; только простые нейросети (уровень блоков).
- Любые комбинации: язык + диффузия, агенты + мир, полный стек.

Пользователь может подниматься или опускаться до нужного уровня представления и использовать движок именно на этом уровне при **единой основе** и **строгом соблюдении канона и философии**.

---

## Часть X. Сериализация, обучаемость, расширяемость

### 10.1 Сериализация на всех уровнях

Проект **полностью сериализуем на каждом уровне** — от блока до мира (и при расширении — вселенной). Для каждого уровня: конфиг структуры + чекпоинт весов; возможность **загрузки из чекпоинта** этого уровня. Мир как верхняя абстракция представляется конфигурационным файлом или шаблоном; из конфига — загрузка, из шаблона + параметров — генерация мира, конфиг + чекпоинт — обученный мир. Два крупных поля сериализации мира: (1) структура/исполняемая часть, (2) контент мира; End World — только контент.

### 10.2 Обучаемость на всех уровнях

На **каждом уровне представления** всё, что может быть обучено, должно поддерживать обучение. Любой блок с обучаемыми параметрами (Backbone, LoRA, Codec, Conditioner и т.д.) — обучаем в составе своего уровня; граф, пайплайн, этап, мир — с выбором trainable сущностей и заморозкой остальных. Конфиг обучения и чекпоинты сериализуемы; после обучения сохранённую сущность можно загрузить и продолжить обучение или только инференс.

### 10.3 Единый контракт и расширяемость

На каждом уровне — единый контракт: объявление входов/выходов (get_input_spec, get_output_spec), выполнение (run), сериализация (конфиг + чекпоинт). Новые сущности и возможности вводятся **без изменений движка**: только реализация контракта и регистрация в реестре; никаких структурных инъекций в ядро, никаких манипуляций с фреймворком — фреймворк изначально предоставляет все возможности. При противоречии новой идеи с Scheme или Philosophy сначала обновляется канон, а не ядро под частный случай. Поддержка гиперссылок в контрактах; поддержка блоков через API — любой блок, для которого доступен API, должен подключаться через API **без отличия** от режима с локальными весами или весами на эндпоинте (единый контракт, одни сценарии).

### 10.4 Повторное использование одной модели: тождество без дублирования

Если один и тот же чекпоинт (одна и та же модель, один checkpoint_ref) используется в нескольких узлах, графах или пайплайнах, в памяти должен существовать **один экземпляр** — все места ссылаются на него. Философски это — **тождество без дублирования материи**: одна и та же «сущность» (модель, заданная ref) не умножается в бытии при множественном использовании; система признаёт идентичность по идентификатору и экономит материю (память). Правило действует на всех уровнях иерархии и для всех типов блоков (в т.ч. LLM, VLM, backbone, codec через API с одним model_id). Тем самым **идентичность блока** задаётся не только block_id в графе, но и ref на общий ресурс: «один ref → один экземпляр» есть онтологический принцип — не создавать копии того, что уже есть под тем же именем.

### 10.5 Лёгкие кастомные миры и масштабируемость без привязки к одной архитектуре

**Лёгкие кастомные миры:** базовый мир (все веса заморожены) + LoRA-адаптеры (или аналоги), подключённые ко всем нужным блокам; обучаются только адаптеры. Получается **кастомный мир** без полного fine-tune: один базовый мир и много **вариантов** за счёт разных наборов адаптеров. Философски это — **мир как шаблон и вариация**: одна материя (базовый мир), много форм (наборы LoRA); адаптация без дублирования всей материи. Та же логика «тождество / вариация» на уровне мира.

**Масштабируемость и расширяемость:** проект не привязан к одному типу модели или архитектуре. LLM, VLM, любая диффузионная модель, любая нейросетевая архитектура встраиваются как блоки с объявленными портами и выполнением; **фундамент предписывает только форму** (контракт, порты, run), а не содержание (какие слои, какая архитектура). Новый тип блока добавляется через реализацию контракта и регистрацию в реестре — без изменения ядра. Тем самым система **открыта по содержанию**: любое конкретное воплощение, удовлетворяющее форме, принадлежит той же онтологии. Масштабируемость обеспечивается единым фундаментом, сериализуемостью на всех уровнях и отсутствием жёсткой привязки к конкретному семейству моделей.

---

## Часть XI. Внешние миры и источники контекста

### 11.1 Поддержка вики-ресурсов (Fandom, Wikipedia и аналоги)

Система должна позволять **сформировать или наполнить мир по ссылке на вики-ресурс**: заполнение мира в сериализованной форме на основе контента с сайта (описание, персонажи, глоссарии, истории, статьи). Поддерживаются не только **Fandom.com**, но и **Wikipedia** и **аналогичные вики-ресурсы** — любой источник, из которого можно извлечь структурированный или текстовый лор (статьи, категории, ссылки). Один URL или идентификатор ресурса → конфигурация/начальное наполнение мира. Результат — конфиг мира и/или начальное содержание; дальше мир работает по канону (цикл, state, Development of the world). При необходимости такой мир может быть зафиксирован как End World. Детали парсинга, лимитов обхода и маппинга в модель мира задаются реализацией; философский принцип — **возможность использовать такие ресурсы без жёсткой привязки к одному сайту**.

### 11.2 Блоки через API: единый контракт, никакой разницы

**Любой блок**, для которого возможно подключение через API (LLM, VLM, эмбеддинги, генерация изображений по API и т.д.), должен иметь **возможность работать через API без каких-либо изменений** в использовании. То есть **не должно быть разницы** между блоком, подключённым через API (без локальных весов), и блоком с весами на эндпоинте или с локально загруженными весами: один и тот же контракт портов, одна и та же семантика выполнения, одни и те же сценарии. Граф, пайплайн, этап и мир **не зависят** от того, как реализован блок — по API или локально; выбор задаётся только конфигом блока (backend: API vs local/endpoint). Никакой специальной обработки, никаких «ветвлений» в коде под «API-блок»: для остальной системы блок остаётся блоком с теми же входами/выходами и тем же run. Этапы мира (Автор, Философ, Архитектор, Development) и любые другие узлы могут использовать такие блоки полностью через API; обучение, сериализация и повторное использование моделей согласованы с этим принципом (в т.ч. сценарии с API-узлами — см. канон TRAINING_REUSE_AND_API_SCENARIOS).

---

## Часть XII. Итог: развитие философской идеи в проекте

### 12.1 Как проводится единая философская нить

Философия проекта выстраивается **структурно** — как последовательное развитие одной идеи от основания до высших уровней. Ниже показано, **как** эта идея развивается шаг за шагом, так что каждый следующий уровень не привносит новую онтологию, а развёртывает ту же мысль.

**Шаг 1. Два начала и их синтез.** В основании — разделение на материальное (то, что хранит и несёт) и идеальное (то, что задаёт связи и порядок). Они воплощаются в **блоке** и **узле гиперграфа**; правило «любой блок может стать узлом» замыкает фундамент. В гегелевском смысле **синтез** этих двух моментов — сам гиперграф и это правило: снятие (Aufhebung), единство понятия. Итог: система держится не на двух разрозненных сущностях, а на их **единстве в гиперграфе**. Цель проекта — предельная гибкость и масштабируемость; одна философская позиция описывает устройство **любой сложной системы** вплоть до модели вселенной. Три столпа: **простота запуска** (буквально в несколько строк кода при полной автоматизации согласования), **всеобъемлющая сериализация** (мощь и многофункциональность при воспроизводимости всего) и **абсолютная свобода настройки** (любые архитектуры, задачи, сценарии, миры, сообщества). В духе «Minecraft в мире программирования — но больше»: из конечного набора абстракций собирается что угодно, вплоть до вселенной и её сообщества. Фреймворк — **песок в бесконечной пустыне**: пользователь создаёт любые формы, от простых до целых миров; **единственное ограничение — фантазия**. **Полная кастомизируемость** — любая модель, задача, цепочка задач, последовательность или состав переходов, взаимодействие между мирами — реализуется **без изменений движка**, без структурных инъекций в ядро; инструменты (контракт, реестр) дают возможность кастомной реализации всего при неизменной основе и философской мысли.

**Шаг 2. Единая форма на всех уровнях.** Если синтез — гиперграф, то и движок системы — гиперграф; не граф, а именно **гиперграф** (гиперрёбра, гиперссылки). Одна и та же форма повторяется на каждом уровне: гиперграф задачи → гиперграф гиперграфов (пайплайн) → гиперграф пайплайнов (переход) → гиперграф переходов (мир) → гиперграф миров (вселенная). Философское развитие: **одна структура** пронизывает всё; различается только то, что является узлом и что течёт по рёбрам (данные, затем state, затем обмен между мирами).

**Шаг 3. Свобода при единстве.** Из единства основы выводится принцип **Lego**: максимальная свобода сборки (любой блок с любым в рамках портов и типов) при **единой основе** — материальный блок и идеальная форма узла. Нет противоречия между свободой и структурой: структура задаёт правило, свобода — способ сборки внутри него.

**Шаг 4. Абстрактный уровень и переход к конкретному.** Над фундаментом не вводятся новые «атомы», а вводятся **абстрактные роли** (Backbone, Solver, Codec, …) — специализации пары блок/узел; каждая такая сущность **двойно наследует** Block и Node, то есть по определению есть **одно понятие** (материя и форма в одном типе). Философский ход: **конечный набор абстракций** → **бесконечное множество конкретных решений**. Из одного и того же набора ролей собирается любая конкретная задача; аналогия — алфавит и слова. Идея синтеза сохраняется и закрепляется в типологии: каждая роль есть единство блока и узла с фиксированной задачей.

**Шаг 5. Иерархия как восхождение одной идеи.** Пайплайн — гиперграф, узлами которого являются целые гиперграфы задач; переход (Stage) — гиперграф пайплайнов, реализующий одну **метаморфозу** state; мир — цепочка таких переходов, по гиперрёбрам течёт state. Развитие идеи: то, что на уровне задачи было **потоком данных**, на уровне мира становится **потоком состояния** (state), претерпевающего качественные превращения (материя ↔ идея). Тот же принцип «узлы + поток» поднимается на новый уровень.

**Шаг 6. Мир как становление.** Мир — не объект, а **процесс**: непрерывное становление (Гераклит), цикл метаморфоз (диалектика), state как «память» и «план», возможность самодвижения (автопоэзис). Первая итерация может начаться **без предзаданного state** — мир способен породить первый шаг из себя; пользователь выступает **опциональным со-автором**, а не необходимой причиной каждого шага. Философская нить: на уровне мира та же оппозиция материи и идеи развёртывается во **времени** — как цикл из пяти переходов и пяти блоков state; единство сохраняется в единстве state и единстве порядка перехода.

**Шаг 7. Вселенная как множество миров в единстве связей.** Выше мира — гиперграф миров; счёт миров и связи между ними. Идея развития: **множество** (много миров) становится **единым целым** за счёт гиперграфа и обмена (гиперрёбра, сущности, кросс-мировое влияние). Этап Вселенной — для сообщества; End Worlds — фиксированные точки, к которым можно привязаться. Та же логика «единство в структуре» переносится на уровень множества миров: не хаос, а **древо** (Иггдрасиль) — связная целостность.

**Шаг 8. Граница системы и единый контракт.** Внешние источники (вики: Fandom, Wikipedia и аналоги) и блоки через API встроены так, чтобы **не ломать нить**: формирование мира из вики-ресурса — тот же канон мира после наполнения; блок через API — **никакой разницы** с блоком с локальными весами (единый контракт, одни сценарии). **Тождество без дублирования**: один checkpoint_ref → один экземпляр в памяти на всех уровнях (экономия материи). **Мир как шаблон и вариация**: базовый мир + LoRA (или аналоги) дают множество кастомных миров без дублирования всей материи. **Открытость по содержанию**: фундамент предписывает только форму (контракт, порты); любая архитектура и любой тип модели встраиваются как блок — система не привязана к одному семейству моделей. Сериализация и обучаемость на всех уровнях — продолжение того же единства во времени (сохранить/загрузить, обучить). Гибкость использования (только агенты, только мир, только диффузия, любые комбинации) — следствие единой основы: можно опираться на любой уровень, не меняя философии.

Таким образом, **единая философская нить** — это не перечень тем, а **последовательное развёртывание** одной мысли: два начала → их синтез в гиперграфе → одна форма на всех уровнях → свобода при единстве → абстракции и конкретное → иерархия как восхождение → мир как становление → вселенная как целое множества → проницаемая граница при едином контракте. Каждый шаг вытекает из предыдущего; новых онтологий не вводится.

### 12.2 Назначение документа

Этот документ — **главный философский ориентир** при проектировании Universe Generator 3.0. Он задаёт *зачем*, *почему*, *как* и *что именно* для всех уровней и проводит **развитие философской идеи** в проекте структурно — от двух начал и синтеза до вселенной и границы системы. Операционная схема мира (цикл, state, условия выполнения) задаётся в каноне (Scheme.md); технические детали уровней — в файлах канона (Graph_Level, Pipeline_Level, Stage_Level, World_Level, EXPANSION_UNIVERSE и др.). Философия не подменяет канон, а извлекает из него единую мысль и показывает, как она развёртывается от основания до высших представлений.

---

*Документ составлен по канону WorldGenerator_2.0 для проекта Universe Generator 3.0 (Yggdrasil).*
