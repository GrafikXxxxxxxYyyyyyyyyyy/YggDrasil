# Примеры: дифференциальные уравнения и задачи рекурсивной природы

**Назначение:** показать, как **движок гиперграфа** проекта (02_HYPERGRAPH_LEVEL) позволяет решать **сложные уравнения** — в том числе нелинейные обыкновенные дифференциальные уравнения (ОДУ) — и задачи **рекурсивной природы**, например **последовательность Фибоначчи**. В обоих случаях ключевую роль играют **циклы в графе** и параметр **num_loop_steps** (или итеративная схема плана): движок многократно выполняет один и тот же подграф, передавая по рёбрам обновлённое состояние.

**Якорь:** [02_HYPERGRAPH_LEVEL.md](02_HYPERGRAPH_LEVEL.md) §6.5 (гиперграф с циклами, итеративная схема, num_loop_steps), [EXAMPLE_ARITHMETIC_AT_GRAPH_LEVEL.md](EXAMPLE_ARITHMETIC_AT_GRAPH_LEVEL.md), [RECURSION_AND_HYPERGRAPH.md](RECURSION_AND_HYPERGRAPH.md).

**Язык:** русский.

---

## 1. Общая идея: циклы в графе и итеративное выполнение

Движок поддерживает **гиперграфы с циклами** (02 §6.5): планировщик выделяет циклическую часть и формирует **итеративную схему** — «повторить K раз заданный подграф». Число итераций K задаётся конфигом (**num_loop_steps**, num_inference_steps) или опцией run. Между итерациями **буферы на рёбрах цикла обновляются**: выходы узлов на шаге k становятся входами узлов на шаге k+1. Тем самым один и тот же граф реализует **итеративный процесс** без явной рекурсии в коде пользователя.

- **Рекурсивные по определению задачи** (например, Фибоначчи F(n) = F(n−1) + F(n−2)) реализуются как **итерация с состоянием**: граф с циклом, в котором блоки вычисляют следующее состояние по предыдущему; K = число шагов.
- **Дифференциальные уравнения** (dx/dt = f(t, x)) интегрируются **пошагово**: на каждой итерации по времени вычисляется правая часть f и шаг метода (Эйлер, Рунге–Кутта и т.д.); состояние (t, x) обновляется. Цикл графа = один шаг по времени; K = число шагов по времени.

Ниже — конкретные схемы для ОДУ и для Фибоначчи.

---

## 2. Обыкновенные дифференциальные уравнения (ОДУ)

### 2.1 Постановка

Требуется решить задачу Коши для системы ОДУ (возможно нелинейной):

- **dx/dt = f(t, x)**, x(t0) = x0, где x — вектор состояния, f — заданная функция (линейная или нелинейная).

Интегрирование по времени: последовательно вычислять **x_{n+1}** по **x_n** и шагу **dt** по формуле выбранного метода (Эйлер, Рунге–Кутта 2/4 порядка и т.д.).

### 2.2 Граф для одного шага по времени

Один шаг метода можно представить **подграфом** из двух (или более) узлов:

| Узел | Назначение | Входы | Выходы |
|------|------------|--------|--------|
| **RHS** | Вычисление правой части f(t, x) | t, x | f_val |
| **Step** | Шаг метода: по (t, x, f_val, dt) вычисляет (t_new, x_new) | t, x, f_val, dt | t_new, x_new |

- **Рёбра:** (внешние или с предыдущей итерации) t, x → RHS; t, x, f_val, dt → Step; выход Step (t_new, x_new) на **следующей итерации** подаётся снова на RHS и Step (цикл).
- **На первой итерации** t и x приходят с внешних входов гиперграфа (t0, x0); dt — внешний параметр. После K итераций с графа снимаются итоговые t, x как внешний выход.

То есть граф содержит **цикл**: RHS → Step → (обновлённые t, x) снова в RHS и Step. Планировщик строит план «повторить K раз [RHS, Step]»; буферы между итерациями передают обновлённое состояние. **Нелинейность** целиком скрыта внутри блока RHS: f может быть произвольной (вплоть до вызова другого графа или нейросети).

### 2.3 Нелинейные ОДУ

Для **нелинейных** ОДУ блок **RHS** просто реализует нелинейную функцию f(t, x). Например, уравнение вида dx/dt = g(x) с полиномом или экспонентой: внутри RHS — формула или подграф, вычисляющий g(x). Движок не меняется; меняется только реализация блока RHS. Если используется **неявная схема** (например, неявный Эйлер), то на одном шаге по времени нужно решать уравнение вида x_new = x + dt·f(t_new, x_new). Тогда блок **Step** может сам содержать внутренний цикл (например, итерации Ньютона) или вызывать подграф «решатель» до сходимости — по канону это либо блок с состоянием и циклом внутри, либо вложенный граф с циклом (RECURSION_AND_HYPERGRAPH).

### 2.4 Пример конфигурации (схема Эйлера)

- **Узлы:** rhs (block_type: ode/rhs, конфиг с видом f), step (block_type: ode/euler_step).
- **Рёбра внутри одной итерации:** (step, t_out) → (rhs, t); (step, x_out) → (rhs, x); (rhs, f_val) → (step, f_val); (step, t_out) → (step, t) для следующей итерации; (step, x_out) → (step, x) для следующей итерации. На первой итерации t, x — с внешних входов.
- **Цикл:** планировщик помечает пару (rhs, step) как циклическую; num_loop_steps = N (число шагов по времени).
- **Внешние входы:** t0, x0, dt. **Внешние выходы:** t_final, x_final (после N шагов).

Итог: решение ОДУ (в том числе нелинейного) сводится к **гиперграфу с циклом** и блокам RHS и Step; движок выполняет N итераций, передавая состояние по рёбрам.

---

## 3. Задачи рекурсивной природы: последовательность Фибоначчи

### 3.1 Рекурсивное определение и итеративная реализация

- **Рекурсивное определение:** F(0) = 0, F(1) = 1, F(n) = F(n−1) + F(n−2) при n ≥ 2.
- Вместо программной рекурсии (вызов F(n-1) и F(n-2)) используем **итерацию с состоянием**: храним пару (F_{k-1}, F_k) и на каждом шаге переходим к (F_k, F_{k-1} + F_k). После n−1 шагов второй элемент пары есть F(n).

### 3.2 Граф с циклом для Фибоначчи

- **Узлы:**
  - **Add** — сложение двух чисел (как в EXAMPLE_ARITHMETIC): in_a, in_b → out.
  - **Shift** (или два порта «предыдущее/текущее») — блок, который на вход принимает (prev, curr) и на выход отдаёт (curr, curr + prev), т.е. «сдвиг» пары к следующей паре Фибоначчи. Либо можно обойтись без отдельного блока Shift, разведя рёбра: выход Add и «текущий» вход подать обратно на входы Add на следующей итерации (см. ниже).

- **Состояние на итерации k:** (a, b) = (F_{k-1}, F_k). Следующая пара: (b, a+b). Поэтому достаточно **одного блока Add** и передачи данных по циклу:
  - Входы Add: in_a = «первое число пары», in_b = «второе число пары».
  - Выход Add: out = in_a + in_b (= следующее число Фибоначчи).
  - Для следующей итерации нужно подать на in_a значение «второго» (бывший in_b), на in_b — значение out. Это достигается **рёбрами цикла**: (Add, out) → (Add, in_b); (тот узел/порт, который хранит «второй») → (Add, in_a). «Второй» на следующей итерации — это бывший in_b. Значит, нужно чтобы in_b на шаге k стал in_a на шаге k+1. Такое возможно, если в графе есть цикл: выход Add идёт в in_b следующей итерации, а in_b (текущий) должен идти в in_a следующей итерации. В типичной реализации один блок Add: на первой итерации in_a = F0 = 0, in_b = F1 = 1 (внешние входы); out = 1. На второй итерации in_a должно стать 1, in_b = 1 (out предыдущего шага). То есть рёбра: (внешний F0) → Add.in_a только на первом шаге; (внешний F1) → Add.in_b на первом шаге; (Add, out) → буфер для in_b на следующей итерации; и «in_a на следующей итерации» = «in_b с предыдущей итерации». Это ровно цикл с двумя «проводами»: один передаёт предыдущий in_b в in_a, другой — out в in_b. Реализуется графом с одним узлом Add и рёбрами обратной связи: (Add, in_b) → (Add, in_a) [на следующей итерации], (Add, out) → (Add, in_b) [на следующей итерации]. Тогда на шаге 1: in_a=0, in_b=1, out=1. На шаге 2: in_a=1 (старый in_b), in_b=1 (старый out), out=2. На шаге 3: in_a=1, in_b=2, out=3, и т.д. После n−1 итераций out = F(n).

- **Число итераций:** K = n − 1 (или n, если считать от 0), задаётся **num_loop_steps**.
- **Внешние входы:** начальная пара (0, 1) — например, F0 и F1. **Внешний выход:** значение с порта Add.out после последней итерации = F(n).

### 3.3 Конфигурация (схема)

- **Узлы:** один узел add (block_type: arithmetic/add).
- **Рёбра цикла:** (add, out) → (add, in_b); (add, in_b) → (add, in_a). Семантика «на следующей итерации» обеспечивается движком: буферы обновляются после каждой итерации цикла, так что на шаге k+1 узел add получает на in_a значение, которое было на in_b на шаге k, и на in_b значение, которое было на out на шаге k.
- **Внешние входы (начальные значения для первой итерации):** add.in_a = 0, add.in_b = 1.
- **Внешний выход:** add.out после последней итерации (K = n − 1).
- **План:** цикл из одного узла add, num_loop_steps = n − 1 (или n для F(n) при нумерации с 0).

Итог: **рекурсивное по определению правило Фибоначчи** реализуется на графе **без вызова функций рекурсивно** — за счёт цикла в гиперграфе и параметра num_loop_steps.

---

## 4. Общие принципы

| Задача | Роль цикла в графе | Параметр | Блоки |
|--------|---------------------|----------|--------|
| ОДУ dx/dt = f(t,x) | Один «шаг по времени» = одна итерация подграфа (RHS + Step). Состояние (t, x) передаётся по рёбрам между итерациями. | num_loop_steps = число шагов по времени | RHS (правая часть, может быть нелинейной), Step (интегратор) |
| Фибоначчи F(n) | Одна итерация = один «шаг» рекуррентности: (F_{k-1}, F_k) → (F_k, F_{k+1}). Состояние пары передаётся по рёбрам обратной связи. | num_loop_steps = n − 1 | Add (и при необходимости сдвиг пары) |

В обоих случаях движок **не знает** про ОДУ или Фибоначчи: он только выполняет план «повторить K раз заданные узлы» и передаёт данные по рёбрам. Доменная логика — в блоках (RHS, Step, Add); граф задаёт **структуру итерации** и поток данных.

---

## 5. Ссылки

| Документ | Назначение |
|----------|------------|
| [02_HYPERGRAPH_LEVEL.md](02_HYPERGRAPH_LEVEL.md) | Движок, циклы, num_loop_steps, итеративная схема плана. |
| [EXAMPLE_ARITHMETIC_AT_GRAPH_LEVEL.md](EXAMPLE_ARITHMETIC_AT_GRAPH_LEVEL.md) | Простой граф без цикла (арифметика). |
| [RECURSION_AND_HYPERGRAPH.md](RECURSION_AND_HYPERGRAPH.md) | Рекурсия и глубина композиции, делегирование run. |
