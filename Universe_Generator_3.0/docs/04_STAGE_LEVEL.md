# 04. Уровень перехода (Stage) — полная техническая спецификация

**Назначение:** глубокая и детальная **техническая документация третьего исполняемого уровня** для Universe Generator 3.0 (Yggdrasil). Документ задаёт **переход (Stage)** как **гиперграф пайплайнов**: узлы Stage — **целые пайплайны** (уровня пайплайна, фаза 3), по рёбрам Stage передаётся **state** (контейнер из пяти блоков) или его части. Описаны **state** (пять блоков, смысл в цикле мира), Stage как одна **метаморфоза** state, пайплайн как узел Stage и маппинг **state ↔ входы/выходы пайплайна**, построение Stage (API и конфиг), **условия выполнения перехода** (какие блоки state должны быть заполнены), контракт **run(Stage, state, context?) → state**, вырожденный случай (Stage из одного пайплайна), **пять переходов мира** (Философ, Автор, Среда, Архитектор, Творец) с таблицами входов/выходов и условий, сериализация и связь с уровнем мира. Это **канонический источник** технических решений уровня перехода в каноне 3.0.

**Якорь:** [Philosophy.md](../Philosophy.md) (Часть VI — переход как метаморфоза; Часть VII — state, пять блоков); [Scheme.md](../Scheme.md) §6, §7.

**Предыдущий уровень:** [03_PIPELINE_LEVEL.md](03_PIPELINE_LEVEL.md) — пайплайн (гиперграф гиперграфов, данные между задачами).

**Референс:** [../WorldGenerator_2.0/Stage_Level.md](../WorldGenerator_2.0/Stage_Level.md).

**Язык:** русский.

**Связь с планом:** [PLAN_DEVELOPMENT_CANON.md](PLAN_DEVELOPMENT_CANON.md) — фаза 4.

---

## 1. Место уровня в иерархии

| Уровень | Сущность | Что течёт по связям | Описание |
|---------|----------|---------------------|----------|
| **Уровень пайплайна** | Пайплайн — гиперграф гиперграфов | **Данные** между гиперграфами | Комбинированные задачи (текст → картинка → апскейл → видео). [03_PIPELINE_LEVEL.md](03_PIPELINE_LEVEL.md). |
| **Уровень перехода (Stage)** | **Stage** — гиперграф пайплайнов | **State** (в контексте мира) | **Одна метаморфоза** state. Stage = гиперграф пайплайнов; по рёбрам между пайплайнами внутри Stage — данные; вход/выход Stage в мир — **state**. |
| **Уровень мира** | Мир — гиперграф переходов | **State** (пять блоков) | Непрерывная цепь переходов: Философ → Автор → Среда → Архитектор → Творец. [05_WORLD_LEVEL.md](05_WORLD_LEVEL.md) (фаза 5). |

Ключевое отличие уровня перехода от пайплайна: на **пайплайне** по рёбрам передаются **сырые данные** (тензоры, изображения, текст и т.д.); на **Stage** в контексте мира по переходам передаётся **state** — структурированный контейнер слотов (пять блоков: намерение, конфигурация, артефакты, описания, нарратив). Один Stage реализует **один переход** цикла мира: одну **метаморфозу** (материя → идея, идея → материя, объект в объект).

---

## 2. State — контейнер из пяти блоков

**State** (состояние мира) — это **контейнер с фиксированными слотами (блоками)**. Он передаётся между переходами в цикле мира и претерпевает метаморфозы: каждый переход читает одни блоки и дополняет или перезаписывает другие.

### 2.1 Определение пяти блоков

| № | Блок | Смысл в цикле мира |
|---|------|---------------------|
| **1** | Описание того, что должно было произойти | Намерение; порождается в **Development of the world** (часть Среды). Вход **Архитектора**. |
| **2** | Конфигурация для генерации артефактов | План воплощения; выход Архитектора, вход **Творца**. |
| **3** | Сгенерированные артефакты | Материальный результат; выход Творца, вход **Философа**. |
| **4** | Описание сгенерированных артефактов | Идеализация материи; выход Философа, вход **Автора**. |
| **5** | Описание того, что реально произошло в мире | Нарратив последствий; выход Автора. Вход **World update** (часть Среды). |

**World update** выполняется **только при полностью заполненном state** (все пять блоков): тогда state применяется к миру (контент мира обновляется), state сохраняется. Иначе World update не выполняется.

### 2.2 Использование state на уровне Stage

- **Stage** получает на вход **state** (или его часть — подмножество блоков) и **возвращает** state (обновлённый: те же блоки плюс новые или изменённые слоты).
- **Маппинг state → inputs пайплайна:** при выполнении Stage каждый узел-пайплайн получает **inputs**, собранные из блоков state по правилу перехода (например, «блок 2 → вход `config` пайплайна Творца»).
- **Маппинг outputs пайплайна → state:** выходы пайплайна (по конфигу Stage) записываются в указанные блоки state (например, «выход `artifacts` пайплайна Творца → блок 3»).
- **Условие выполнения Stage:** переход может требовать заполненности **определённых блоков** state перед run. Например, Философ выполняется только при заполненных блоках 1, 2, 3; Автор — при 1–4; World update — только при всех пяти.

Подробные таблицы по каждому из пяти переходов мира — в §9.

---

## 3. Определение Stage (перехода)

**Stage (переход, этап)** — это **гиперграф, узлами которого являются пайплайны**. Stage реализует **одну метаморфозу** state: качественное превращение (материя → идея, идея → материя, описание → конфигурация → артефакты и т.д.). С точки зрения движка фреймворка Stage — **тот же гиперграф**: узлы = пайплайны, по рёбрам Stage между пайплайнами могут передаваться **данные** (как на уровне пайплайна); **внешний** вход и выход Stage в контексте мира — **state**.

- **Узлы Stage** — пайплайны (один или несколько). Каждый пайплайн имеет контракт run(pipeline, inputs) → outputs; входы и выходы пайплайна **маппятся** на блоки state по конфигурации Stage.
- **Рёбра Stage** (между пайплайнами): могут соединять выходы одного пайплайна с входами другого (тогда по ним текут данные, как в 03); при одном пайплайне рёбер нет — вырожденный случай. Например, в одном Stage возможны пайплайн «text-to-image → image-to-video» и следующий пайплайн из задач подключения физического движка мира и генерации видео по физической структуре мира (см. §5.4).
- **Вход Stage (по state):** какие блоки state читаются и как подаются на пайплайн(ы). **Выход Stage (по state):** какие выходы пайплайна(ов) записываются в какие блоки state.
- **Выполнение Stage:** проверить условие (заполненность нужных блоков state); если выполнено — собрать inputs для пайплайн(ов) из state, выполнить пайплайн(ы) в порядке топологии (если несколько), записать результаты в state; вернуть обновлённый state.

Таким образом, **один переход** в цикле мира (Философ, Автор, Среда, Архитектор, Творец) реализуется **одним Stage** — гиперграфом пайплайнов с явным контрактом «вход/выход по state» и опциональным условием выполнения.

---

## 4. Пайплайн как узел Stage: контракт и маппинг state

### 4.1 Контракт пайплайна (напоминание)

Пайплайн вызывается как **run(pipeline, inputs) → outputs** (03_PIPELINE_LEVEL). Входы и выходы — словари с ключами по именам внешних входов/выходов пайплайна (например, `text`, `image`, `config`, `artifacts`).

### 4.2 Маппинг state → inputs пайплайна

Для каждого **внешнего входа пайплайна** задаётся правило, откуда брать значение при run Stage:

- **Из блока state:** например, вход `config` пайплайна Творца ← блок 2 state; вход `image` ← артефакт из блока 3 (или слот артефактов).
- **Из контекста:** опционально часть inputs может приходить из **context** (мир, Action, общие параметры), а не только из state.

Конфиг Stage задаёт **state_input_map**: список или словарь (port_name пайплайна → block_index или path в state). При выполнении Stage перед вызовом run(pipeline, inputs) словарь inputs собирается по этому правилу из переданного state (и context).

### 4.3 Маппинг outputs пайплайна → state

После run(pipeline, inputs) → outputs значения из outputs записываются в state по правилу **state_output_map**: (port_name пайплайна или имя выхода Stage) → block_index (или слот внутри блока). Например: выход `artifacts` пайплайна Творца → блок 3 state; выход `description` → блок 4.

При **нескольких пайплайнах** в одном Stage выходы разных пайплайнов могут записываться в разные блоки (или в один блок по заданной политике слияния). Порядок выполнения пайплайнов задаётся топологией Stage; итоговый state после Stage — результат последовательного применения state_output_map после каждого пайплайна (или объединения выходов по конфигу).

### 4.4 Единый контракт Stage по state

- **Вход Stage:** state (словарь или объект с ключами 1–5 или именами блоков); опционально **context** (мир, Action, опции run).
- **Выход Stage:** state (тот же объект с обновлёнными блоками или новый объект state с записанными по state_output_map значениями).
- **Условие:** предикат **can_run(stage, state)** — например, «блоки 1, 2, 3 заполнены» для Философа. Если условие ложно, run не вызывается, state возвращается без изменений (или по правилу «пропуск перехода»).

---

## 5. Состав Stage: узлы, рёбра, контракт по state

### 5.1 Узлы Stage = пайплайны

- Каждый **узел Stage** — целый **пайплайн** (один или несколько гиперграфов задач). У каждого узла есть идентификатор в рамках Stage (pipeline_id или node_id).
- Пайплайн может быть задан вложенным конфигом (по спецификации 03) или ссылкой (ref на конфиг пайплайна). При загрузке Stage каждый пайплайн-узел строится из своего конфига.

### 5.2 Рёбра Stage (между пайплайнами)

- Если узлов-пайплайнов **несколько**, рёбра Stage соединяют выходы одного пайплайна с входами другого — как на уровне пайплайна, по ним текут **данные**. Тогда порядок выполнения пайплайнов задаётся топологией; данные между ними не обязательно проходят через state (можно передать выход первого пайплайна на вход второго по ребру Stage).
- **Внешний** вход Stage (в мир) и **внешний** выход Stage (в мир) — всегда **state**: что из state подаётся на первый(е) пайплайн(ы), что с последнего(их) пайплайн(ов) пишется в state.

### 5.3 Контракт Stage: state_input_map, state_output_map, condition

| Элемент | Описание |
|---------|----------|
| **state_input_map** | Маппинг «блок state (или слот) → вход пайплайна» для сбора inputs при run. Может быть задан по узлам (для какого pipeline_id какие порты берутся из каких блоков). |
| **state_output_map** | Маппинг «выход пайплайна (порт или имя) → блок state» для записи результатов в state после run. |
| **condition** | Предикат can_run(stage, state): например, список обязательных блоков [1,2,3] или функция (state) → bool. Если ложно — переход пропускается. |

Для **вырожденного** Stage (один пайплайн) state_input_map и state_output_map задают связь «state ↔ этот пайплайн». Для Stage из нескольких пайплайнов — какие блоки идут на первый(е) пайплайн(ы), какие выходы какого пайплайна пишутся в какие блоки (и при необходимости передача по рёбрам между пайплайнами данными).

### 5.4 Пример: граф пайплайнов — медиа-цепочка и видео по физике мира

В графе пайплайнов одного Stage допустимы композиции, где **первый пайплайн** реализует цепочку задач генерации медиа (например, text-to-image → image-to-video), а **следующий пайплайн** объединяет задачу **подключения физического движка мира** и задачу **генерации видео в соответствии с физической структурой мира**. Пример:

- **Пайплайн 1:** гиперграф задач «текст → изображение → видео» (text-to-image, затем image-to-video). Вход из state (например, текст/конфиг); выход — видео.
- **Пайплайн 2:** (1) узел-задача **интеграции физического движка мира** (чтение/подключение к физической модели мира, структура сцены, законы, коллизии и т.д.); (2) узел-задача **генерации видео**, согласованного с физической структурой мира (видео, которое учитывает физику мира — движение объектов, освещение, консистентность с движком). Входы второго пайплайна могут включать выход видео первого пайплайна (по ребру Stage) и/или блоки state (описание мира, конфигурация сцены); выход — финальное видео для state.

Рёбра Stage соединяют выход первого пайплайна (видео) с входом второго (при необходимости); state_input_map и state_output_map задают связь с блоками state. Таким образом, в одном переходе (Stage) можно совмещать **медиа-генерацию** и **физически согласованную генерацию** за счёт нескольких пайплайнов в графе пайплайнов Stage.

---

## 6. Построение Stage

### 6.1 Добавление узлов (пайплайнов)

- **add_node(pipeline_id, pipeline)** — добавить пайплайн как узел Stage (pipeline уже собран).
- **add_node(pipeline_id, config, registry?)** — построить пайплайн из конфига (03.from_config) и добавить как узел.

### 6.2 Добавление рёбер Stage (между пайплайнами)

- **add_edge(source_pipeline_id, source_port, target_pipeline_id, target_port)** — соединить выход одного пайплайна с входом другого (данные между пайплайнами внутри Stage). Используется, когда в одном переходе несколько пайплайнов и часть потока идёт не через state, а напрямую.

### 6.3 Задание контракта по state

- **set_state_input_map(mapping)** — задать, какие блоки state (и при необходимости context) маппятся на какие входы пайплайн(ов). Формат: словарь или список правил (block_index или path → pipeline_id, port_name).
- **set_state_output_map(mapping)** — задать, какие выходы пайплайн(ов) записываются в какие блоки state. Формат: (pipeline_id, port_name) или (port_name при одном пайплайне) → block_index или path.
- **set_condition(required_blocks)** или **set_condition(predicate)** — задать условие выполнения перехода (какие блоки должны быть заполнены или произвольный предикат от state).

### 6.4 Построение из конфига

- **Конфиг Stage:** список **pipelines** (pipeline_id, config или ref); список **edges** (source_pipeline, source_port, target_pipeline, target_port); **state_input_map**, **state_output_map**; **condition** (required_blocks: [1,2,3] или predicate); stage_id, опционально metadata.
- **from_config(config, registry?, validate?)** — построить пайплайны, добавить как узлы; добавить рёбра; установить state_input_map, state_output_map, condition. При validate — проверить совместимость (все pipeline_id существуют, порты и блоки указаны корректно).

---

## 7. Условия выполнения перехода (can_run)

**Переход выполняется** (run Stage вызывается) **только если выполнено условие** для данного Stage. Типичное условие — **заполненность определённых блоков state**.

| Тип условия | Описание |
|------------|----------|
| **required_blocks** | Список индексов блоков (например, [1, 2, 3]). run(Stage, state) выполняется только если для каждого из этих индексов соответствующий блок state не пуст (заполнен). |
| **predicate** | Функция can_run(state, context) → bool. Позволяет задать произвольную логику (например, «блок 2 имеет поле type = "generation"»). |
| **always** | Условие отсутствует или всегда true — переход выполняется при любом state (например, Development of the world). |

Если условие **не выполнено**, Stage при вызове из мира **пропускается**: state передаётся дальше без изменений (или по правилу мира — см. 05_WORLD_LEVEL). Это обеспечивает корректный порядок цикла: Философ не запускается без блоков 1–3, World update — только при полном state.

---

## 8. Планирование и выполнение Stage

### 8.1 Алгоритм run(Stage, state, context?)

1. **Проверить условие:** can_run(stage, state). Если ложно — вернуть state без изменений (или копию state).
2. **Собрать inputs** для узлов-пайплайнов по **state_input_map** (и context): для каждого пайплайна сформировать словарь inputs из указанных блоков state.
3. **Топологический порядок:** если пайплайнов несколько и есть рёбра Stage — получить порядок обхода.
4. **Выполнить пайплайн(ы):** для каждого пайплайна в порядке: подставить inputs (из state и из буферов рёбер Stage от предыдущих пайплайнов); вызвать **run(pipeline, inputs)** → outputs; записать outputs в буферы исходящих рёбер Stage и по **state_output_map** — в соответствующие блоки state.
5. **Вернуть** обновлённый state.

### 8.2 Контракт run Stage

- **Вход:** **state** (контейнер пяти блоков; может быть представлен словарём, объектом с полями 1–5 или именованными слотами); опционально **context** (мир, Action, опции).
- **Выход:** **state** — тот же контейнер с обновлёнными блоками согласно state_output_map (или без изменений, если условие не выполнено).
- **Опции:** те же, что могут пробрасываться в run пайплайнов (device, callbacks и т.д.).

---

## 9. Пять переходов мира: идеальные задачи и контракт по state

В каноне мир — **цепочка из пяти переходов**. Каждое звено реализуется **одним Stage**. Ниже — таблица идеальных задач, входов/выходов по state и условий выполнения (см. Philosophy VI, VII; Scheme §7).

### 9.1 Таблица переходов

| Переход | Идеальная задача | Вход state (блоки) | Условие выполнения | Выход state |
|---------|-------------------|--------------------|---------------------|-------------|
| **Философ** (Philosopher) | Идеализация материального. Артефакты (блок 3) → описание (блок 4). | Блоки 1, 2, 3 | **Только если заполнены 1, 2, 3.** | Блок 4 |
| **Автор** (Author) | Нарратив в контексте мира. Блок 4 → «что реально произошло» (блок 5). Контекст — неизменённый мир. | Блоки 1–4 | **Только если заполнены 1, 2, 3, 4.** | Блок 5 |
| **Среда** (Environment) | (1) World update — применение state к миру при полном state; (2) Development of the world — новый state с блоком 1. | State; опционально Action | **World update — только при всех 5 блоках.** Development — **безусловно**. | Новый state с блоком 1 (после Development) |
| **Архитектор** (Architect) | Идея → техническая структура. Блок 1 → конфигурация (блок 2). Контекст — изменённый мир. | Блок 1 | По потоку цикла **всегда** state с блоком 1. | Блок 2 |
| **Творец** (Creator) | Конфигурация → материя. Блок 2 → артефакты (блок 3). | Блок 2 | По потоку **всегда** state с блоком 2. | Блок 3 |

### 9.2 Среда как два узла

**Среда** в графе мира — **два последовательных перехода** (или один Stage с двумя «подшагами»):

1. **World update** — выполняется **только если state полностью заполнен** (все 5 блоков). Применить state к миру, обновить контент мира, сохранить state. Иначе — пропуск.
2. **Development of the world** — выполняется **безусловно**. Читает мир; с учётом Action (если передан) или без него генерирует описание следующего шага (блок 1). Выход — **новый state** с заполненным **только блоком 1** (остальные могут быть пусты или не передаваться в следующий виток по правилу мира).

После Development новый state идёт в **Архитектор → Творец → Философ → Автор → Среда** — цикл повторяется.

### 9.3 Первая итерация

**Если пользователь не передал state** (или передал пустой): на **первой итерации** пропускаются **Философ**, **Автор** и **World update**. Цикл **начинается с Development of the world** — он создаёт **первый state** (блок 1); затем state идёт в Архитектор → Творец → Философ → Автор → Среда. Логика первой итерации относится к уровню **мира** (05_WORLD_LEVEL); на уровне Stage достаточно того, что у перехода есть условие can_run и что Development задаётся как переход с условием «always».

---

## 10. Вырожденный случай: Stage из одного пайплайна

- **Stage может состоять из одного пайплайна.** Тогда у Stage один узел; рёбер между пайплайнами нет. Контракт Stage: state_input_map задаёт, какие блоки state подаются на входы этого пайплайна; state_output_map — куда записать выходы пайплайна в state. run(Stage, state) по сути: проверить condition → собрать inputs из state → run(pipeline, inputs) → записать outputs в state → вернуть state.
- **Типичный случай в цикле мира:** каждый из пяти переходов (Философ, Автор, Архитектор, Творец) часто реализуется **одним пайплайном** (например, Творец — один пайплайн «конфиг → артефакты»). Среда — либо один Stage с двумя внутренними «подшагами» (World update + Development), либо два отдельных Stage в цепочке мира.

---

## 11. Сериализация уровня Stage

### 11.1 Конфиг Stage

- **Структура конфига:** список **pipelines** (pipeline_id, конфиг пайплайна — вложенный по 03 — или ref); список **edges** (source_pipeline, source_port, target_pipeline, target_port); **state_input_map**; **state_output_map**; **condition** (required_blocks или ссылка на предикат); schema_version, stage_id, опционально metadata.
- При загрузке по конфигу каждый пайплайн строится из своего конфига (03.from_config); восстанавливаются рёбра, state_input_map, state_output_map, condition.

### 11.2 Чекпоинт Stage

- Stage **не имеет своего отдельного state_dict** — состояние распределено по пайплайнам-узлам. **Чекпоинт Stage** — совокупность чекпоинтов всех входящих в него пайплайнов (словарь pipeline_id → чекпоинт пайплайна, или директория по pipeline_id).
- Сохранение/загрузка: по тем же правилам, что для пайплайна (03 §10): сохранить чекпоинт каждого пайплайна; при загрузке Stage восстановить пайплайны и загрузить их чекпоинты.

### 11.3 Полное сохранение/загрузка

- **Сохранить:** конфиг Stage (config.json / config.yaml) + чекпоинты всех пайплайнов (save_dir/pipeline_1/, … или checkpoint по pipeline_id). **Загрузить:** прочитать конфиг, построить Stage (пайплайны из конфигов), загрузить чекпоинты в пайплайны.

---

## 12. Связь с уровнем мира (World)

- **Мир (World)** — гиперграф, узлами которого являются **переходы (Stage)**. Порядок выполнения фиксирован: Философ → Автор → Среда → Архитектор → Творец → … По рёбрам мира передаётся **state** (пять блоков). Каждый узел мира — один Stage; при выполнении мира state последовательно передаётся в run(Stage, state); после каждого перехода state обновляется и передаётся следующему. Спецификация мира: [05_WORLD_LEVEL.md](05_WORLD_LEVEL.md).
- Условия выполнения переходов (пропуск Философа/Автора/World update при неполном state), первая итерация (старт с Development), Action — задаются на уровне **мира** при обходе цепочки Stage; уровень Stage предоставляет только контракт run(Stage, state) и can_run(stage, state).

---

## 13. Отличия от WG 2.0 и совпадения

| Аспект | WG 2.0 | Канон 3.0 (уровень Stage) |
|--------|--------|----------------------------|
| **Определение** | Stage — граф пайплайнов, один переход. | Stage — **гиперграф** пайплайнов; терминология 3.0 — гиперграф везде. |
| **Узлы** | Пайплайны (графы графов). | То же; узлы = пайплайны (03). |
| **Поток** | Между переходами в мире — state. | То же; по рёбрам Stage между пайплайнами — данные; вход/выход Stage в мир — state. |
| **Контракт** | Вход/выход по state. | Явный **state_input_map**, **state_output_map**, **condition** (can_run). |
| **Пять переходов** | Философ, Автор, Среда, Архитектор, Творец; таблицы по входам/выходам. | То же; зафиксировано в §9 с условиями и идеальными задачами. |

Итог: уровень Stage 3.0 **совместим по духу** с WG 2.0 Stage_Level; добавлены явный маппинг state ↔ пайплайн и формализация условия выполнения.

---

## 14. Сводные таблицы

### 14.1 Уровень Stage (кратко)

| Понятие | Определение |
|---------|-------------|
| **Stage (переход)** | Гиперграф пайплайнов, реализующий **одну метаморфозу** state. Вход/выход в контексте мира — **state** (пять блоков). |
| **Третий исполняемый уровень** | run(Stage, state, context?) → state; условие can_run(stage, state); маппинг state ↔ inputs/outputs пайплайн(ов). |
| **State** | Контейнер из **пяти блоков** (намерение, конфигурация, артефакты, описание артефактов, нарратив). Течёт между переходами в мире. |
| **Построение** | add_node(pipeline), add_edge(…), set_state_input_map, set_state_output_map, set_condition; или from_config(config). |
| **Вырожденный случай** | Stage из одного пайплайна; контракт по state задаётся маппингом для этого пайплайна. |
| **Выше** | Мир = гиперграф переходов; по рёбрам — state. [05_WORLD_LEVEL.md](05_WORLD_LEVEL.md). |

### 14.2 Пайплайн и Stage

| Аспект | Пайплайн | Stage |
|--------|----------|-------|
| **Узлы** | Гиперграфы задач. | Пайплайны. |
| **По рёбрам (внутри)** | Данные между гиперграфами. | Данные между пайплайнами (при нескольких узлах). |
| **Внешний вход/выход** | inputs / outputs (словари данных). | **state** (пять блоков); маппинг state ↔ пайплайн. |
| **Условие run** | Нет (всегда выполним при заданных inputs). | **can_run(stage, state)** — опционально пропуск перехода. |

---

## 15. Критерии завершения фазы 4 (напоминание)

- Документ docs/04_STAGE_LEVEL.md создан. ✓
- State (пять блоков) и Stage (гиперграф пайплайнов, контракт по state, state_input_map, state_output_map, condition) реализованы.
- Контракт run(Stage, state) → state; при невыполненном условии — возврат state без изменений (или пропуск по правилу мира).
- Пример Stage с state выполняется (например, переход-заглушка «блок 1 → блок 2» или минимальная метаморфоза).
- Соответствие Philosophy и Scheme сохранено.

---

## 16. Ссылки

| Документ | Назначение |
|----------|------------|
| [Philosophy.md](../Philosophy.md) | Часть VI — переход как метаморфоза; Часть VII — state, пять блоков, Среда, цикл мира. |
| [Scheme.md](../Scheme.md) | §6 — уровень перехода (Stage); §7 — мир, state, цикл, условия, первая итерация. |
| [03_PIPELINE_LEVEL.md](03_PIPELINE_LEVEL.md) | Пайплайн как узел Stage; данные между задачами. |
| [05_WORLD_LEVEL.md](05_WORLD_LEVEL.md) | Мир = гиперграф переходов; state по цепочке; условия выполнения. |
| [PLAN_DEVELOPMENT_CANON.md](PLAN_DEVELOPMENT_CANON.md) | Фаза 4 — цели, документация, реализация, критерии. |
| [../WorldGenerator_2.0/Stage_Level.md](../WorldGenerator_2.0/Stage_Level.md) | Уровень перехода в WG 2.0. |

---

**Итог.** Настоящий документ — **полная и глубокая техническая спецификация уровня перехода (Stage)** для Universe Generator 3.0. В нём заданы **state** (пять блоков, смысл в цикле мира), **Stage** как гиперграф пайплайнов с одной метаморфозой state, маппинг **state ↔ входы/выходы пайплайна** (state_input_map, state_output_map), условия выполнения перехода (can_run), контракт **run(Stage, state) → state**, вырожденный случай (один пайплайн), **пять переходов мира** (Философ, Автор, Среда, Архитектор, Творец) с таблицами и условиями, сериализация и связь с уровнем мира. Реализация фазы 4 и уровень мира (фаза 5) опираются на эту спецификацию.
