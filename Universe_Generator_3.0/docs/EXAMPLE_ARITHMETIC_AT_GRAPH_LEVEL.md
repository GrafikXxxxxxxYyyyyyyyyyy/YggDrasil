# Пример: арифметические задачи на уровне графа

**Назначение:** показать на **простом примере**, как решать **арифметические задачи** на **уровне гиперграфа задачи** (фаза 2): узлы = блоки с портами, рёбра = поток данных, внешние входы/выходы гиперграфа, вызов **run(hypergraph, inputs) → outputs**. Пример не требует нейросетей или тяжёлых моделей — достаточно блоков, реализующих элементарные операции (сложение, умножение), чтобы проиллюстрировать работу движка и контракта.

**Якорь:** [02_HYPERGRAPH_LEVEL.md](02_HYPERGRAPH_LEVEL.md), [00_FOUNDATION.md](00_FOUNDATION.md).

**Язык:** русский.

---

## 1. Идея примера

Вычислить выражение **(a + b) · c** с помощью гиперграфа:

- **Узлы** — два блока: «сложение» (Add) и «умножение» (Mul).
- **Рёбра** — выход Add подаётся на один из входов Mul; входы a, b подаются на Add; вход c подаётся на второй вход Mul.
- **Внешние входы гиперграфа:** a, b, c. **Внешний выход:** result = (a + b) · c.

Движок гиперграфа выполняет топологический обход (сначала Add, затем Mul), передаёт данные по рёбрам и возвращает результат. Так арифметическая задача решается **на уровне графа** без отдельной «арифметической подсистемы» — только блоки и гиперграф по канону.

---

## 2. Блоки (узлы-задачи)

Минимальный контракт блока: **входные порты**, **выходные порты**, **run(inputs) → outputs**.

### 2.1 Блок Add (сложение)

| Порт   | Направление | Тип   | Описание        |
|--------|-------------|--------|-----------------|
| in_a   | вход        | number | Первое слагаемое |
| in_b   | вход        | number | Второе слагаемое |
| out    | выход       | number | Сумма in_a + in_b |

**run(inputs):** `return {"out": inputs["in_a"] + inputs["in_b"]}`

### 2.2 Блок Mul (умножение)

| Порт   | Направление | Тип   | Описание          |
|--------|-------------|--------|-------------------|
| in_a   | вход        | number | Первый сомножитель |
| in_b   | вход        | number | Второй сомножитель |
| out    | выход       | number | Произведение in_a * in_b |

**run(inputs):** `return {"out": inputs["in_a"] * inputs["in_b"]}`

Оба блока регистрируются в реестре типов (например, `block_type: "arithmetic/add"` и `"arithmetic/mul"`). Для примера можно реализовать их как простые функции или классы с методами `get_input_ports()`, `get_output_ports()`, `run(inputs)`.

---

## 3. Гиперграф для (a + b) · c

### 3.1 Узлы

| node_id | block_type     | Описание                          |
|---------|----------------|-----------------------------------|
| add     | arithmetic/add | Сложение двух чисел               |
| mul     | arithmetic/mul | Умножение двух чисел              |

### 3.2 Рёбра (поток данных)

| Источник        | Порт | Приёмник | Порт  |
|-----------------|------|----------|--------|
| (внешний вход)  | a    | add      | in_a   |
| (внешний вход)  | b    | add      | in_b   |
| (внешний вход)  | c    | mul      | in_b   |
| add             | out  | mul      | in_a   |

То есть: a и b подаются на блок add; результат add (a + b) подаётся на первый вход mul; c подаётся на второй вход mul; выход mul — итог (a + b) · c.

### 3.3 Внешние входы и выходы гиперграфа

- **exposed_inputs:** (add, in_a) с именем "a", (add, in_b) с именем "b", (mul, in_b) с именем "c".
- **exposed_outputs:** (mul, out) с именем "result".

При вызове **run(hypergraph, inputs)** словарь inputs должен содержать ключи "a", "b", "c" (числа). Возвращаемый словарь outputs содержит ключ "result" — число (a + b) · c.

### 3.4 Порядок выполнения

Топологический порядок: сначала **add** (у него нет входящих рёбер от других узлов, только внешние a, b), затем **mul** (входящие рёбра: add.out и внешний c). Движок: инициализирует буферы для внешних входов a, b, c; выполняет add → записывает add.out в буфер ребра (add, out) → (mul, in_a); выполняет mul (входы из буферов и внешний c); считывает mul.out во внешний выход "result".

---

## 4. Пример вызова

```text
inputs  = {"a": 1, "b": 2, "c": 3}
outputs = run(hypergraph, inputs)
# outputs["result"] == (1 + 2) * 3 == 9
```

Проверка: a=1, b=2, c=3 → add выдаёт 3 → mul получает 3 и 3 → result = 9.

---

## 5. Конфиг гиперграфа (структура)

Пример конфига в виде структуры (YAML или JSON):

```yaml
graph_id: "arithmetic_example"
nodes:
  - node_id: add
    block_type: arithmetic/add
    config: {}
  - node_id: mul
    block_type: arithmetic/mul
    config: {}

edges:
  - source_node: add
    source_port: out
    target_node: mul
    target_port: in_a

exposed_inputs:
  - node_id: add
    port_name: in_a
    name: a
  - node_id: add
    port_name: in_b
    name: b
  - node_id: mul
    port_name: in_b
    name: c

exposed_outputs:
  - node_id: mul
    port_name: out
    name: result
```

Замечание: в каноне рёбра от «внешнего входа» к узлу задаются не отдельным ребром из виртуального узла, а тем, что порты add.in_a, add.in_b, mul.in_b объявлены как внешние входы гиперграфа; при run значения из словаря inputs подаются на эти порты. Поэтому в списке edges только ребро add → mul. Построение гиперграфа: **from_config(config, registry)** создаёт узлы add и mul, добавляет ребро (add, out) → (mul, in_a), регистрирует exposed_inputs и exposed_outputs.

---

## 6. Второй пример: цепочка из трёх операций

Вычислить **a + b + c** (или **a · b + c**) — цепочка из нескольких узлов.

**Вариант a + b + c:**

- Узлы: add1 (a + b), add2 (результат add1 + c).
- Рёбра: (внеш. a) → add1.in_a, (внеш. b) → add1.in_b; add1.out → add2.in_a, (внеш. c) → add2.in_b.
- Внешние входы: a, b, c (на add1.in_a, add1.in_b, add2.in_b). Внешний выход: add2.out → "result".

**Порядок выполнения:** add1, затем add2. run(hypergraph, {"a": 1, "b": 2, "c": 3}) → {"result": 6}.

Тот же принцип: любое арифметическое выражение, представимое DAG операций, собирается из блоков-операций и рёбер; движок обходит граф и передаёт данные по рёбрам. Арифметика — лишь один из типов блоков в реестре; уровень графа остаётся универсальным.

---

## 7. Сводка

| Элемент        | В примере                                      |
|----------------|-------------------------------------------------|
| **Уровень**    | Гиперграф задачи (02) — узлы = блоки-задачи.   |
| **Узлы**       | Add, Mul (блоки с портами и run).               |
| **Рёбра**      | Поток чисел от выходов к входам узлов.          |
| **Внешние I/O**| inputs: a, b, c; outputs: result.               |
| **Движок**     | Топологический порядок, буферы, run узлов.      |
| **Контракт**   | run(hypergraph, inputs) → outputs.              |

Арифметические задачи на уровне графа решаются **без исключений** из канона: те же правила «блок → узел», те же рёбра и exposed_inputs/exposed_outputs, тот же движок. Блоки арифметики — такие же блоки реестра, как Backbone или Solver; разница только в реализации run (сложение/умножение вместо диффузии или LLM).

---

## 8. Ссылки

| Документ | Назначение |
|----------|------------|
| [00_FOUNDATION.md](00_FOUNDATION.md) | Блок, узел, порты, гиперграф, исполнитель. |
| [02_HYPERGRAPH_LEVEL.md](02_HYPERGRAPH_LEVEL.md) | Уровень гиперграфа задачи, построение, движок, run. |
| [01_ABSTRACT_TASK_BLOCKS.md](01_ABSTRACT_TASK_BLOCKS.md) | Типы блоков-задач, контракты портов, реестр. |
