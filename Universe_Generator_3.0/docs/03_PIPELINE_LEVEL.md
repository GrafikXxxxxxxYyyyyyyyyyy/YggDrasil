# 03. Уровень пайплайна — полная техническая спецификация

**Назначение:** глубокая и детальная **техническая документация второго исполняемого уровня** для Universe Generator 3.0 (Yggdrasil). Документ задаёт **пайплайн** как **гиперграф гиперграфов**: узлы пайплайна — **целые гиперграфы задач** (уровня гиперграфа, фаза 2), по гиперрёбрам пайплайна передаются **данные** между выходами одного гиперграфа и входами другого. Описаны состав пайплайна (узлы-гиперграфы, рёбра, внешние входы/выходы пайплайна), гиперграф как узел и его контракт, построение (API и конфиг), валидация, планирование и выполнение (та же модель гиперграфового движка), контракт run пайплайна, **вырожденный случай** (пайплайн из одного гиперграфа), сериализация и связь с уровнем перехода (Stage). Это **канонический источник** технических решений уровня пайплайна в каноне 3.0.

**Якорь:** [Philosophy.md](../Philosophy.md) (п. 5.4); [Scheme.md](../Scheme.md) §5.

**Предыдущий уровень:** [02_HYPERGRAPH_LEVEL.md](02_HYPERGRAPH_LEVEL.md) — гиперграф задачи (узлы = блоки-задачи, внешние входы/выходы).

**Референс:** [../WorldGenerator_2.0/Pipeline_Level.md](../WorldGenerator_2.0/Pipeline_Level.md).

**Язык:** русский.

**Связь с планом:** [PLAN_DEVELOPMENT_CANON.md](PLAN_DEVELOPMENT_CANON.md) — фаза 3.

---

## 1. Место уровня в иерархии

| Уровень | Сущность | Описание |
|---------|----------|----------|
| **Уровень гиперграфа** | Гиперграф, узлы которого — блоки-задачи | Один гиперграф = **одна цельная задача**; по рёбрам — данные между портами. [02_HYPERGRAPH_LEVEL.md](02_HYPERGRAPH_LEVEL.md). |
| **Уровень пайплайна** | **Пайплайн** — гиперграф, узлы которого — **гиперграфы задач** | **Второй исполняемый уровень:** комбинированные сценарии — цепочка или ветвление из нескольких задач; по рёбрам пайплайна передаются **данные между задачами**. |
| **Уровень перехода (Stage)** | Гиперграф пайплайнов (узлы = пайплайны) | Один переход = одна метаморфоза; по рёбрам передаётся **state**. [04_STAGE_LEVEL.md](04_STAGE_LEVEL.md) (фаза 4). |

Пайплайн **не разбивает** одну задачу на куски (текст, диффузия, декодирование — всё внутри одного гиперграфа задачи). Пайплайн **соединяет готовые задачи** (каждая = один гиперграф) в сложный сценарий: текст → картинка → апскейл → видео и т.д.

---

## 2. Определение пайплайна

**Пайплайн (Pipeline)** — это **гиперграф, узлами которого являются целые гиперграфы** (гиперграфы уровня задачи из фазы 2). С точки зрения движка фреймворка пайплайн — **тот же гиперграф**: та же структура (узлы, гиперрёбра, внешние входы/выходы), тот же принцип планирования (топологический порядок), та же семантика run (собрать входы по рёбрам, вызвать run узла, раздать выходы по рёбрам). Меняется только **содержимое узла**: узел пайплайна — не блок, а **гиперграф**, который сам выполняется своим run(hypergraph, inputs) → outputs. Таким образом, **гиперграфовый движок** (02 §6) применяется на уровне пайплайна без смены модели: узлы = гиперграфы, по рёбрам = данные между внешними выходами одного гиперграфа и внешними входами другого.

- **Узлы пайплайна** — целые гиперграфы (каждый гиперграф = одна задача: text-to-image, upscale, image-to-video, агент с инструментами и т.д.). Узлов может быть **один или несколько**.
- **Рёбра пайплайна** — связи между **внешним выходом** одного гиперграфа и **внешним входом** другого (или с внешним входом/выходом самого пайплайна). Формат ребра: (source_graph_id, source_port_name) → (target_graph_id, target_port_name), где порты — внешние порты соответствующих гиперграфов (exposed_outputs источника, exposed_inputs приёмника).
- **Выполнение пайплайна** — в порядке топологии выполнять **целые гиперграфы**; на каждом шаге вызывать run(hypergraph, inputs) для гиперграфа-узла, где inputs собираются из буферов входящих рёбер пайплайна (и из внешних входов пайплайна для графов без входящих рёбер); выходы гиперграфа записываются в буферы исходящих рёбер пайплайна (и во внешние выходы пайплайна).

---

## 3. Гиперграф как узел пайплайна: контракт и чёрный ящик

### 3.1 Внешний интерфейс гиперграфа (граф-порты)

Каждый гиперграф уровня задачи объявляет **внешние входы и выходы** (exposed_inputs, exposed_outputs) — см. [02_HYPERGRAPH_LEVEL.md](02_HYPERGRAPH_LEVEL.md) §3.3, §4.3. Это и есть **контракт задачи**: имена и типы входов/выходов, по которым гиперграф вызывается извне.

- **Входы гиперграфа** — то, что нужно задать для задачи (текст для text-to-image, изображение для upscale или image-to-video, prompt для агента и т.д.). При вызове run(hypergraph, inputs) значения из словаря inputs подаются на эти порты.
- **Выходы гиперграфа** — результат задачи (изображение, видео, латенты, response агента и т.д.). run возвращает словарь outputs с этих портов.

Пайплайн **соединяет** выход одного гиперграфа с входом другого по этим портам; внутреннее устройство гиперграфа (узлы-задачи, рёбра, агентный цикл внутри) для пайплайна **не важно** — только контракт.

### 3.2 Примеры гиперграфов как единиц (одна задача = один гиперграф)

| Гиперграф (задача) | Внешние входы | Внешние выходы |
|--------------------|---------------|-----------------|
| **text-to-image** | text (или prompt) | image |
| **upscale** | image (низкое разрешение) | image (высокое разрешение) |
| **image-to-video** | image | video |
| **image-to-image** | image, опционально condition | image |
| **Агент с инструментами** | prompt (и опционально context) | response |

Пайплайн соединяет, например: выход `image` графа text-to-image → вход `image` графа upscale; выход `image` графа upscale → вход `image` графа image-to-video. Итог пайплайна: текст → видео (через промежуточные изображения).

---

## 4. Состав пайплайна: узлы, рёбра, внешние входы/выходы пайплайна

### 4.1 Узлы пайплайна = гиперграфы

- Каждый **узел пайплайна** — целый **гиперграф** одной задачи. У каждого такого узла есть идентификатор в рамках пайплайна (например, `graph_id` или имя узла: `text2img`, `upscale`, `img2video`), чтобы задавать рёбра между выходами и входами гиперграфов.
- Гиперграф может быть задан **в конфиге пайплайна** (вложенный конфиг: nodes, edges, exposed_inputs, exposed_outputs по спецификации уровня гиперграфа) или **ссылкой** (путь к конфигу графа, идентификатор в реестре графов). При загрузке пайплайна каждый гиперграф-узел строится из своего конфига (через реестр блоков и контракт уровня гиперграфа).

### 4.2 Рёбра пайплайна

- **Ребро пайплайна** соединяет **внешний выход одного гиперграфа** с **внешним входом другого** (или с внешним выходом пайплайна). Формат: (source_graph_id, source_port_name) → (target_graph_id, target_port_name). Типы и семантика портов должны совпадать: то, что один гиперграф выдаёт по данному порту, подходит как вход другому по указанному порту.
- **Внешние входы пайплайна:** порты гиперграфов (или одного гиперграфа), не имеющие входящих рёбер от других гиперграфов — они получают данные извне при вызове run(pipeline, inputs). Задаются списком (graph_id, port_name) с опциональным именем для словаря inputs.
- **Внешние выходы пайплайна:** порты гиперграфов, с которых снимается итоговый результат пайплайна. Задаются списком (graph_id, port_name) с опциональным именем для словаря outputs.

Таким образом, пайплайн — **гиперграф над гиперграфами**: вершины — целые гиперграфы, рёбра — потоки данных между их внешними входами/выходами.

### 4.3 Единая форма: тот же движок

С точки зрения **гиперграфового движка** (02 §6) пайплайн — гиперграф, у которого «блок» в узле — это **гиперграф**: у него есть get_input_ports() / get_output_ports() (внешние порты гиперграфа) и run(inputs) → outputs (выполнение гиперграфа). Планировщик строит порядок обхода узлов пайплайна по топологии рёбер; исполнитель для каждого узла вызывает run(hypergraph, inputs), подставляя входы из буферов рёбер пайплайна. Буферы на рёбрах пайплайна хранят **данные между задачами** (например, тензор изображения, передаваемый от text-to-image к upscale). Никакой новой «логики пайплайна» в движке не требуется — только интерпретация узла как гиперграфа и вызов его run.

---

## 5. Построение пайплайна

### 5.1 Добавление узлов (гиперграфов)

- **add_node(node_id, hypergraph)** — добавить гиперграф как узел пайплайна с заданным node_id (или graph_id). Гиперграф уже собран и имеет объявленные exposed_inputs и exposed_outputs.
- **add_node(node_id, config, registry?)** — построить гиперграф из конфига (по спецификации 02: from_config для гиперграфа) и добавить как узел. Конфиг — полный конфиг гиперграфа (nodes, edges, exposed_inputs, exposed_outputs).
- Узлов может быть один (вырожденный пайплайн) или несколько.

### 5.2 Добавление рёбер пайплайна

- **add_edge(source_graph_id, source_port, target_graph_id, target_port)** — соединить внешний выход гиперграфа source_graph_id (порт source_port) с внешним входом гиперграфа target_graph_id (порт target_port). Оба гиперграфа должны быть узлами пайплайна; оба порта должны входить в exposed_outputs источника и exposed_inputs приёмника соответственно.
- Для связи с **внешним миром** пайплайна: внешние входы пайплайна — это порты гиперграфов, на которые не ведут рёбра от других гиперграфов (они заполняются из словаря inputs при run). Внешние выходы пайплайна — порты, объявленные как выходы пайплайна (значения с них попадают в словарь outputs при run).

### 5.3 Объявление внешних входов/выходов пайплайна

- **expose_input(graph_id, port_name, name?)** — пометить порт гиперграфа graph_id как внешний вход пайплайна (данные приходят из inputs при вызове run(pipeline, inputs)).
- **expose_output(graph_id, port_name, name?)** — пометить порт гиперграфа graph_id как внешний выход пайплайна (значение попадает в outputs).
- Обычно внешние входы пайплайна — входы «первого» по топологии гиперграфа(ов); внешние выходы — выходы «последнего» гиперграфа(ов). При ветвлении может быть несколько входов/выходов.

### 5.4 Построение из конфига

- **Конфиг пайплайна:** список **graphs** (каждый элемент — конфиг гиперграфа или ссылка на конфиг: node_id/graph_id, config или ref), список **edges** пайплайна ({source_graph, source_port, target_graph, target_port}), **exposed_inputs**, **exposed_outputs** пайплайна (списки {graph_id, port_name, name?}). Опционально: pipeline_id, metadata.
- **from_config(config, registry?, validate?)** — для каждого элемента graphs построить гиперграф (из вложенного config или по ref), добавить как узел; добавить рёбра пайплайна; восстановить exposed_inputs/exposed_outputs пайплайна. При validate=True выполнить валидацию пайплайна (см. §6).

---

## 6. Валидация пайплайна

Перед выполнением или сериализацией рекомендуется проверять:

| Проверка | Описание |
|----------|----------|
| **Существование узлов и портов** | Все graph_id в рёбрах пайплайна и в exposed_inputs/exposed_outputs пайплайна существуют в множестве узлов пайплайна. Все port_name соответствуют внешним портам соответствующих гиперграфов (exposed_inputs, exposed_outputs уровня гиперграфа). |
| **Совместимость типов на рёбрах** | Тип данных внешнего выхода источника (по контракту гиперграфа) совместим с типом внешнего входа приёмника. |
| **Топология** | Топологическая сортировка возможна (нет циклов на уровне пайплайна; циклы допустимы только внутри гиперграфа-узла). При наличии циклов между гиперграфами нужна отдельная семантика (итерация пайплайна); в базовом описании пайплайн — DAG по узлам-гиперграфам. |
| **Внешние входы/выходы** | Каждый объявленный внешний вход пайплайна — порт какого-то гиперграфа; каждый внешний выход — порт какого-то гиперграфа. |

Валидация возвращает список ошибок и предупреждений; при строгом режиме run не выполняется при наличии ошибок.

---

## 7. Планирование и выполнение пайплайна

### 7.1 Топологический порядок

- Пайплайн как гиперграф допускает **топологическую сортировку** узлов (гиперграфов): порядок такой, что перед выполнением гиперграфа все его входящие рёбра пайплайна уже заполнены результатами предыдущих гиперграфов (или внешними входами пайплайна).
- Планировщик (тот же принцип, что в 02 §6): по рёбрам пайплайна строится порядок обхода узлов-гиперграфов; кэш плана и инвалидация при изменении структуры пайплайна — по той же схеме (execution_version).

### 7.2 Буферы на рёбрах пайплайна

- Во время run(pipeline, inputs) каждому ребру пайплайна (или каждой паре (target_graph_id, target_port)) сопоставляется **буфер**: значение, переданное с (source_graph_id, source_port). Внешние входы пайплайна инициализируются из словаря inputs; по мере выполнения гиперграфов их выходы записываются в буферы исходящих рёбер пайплайна.
- **Разрешение входов** для гиперграфа-узла: собрать по входящим рёбрам пайплайна значения из буферов (и для портов, помеченных как внешние входы пайплайна, — из inputs). Сформировать словарь inputs для run(hypergraph, inputs). **Запись выходов:** после run(hypergraph, inputs) → outputs записать значения выходных портов гиперграфа в буферы исходящих рёбер пайплайна (и во внешние выходы пайплайна).

### 7.3 Алгоритм выполнения (псевдо)

1. По структуре пайплайна получить порядок обхода узлов-гиперграфов (топологическая сортировка).
2. Инициализировать буферы: для каждого внешнего входа пайплайна записать значение из словаря inputs.
3. Для каждого гиперграфа в порядке обхода: собрать входы гиперграфа из буферов входящих рёбер пайплайна и внешних входов пайплайна; вызвать **run(hypergraph, inputs)** → outputs; записать outputs в буферы исходящих рёбер пайплайна и при необходимости во внешние выходы пайплайна.
4. Собрать словарь outputs пайплайна из буферов по списку exposed_outputs пайплайна.
5. Вернуть outputs.

---

## 8. Контракт run пайплайна

- **Вход:** словарь **inputs** — значения для внешних входов пайплайна (имена или (graph_id, port_name)). Данные в формате, ожидаемом соответствующими гиперграфами (тензоры, словари, строки и т.д.).
- **Выход:** словарь **outputs** — значения с внешних выходов пайплайна после выполнения всех гиперграфов в порядке топологии.
- **Опции run:** те же, что могут передаваться в run гиперграфа (training, device и т.д.), при необходимости пробрасываются в run каждого гиперграфа-узла.

Пайплайн вызывается извне как **единая комбинированная задача**: run(pipeline, inputs) → outputs. Вышестоящий уровень (переход, Stage) может использовать пайплайн как узел: тогда по рёбрам Stage передаётся уже **state**, а не сырые данные между графами (см. 04_STAGE_LEVEL).

---

## 9. Вырожденный случай: пайплайн из одного гиперграфа

- **Пайплайн может состоять из одного гиперграфа.** Тогда у пайплайна один узел; рёбер между гиперграфами нет. Внешние входы пайплайна = внешние входы этого гиперграфа; внешние выходы пайплайна = внешние выходы этого гиперграфа. run(pipeline, inputs) по сути делегирует run(hypergraph, inputs) и возвращает те же outputs.
- **Зачем:** единый интерфейс «вход/выход пайплайна» для одной задачи удобен на уровне **перехода (Stage)**: Stage мира может быть реализован как гиперграф пайплайнов, где каждый узел — пайплайн (в том числе вырожденный — одна задача). Тогда между этапами передаётся state; внутри этапа пайплайн вызывается с частью state и возвращает результат в state. Вырожденный пайплайн даёт единообразие: и «одна задача», и «цепочка задач» представлены как пайплайн.

---

## 10. Сериализация уровня пайплайна

### 10.1 Конфиг пайплайна

- **Структура конфига:** список узлов-гиперграфов (каждый узел: graph_id, конфиг гиперграфа — вложенный объект с nodes, edges, exposed_inputs, exposed_outputs по 02 — или ссылка ref на отдельный файл конфига); список рёбер пайплайна (source_graph, source_port, target_graph, target_port); exposed_inputs и exposed_outputs пайплайна (graph_id, port_name, name?); schema_version, pipeline_id, опционально metadata.
- При загрузке по конфигу каждый гиперграф строится из своего конфига (02.from_config); затем собираются рёбра пайплайна и внешние входы/выходы пайплайна.

### 10.2 Чекпоинт пайплайна

- Пайплайн **не имеет своего отдельного state_dict** — состояние распределено по гиперграфам-узлам. **Чекпоинт пайплайна** — это совокупность чекпоинтов всех входящих в него гиперграфов (например, словарь graph_id → state_dict гиперграфа, или директория с поддиректориями по graph_id, в каждой — checkpoint гиперграфа).
- Сохранение: для каждого узла-гиперграфа сохранить его чекпоинт (по правилам 02). Загрузка: после построения пайплайна из конфига загрузить чекпоинт каждого гиперграфа в соответствующий узел.

### 10.3 Полное сохранение/загрузка

- **Сохранить:** записать конфиг пайплайна (config.json или config.yaml) и чекпоинты всех гиперграфов (например, save_dir/graph_1/, save_dir/graph_2/, … или один файл checkpoint.json с ключами graph_id). **Загрузить:** прочитать конфиг, построить пайплайн (гиперграфы из конфигов), загрузить чекпоинты в гиперграфы.

---

## 11. Примеры пайплайнов

| Сценарий | Узлы пайплайна (гиперграфы) | Рёбра пайплайна | Внешние входы/выходы пайплайна |
|----------|-----------------------------|-----------------|---------------------------------|
| **Текст → видео** | 1) text-to-image, 2) upscale, 3) image-to-video | out(1, image) → in(2, image); out(2, image) → in(3, image) | Вход: text (граф 1). Выход: video (граф 3). |
| **Аутпейнтинг → апскейл → image-to-image → image-to-video** | Четыре гиперграфа (outpainting, upscale, image-to-image, image-to-video) | Цепочка по портам image. | Входы: первый граф. Выходы: последний граф (video). |
| **Вырожденный** | Один гиперграф (например, text-to-image) | Нет внутренних рёбер. | Входы/выходы пайплайна = входы/выходы этого гиперграфа. |

Общий принцип: на уровне **гиперграфа** выполняются **цельные задачи** (одна цель = один гиперграф). На уровне **пайплайна** пользователь комбинирует **гиперграфы этих задач**, получая сложные цепочки или ветвления.

---

## 12. Связь с уровнем перехода (Stage)

- **Переход (Stage)** — гиперграф, узлами которого являются **пайплайны** (см. [04_STAGE_LEVEL.md](04_STAGE_LEVEL.md)). Между переходами в мире передаётся **state** (пять блоков); каждый переход читает и/или дополняет state. Пайплайн как узел Stage получает на вход часть state (или маппинг state → inputs пайплайна) и возвращает выходы, которые маппятся обратно в state.
- То, что на уровне пайплайна течёт по рёбрам (данные между задачами), на уровне Stage и мира входит в **state** — контейнер слотов (описание, конфигурация, артефакты, нарратив и т.д.). Спецификация перехода и мира — в 04_STAGE_LEVEL и Scheme §6–7.

---

## 14. Сводные таблицы

### 14.1 Уровень пайплайна (кратко)

| Понятие | Определение |
|---------|-------------|
| **Пайплайн** | Гиперграф гиперграфов: узлы = гиперграфы задач; по рёбрам — данные между внешними выходами одного гиперграфа и внешними входами другого. |
| **Второй исполняемый уровень** | run(pipeline, inputs) → outputs; выполнение гиперграфов в топологическом порядке, передача данных по рёбрам пайплайна. |
| **Построение** | add_node(hypergraph или config), add_edge(source_graph, source_port, target_graph, target_port), expose_input/expose_output пайплайна; или from_config(config). |
| **Вырожденный случай** | Пайплайн из одного гиперграфа; интерфейс пайплайна = интерфейс этого гиперграфа. |
| **Выше** | Переход (Stage) = гиперграф пайплайнов; по рёбрам — state. [04_STAGE_LEVEL.md](04_STAGE_LEVEL.md). |

### 14.2 Гиперграф задачи и пайплайн

| Аспект | Гиперграф задачи | Пайплайн |
|--------|------------------|----------|
| **Узлы** | Блоки-задачи (Backbone, Solver, Codec, …). | Целые гиперграфы (каждый = одна задача). |
| **Рёбра** | Связи портов между узлами-задачами. | Связи внешних выходов одного гиперграфа с внешними входами другого. |
| **Поток** | Данные между портами узлов. | Данные между задачами. |
| **run** | run(hypergraph, inputs) → outputs. | run(pipeline, inputs) → outputs; внутри — вызов run(hypergraph, …) для каждого узла. |

---

## 15. Критерии завершения фазы 3 (напоминание)

- Документ docs/03_PIPELINE_LEVEL.md создан. ✓
- Пайплайн (гиперграф гиперграфов) реализован и исполняется: структура (узлы-гиперграфы, рёбра пайплайна), валидация, внешние входы/выходы пайплайна, выполнение по топологии с передачей данных между гиперграфами.
- Пример с двумя гиперграфами (или один — вырожденный) выполняется; тест воспроизводим.
- Соответствие Philosophy и Scheme сохранено.

---

## 16. Ссылки

| Документ | Назначение |
|----------|------------|
| [Philosophy.md](../Philosophy.md) | П. 5.4: уровень пайплайна — гиперграф гиперграфов, данные между задачами, вырожденный случай. |
| [Scheme.md](../Scheme.md) | §5 — уровень пайплайна. |
| [02_HYPERGRAPH_LEVEL.md](02_HYPERGRAPH_LEVEL.md) | Гиперграф задачи: узлы = блоки-задачи, внешние входы/выходы, контракт run, движок. |
| [PLAN_DEVELOPMENT_CANON.md](PLAN_DEVELOPMENT_CANON.md) | Фаза 3 — цели, документация, реализация, критерии. |
| [../WorldGenerator_2.0/Pipeline_Level.md](../WorldGenerator_2.0/Pipeline_Level.md) | Уровень пайплайна в WG 2.0. |

---

**Итог.** Настоящий документ — **полная и глубокая техническая спецификация уровня пайплайна** для Universe Generator 3.0. В нём заданы пайплайн как гиперграф гиперграфов (узлы = гиперграфы задач, рёбра = данные между задачами), контракт гиперграфа как узла (внешние входы/выходы), построение пайплайна (добавление узлов-гиперграфов, рёбер, внешние входы/выходы пайплайна, from_config), валидация, планирование и выполнение (применение того же гиперграфового движка к уровню пайплайна), контракт run(pipeline, inputs) → outputs, вырожденный случай (один гиперграф), сериализация (конфиг и чекпоинт как совокупность чекпоинтов гиперграфов) и связь с уровнем перехода (Stage). Реализация фазы 3 и последующий уровень перехода (фаза 4) опираются на эту спецификацию.
