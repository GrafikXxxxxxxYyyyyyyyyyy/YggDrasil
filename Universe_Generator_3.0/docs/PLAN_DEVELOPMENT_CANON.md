# План разработки Universe Generator 3.0: канон и реализация

**Назначение:** глубокий, детальный и всеобъемлющий **план разработки** фреймворка Yggdrasil (Universe Generator 3.0) — канон (документация) и реализация (код). Документ задаёт **последовательность фаз**, **результаты каждой фазы** (документы и код), **зависимости** и **критерии готовности**. Разработка ведётся **снизу вверх** в соответствии с [Philosophy.md](../Philosophy.md) и [Scheme.md](../Scheme.md).

**Якорь:** Philosophy.md — неизменный ориентир; Scheme.md — полная схема архитектуры. При противоречии пересматриваются план, канон или код, а не философия.

**Язык:** русский.

**Связь:** [Scheme.md](../Scheme.md) §11.2, [docs/README.md](README.md).

---

## 1. Принципы разработки

- **Снизу вверх:** сначала **фундамент** (блок, узел, гиперграф), затем уровни по иерархии: **уровень абстрактных блоков-задач** → **уровень гиперграфа** (гиперграф из блоков-задач) → **уровень пайплайна** (гиперграф гиперграфов) → **уровень перехода** (гиперграф пайплайнов) → **уровень мира** (гиперграф переходов) → **уровень вселенной** (гиперграф миров). Ни один уровень не начинается, пока не заложена опора под ним.
- **Контракт и реестр:** каждая сущность вводится через **контракт** (порты, run, идентификация, сериализация) и **регистрацию**; расширяемость только через контракт, без изменений ядра (Philosophy 1.6, Scheme §9).
- **Документация перед или вместе с кодом:** для каждой фазы явно заданы **документы-результаты** (канон 3.0) и **артефакты кода**. Документация сохраняет единый язык и граф гиперссылок (Philosophy 1.12; Scheme §11).
- **Один язык на всех уровнях:** блок, узел, порт, run, гиперграф, переход, state, мир, вселенная — термины не меняют смысла при переходе между фазами.
- **Референс старого канона:** при проектировании и реализации опираемся на [../WorldGenerator_2.0/](../WorldGenerator_2.0/) (Abstract_Block_And_Node, Graph_Level, Pipeline_Level, Stage_Level, World_Level, EXPANSION_UNIVERSE, Scheme, System); новый канон и код развивают старый, не отменяя его.

---

## 2. Обзор фаз

Иерархия уровней (каждый следующий — **гиперграф предыдущего**):

| Фаза | Название | Что строится | Ключевые результаты |
|------|----------|--------------|----------------------|
| **0** | Фундамент | Block, Node, правило блок→узел, структура гиперграфа | Контракт Block/Node, гиперграф (1 узел), реестр типов, первый run. |
| **1** | Уровень абстрактных блоков-задач | Абстрактные типы узлов-задач (Backbone, Solver, Codec, Conditioner, …) | Двойное наследование Block+Node; реестр типов задач; контракт портов по типам. |
| **2** | Уровень гиперграфа | Гиперграф, узлы которого — блоки-задачи | Первый исполняемый уровень: один гиперграф = одна задача; данные между портами по рёбрам. |
| **3** | Уровень пайплайна | Гиперграф гиперграфов (узлы = гиперграфы) | Пайплайн = гиперграф гиперграфов; данные между гиперграфами. |
| **4** | Уровень перехода (Stage) | Гиперграф пайплайнов (узлы = пайплайны) | Один переход = одна метаморфоза; Stage = гиперграф пайплайнов; state на входах/выходах. |
| **5** | Уровень мира | Гиперграф переходов (узлы = переходы) | Мир = гиперграф переходов; state (5 блоков), Среда; цикл Философ → Автор → Среда → Архитектор → Творец. |
| **6** | Уровень вселенной | Гиперграф миров (узлы = миры) | Вселенная = гиперграф миров; эфир; обмен по гиперрёбрам; End Worlds (опционально). |
| **7** | Сквозные темы | Сериализация, агенты, API, тесты, документация | Сериализация на всех уровнях; агентный цикл; блоки через API; тесты и воспроизводимость; граф docs. |

Фазы 0–6 идут **строго последовательно**; фаза 7 может частично пересекаться с 1–6 (сериализация и тесты — по мере появления сущностей).

---

## 3. Фаза 0: Фундамент (Block, Node, Hypergraph)

**Цель:** заложить **два начала** и их **синтез** в коде и каноне: материальное (Block), идеальное (Node), правило «блок → узел», исполняемый гиперграф. Без этой фазы невозможны все остальные уровни.

**Ссылки:** Philosophy Часть II–III, Scheme §2; референс [../WorldGenerator_2.0/Abstract_Block_And_Node.md](../WorldGenerator_2.0/Abstract_Block_And_Node.md).

### 3.1 Зависимости

- Нет (стартовая фаза). Требуются только Philosophy и Scheme как ориентиры.

### 3.2 Документация (канон 3.0)

| Документ | Содержание | Статус |
|----------|------------|--------|
| **docs/00_FOUNDATION.md** | Спецификация фундамента для 3.0: контракт Block (порты, run, block_type, block_id), контракт Node (положение, гиперрёбра), правило блок→узел, структура гиперграфа (узлы, гиперрёбра, порядок обхода). Отличия от WG 2.0 и совпадения. Ссылки на Philosophy и Abstract_Block_And_Node. | **Готов.** |
| **Обновление Scheme.md** | При необходимости — уточнение §2 (ссылка на docs/00_FOUNDATION.md). | По необходимости. |

### 3.3 Реализация (код)

| Компонент | Описание | Критерий готовности |
|-----------|----------|----------------------|
| **Abstract Base Block (контракт)** | Интерфейс/абстрактный класс: объявление портов (входы/выходы с именами и типами), метод run(inputs) → outputs, block_type, block_id. Без привязки к языку в документе; в коде — одна выбранная реализация (например, Python). | Любая реализация блока может быть зарегистрирована и вызвана по контракту. |
| **Abstract Graph Node (контракт)** | Положение в гиперграфе (node_id), входящие и исходящие гиперрёбра (источник_узел, источник_порт) → (этот_узел, порт). Связь узел ↔ блок (в узле хранится ссылка на блок). | Узел однозначно задаёт место и связи; блок в узле доступен по контракту. |
| **Гиперграф** | Структура данных: множество узлов (каждый узел = блок + положение + связи), множество гиперрёбер (связи между портами узлов). Поддержка гиперрёбер арности > 2 (опционально в фазе 0 — достаточно обычных рёбер). | Добавление узла, добавление ребра, получение топологического порядка (или заданного порядка). |
| **Исполнитель гиперграфа** | Обход узлов в допустимом порядке; для каждого узла: собрать входы по входящим рёбрам, вызвать block.run(inputs), раздать выходы по исходящим рёбрам. | Запуск гиперграфа с одним узлом и одним блоком даёт корректный вызов run и выход. |
| **Реестр типов блоков** | Отображение block_type → класс/фабрика реализации. Регистрация типа и создание экземпляра по block_type + конфиг. | Можно зарегистрировать новый block_type и использовать его в узле гиперграфа. |
| **Минимальный пример** | Один блок-заглушка (например, identity или константа), один узел, один гиперграф, один вызов run. Запуск из теста или скрипта. | «Здравствуй, мир» уровня фундамента: гиперграф выполняется, выход воспроизводим. |

### 3.4 Критерии завершения фазы 0

- Документ docs/00_FOUNDATION.md создан и согласован со Scheme и Philosophy.
- В коде реализованы контракт Block, контракт Node, структура гиперграфа, исполнитель, реестр типов.
- Минимальный пример (один блок в одном узле, run) выполняется и воспроизводится.
- Нет изменений в Philosophy; при расхождении с Philosophy скорректированы канон или код.

---

## 4. Фаза 1: Уровень абстрактных блоков-задач

**Цель:** ввести **абстрактные типы узлов-задач** (Backbone, Solver, Codec, Conditioner, Tokenizer, …) — уровень над фундаментом. Каждый такой тип — **двойное наследование** Block и Node; одна сущность как материя и форма. Реестр типов задач; контракт портов по каждому типу. На этой фазе ещё **не** строится гиперграф из нескольких узлов — только абстракции и регистрация.

**Ссылки:** Philosophy 4.5, Scheme §2 (уровень над фундаментом); референс [../WorldGenerator_2.0/Abstract_Task_Nodes.md](../WorldGenerator_2.0/Abstract_Task_Nodes.md), [../WorldGenerator_2.0/Abstract_Block_And_Node.md](../WorldGenerator_2.0/Abstract_Block_And_Node.md).

### 4.1 Зависимости

- Фаза 0 завершена (Block, Node, гиперграф, реестр типов блоков).

### 4.2 Документация

| Документ | Содержание | Статус |
|----------|------------|--------|
| **docs/01_ABSTRACT_TASK_BLOCKS.md** | Уровень абстрактных блоков-задач в 3.0: Backbone, Solver, Codec, Conditioner, Adapter, Tokenizer, Guidance и др. Двойное наследование Block и Node. Спецификация портов и семантика выполнения по каждому типу. Реестр типов задач. Ссылки на WG2.0 Abstract_Task_Nodes. | **Готов.** |

### 4.3 Реализация

| Компонент | Описание | Критерий готовности |
|-----------|----------|----------------------|
| **Абстрактные узлы-задачи (типы)** | Минимум 2–3 типа (например, Backbone, Solver, Codec или эквиваленты-заглушки) с двойным наследованием Block и Node. Для каждого типа: объявление портов, block_type, контракт run. | Типы зарегистрированы в реестре; экземпляр узла-задачи можно создать по block_type и конфигу. |
| **Реестр типов задач** | Отображение block_type (задача) → класс/фабрика. Регистрация и создание экземпляра. | Новый тип задачи добавляется через регистрацию без изменений ядра. |
| **Минимальная реализация** | Хотя бы один конкретный тип (например, простой «вычислитель» или «прокладка») с реальными портами и run. | Экземпляр блока-задачи можно положить в узел гиперграфа (фаза 0) и выполнить run. |

### 4.4 Критерии завершения фазы 1

- docs/01_ABSTRACT_TASK_BLOCKS.md создан.
- Реализованы абстрактные типы узлов-задач (минимум 2–3), двойное наследование, реестр типов задач.
- Экземпляр узла-задачи создаётся и выполняется в рамках гиперграфа фазы 0.
- Соответствие Philosophy и Scheme сохранено.

---

## 5. Фаза 2: Уровень гиперграфа

**Цель:** первый **полноценно исполняемый уровень** — **гиперграф, узлы которого — блоки-задачи** (из уровня абстрактных блоков-задач). По гиперрёбрам передаются **данные** между портами. Один гиперграф = одна цельная задача (например, conditioner → backbone → solver → codec). Валидация, внешние входы/выходы гиперграфа.

**Ссылки:** Philosophy 5.1–5.2, Scheme §3–4; референс [../WorldGenerator_2.0/Graph_Level.md](../WorldGenerator_2.0/Graph_Level.md).

### 5.1 Зависимости

- Фаза 1 завершена (абстрактные блоки-задачи, реестр типов задач).

### 5.2 Документация

| Документ | Содержание | Статус |
|----------|------------|--------|
| **docs/02_HYPERGRAPH_LEVEL.md** | Уровень гиперграфа в 3.0: гиперграф, узлы которого — блоки-задачи; поток = данные между портами. Внешние входы/выходы гиперграфа. Валидация (совместимость типов портов). Один гиперграф = одна цельная задача. Ссылки на WG2.0 Graph_Level. | **Готов.** |

### 5.3 Реализация

| Компонент | Описание | Критерий готовности |
|-----------|----------|----------------------|
| **Построение гиперграфа** | API или конфиг: добавление узлов (блоки-задачи по block_type + block_id + конфиг), добавление гиперрёбер (узел_A, порт_A) → (узел_B, порт_B). | Гиперграф из нескольких узлов-задач собирается программно или из конфига. |
| **Валидация гиперграфа** | Совместимость типов портов на концах рёбер; опционально — связность, обязательные порты. | Невалидный гиперграф не выполняется или выдаёт явную ошибку. |
| **Внешние входы/выходы** | Порты узлов, «торчащие» наружу, как входы и выходы всего гиперграфа. run(hypergraph, external_inputs) → external_outputs. | Гиперграф вызывается как чёрный ящик с входами и выходами. |
| **Пример гиперграфа** | Гиперграф из 2–3 узлов-задач с потоком данных (A → B или A → B → C). Тест. | Воспроизводимый сценарий уровня гиперграфа. |

### 5.4 Критерии завершения фазы 2

- docs/02_HYPERGRAPH_LEVEL.md создан.
- Реализованы построение гиперграфа из блоков-задач, валидация, внешние входы/выходы.
- Пример гиперграфа с несколькими узлами выполняется и тест проходит.
- Соответствие Philosophy и Scheme.

---

## 6. Фаза 3: Уровень пайплайна (гиперграф гиперграфов)

**Цель:** **пайплайн** = **гиперграф гиперграфов**: узлы — гиперграфы (с уровня гиперграфа, фаза 2), по рёбрам передаются **данные** между выходами одного гиперграфа и входами другого. Комбинированные сценарии (несколько задач в цепочке или ветвлении).

**Ссылки:** Philosophy 5.4, Scheme §5; референс [../WorldGenerator_2.0/Pipeline_Level.md](../WorldGenerator_2.0/Pipeline_Level.md).

### 6.1 Зависимости

- Фаза 2 завершена (уровень гиперграфа: гиперграф из блоков-задач, внешние входы/выходы).

### 6.2 Документация

| Документ | Содержание | Статус |
|----------|------------|--------|
| **docs/03_PIPELINE_LEVEL.md** | Уровень пайплайна в 3.0: пайплайн = гиперграф гиперграфов (узлы = гиперграфы); рёбра = соединение выходов одного гиперграфа с входами другого. Порядок выполнения (топология). Вырожденный случай: пайплайн из одного гиперграфа. Конфиг пайплайна. Ссылки на WG2.0 Pipeline_Level. | Готов. |

### 6.3 Реализация

| Компонент | Описание | Критерий готовности |
|-----------|----------|----------------------|
| **Структура пайплайна** | Пайплайн как контейнер гиперграфов-узлов и рёбер между ними (маппинг выходов гиперграфа A на входы гиперграфа B). | Пайплайн собирается и хранится. |
| **Исполнение пайплайна** | Обход гиперграфов в топологическом порядке; для каждого — run с входами из исходящих рёбер предыдущих; передача выходов по рёбрам. | Пайплайн из 2 гиперграфов (задача1 → задача2) выполняется, данные проходят. |
| **Внешние входы/выходы пайплайна** | Входы первого(ых) гиперграфа(ов) и выходы последнего(их) как интерфейс пайплайна. run(pipeline, inputs) → outputs. | Пайплайн вызывается как единая комбинированная задача. |
| **Пример пайплайна** | Пайплайн из двух гиперграфов (или одного — вырожденный случай). Тест. | Воспроизводимость. |

### 6.4 Критерии завершения фазы 3

- docs/03_PIPELINE_LEVEL.md создан.
- Пайплайн (гиперграф гиперграфов) реализован и исполняется; пример с двумя гиперграфами работает.
- Соответствие Philosophy и Scheme.

---

## 7. Фаза 4: Уровень перехода (Stage) — гиперграф пайплайнов

**Цель:** **переход (transition)** как **метаморфоза** — один **Stage = гиперграф пайплайнов**. На входах/выходах в контексте мира передаётся **state** (а не сырые данные). Каждый переход цикла мира реализуется как один Stage.

**Ссылки:** Philosophy Часть VI, Scheme §6; референс [../WorldGenerator_2.0/Stage_Level.md](../WorldGenerator_2.0/Stage_Level.md).

### 7.1 Зависимости

- Фаза 3 завершена (пайплайн = гиперграф гиперграфов, данные между гиперграфами).
- Понятие **state** (контейнер слотов/блоков) введено для уровня мира; на фазе 4 Stage принимает и возвращает state (или его часть).

### 7.2 Документация

| Документ | Содержание | Статус |
|----------|------------|--------|
| **docs/04_STAGE_LEVEL.md** | Уровень перехода в 3.0: Stage = гиперграф пайплайнов; один переход = одна метаморфоза. Вход/выход Stage в контексте мира — state (или блоки state). Условия выполнения перехода (какие блоки state должны быть заполнены). Связь с пятью переходами мира (Философ, Автор, Среда, Архитектор, Творец). | Готов. |

### 7.3 Реализация

| Компонент | Описание | Критерий готовности |
|-----------|----------|----------------------|
| **Модель state** | State как контейнер с пятью блоками (слоты 1–5). Чтение/запись блоков по индексу. Используется на уровне мира; на фазе 4 достаточно структуры и передачи в Stage. | State передаётся в Stage и может быть обновлён после run. |
| **Stage** | Stage = гиперграф пайплайнов (или один пайплайн). Контракт: run(stage, state, context?) → state (или обновление state). Условие выполнения: проверка заполненности нужных блоков state. | Один Stage можно вызвать с state и получить обновлённый state. |
| **Пример Stage** | Один переход-заглушка (например, «копирование блока 1 в блок 2» или минимальная метаморфоза). Тест. | Воспроизводимость перехода. |

### 7.4 Критерии завершения фазы 4

- docs/04_STAGE_LEVEL.md создан.
- State (пять блоков) и Stage (гиперграф пайплайнов, контракт по state) реализованы.
- Пример Stage с state выполняется.
- Соответствие Philosophy и Scheme.

---

## 8. Фаза 5: Уровень мира — гиперграф переходов

**Цель:** **мир** = **гиперграф переходов**: узлы — переходы (Stage), по рёбрам передаётся **state** (пять блоков). Порядок: Философ → Автор → Среда → Архитектор → Творец. **Среда** — два узла: World update (при полном state) и Development of the world (новый state с блоком 1). Первая итерация без предзаданного state; Action опционален.

**Ссылки:** Philosophy Часть VII, Scheme §7; референс [../WorldGenerator_2.0/World_Level.md](../WorldGenerator_2.0/World_Level.md), [../WorldGenerator_2.0/Scheme.md](../WorldGenerator_2.0/Scheme.md).

### 8.1 Зависимости

- Фаза 4 завершена (Stage = гиперграф пайплайнов, state).

### 8.2 Документация

| Документ | Содержание | Статус |
|----------|------------|--------|
| **docs/05_WORLD_LEVEL.md** | Уровень мира в 3.0: мир = гиперграф переходов (цепочка); порядок Философ → Автор → Среда → Архитектор → Творец. State — пять блоков, таблица смыслов и поток по переходам. Среда: World update (условие: все 5 блоков), Development of the world (безусловно, новый блок 1). Первая итерация без state; передача state пользователем; условия выполнения каждого перехода. Action как контекст для Development. Артефакты (контейнер слотов). Ссылки на Scheme §7, WG2.0 World_Level и Scheme. | Готов. |

### 8.3 Реализация

| Компонент | Описание | Критерий готовности |
|-----------|----------|----------------------|
| **Мир (структура)** | Мир = упорядоченный список/граф из пяти переходов (каждый переход — Stage). Фиксированный порядок. Передача state между переходами. | Выполнение одного «витка» цикла: state проходит по цепочке переходов. |
| **Условия выполнения переходов** | Философ — только при заполненных 1,2,3; Автор — при 1–4; World update — только при всех 5 блоках. Остальные по потоку. Пропуск перехода, если условия не выполнены. | Логика условий совпадает со Scheme §7.4, §7.5. |
| **Среда: World update** | Узел/блок: при полном state применить state к миру (обновить контент мира), сохранить state. Иначе — пропуск. Контент мира — структура данных (история, глоссарий, персонажи и т.д.; минимальная реализация — хранилище ключ–значение или документ). | World update вызывается и обновляет мир только при полном state. |
| **Среда: Development of the world** | Узел/блок: безусловно читать мир (и опционально Action); генерировать описание «что должно произойти» (блок 1). Реализация может быть заглушкой (фиксированный текст или вызов LLM по контракту). Выход — новый state с заполненным только блоком 1. | Development всегда создаёт новый state с блоком 1; цикл может повторяться. |
| **Первая итерация** | При пустом/отсутствующем state: пропуск Философ, Автор, World update; старт с Development of the world → новый state с блоком 1 → Архитектор → … | Мир может «запуститься» без переданного state. |
| **Action** | Опциональный ввод пользователя в начало шага; передаётся в Development как контекст. При отсутствии Action Development всё равно выполняется. | Action опционален; без него цикл продолжается. |
| **Пример мира** | Мир с пятью переходами (хотя бы заглушками), 1–2 полных витка цикла. Тест: первая итерация без state, вторая с state после Development. | Воспроизводимость цикла мира. |

### 8.4 Критерии завершения фазы 5

- docs/05_WORLD_LEVEL.md создан.
- Мир реализован: гиперграф из пяти переходов, state (5 блоков), Среда (World update + Development), условия выполнения, первая итерация, Action опционален.
- Пример мира с витками цикла выполняется.
- Соответствие Philosophy и Scheme (в т.ч. круг Хармона — см. docs/HARMON_CIRCLE_AND_WORLD_CYCLE.md).

---

## 9. Фаза 6: Уровень вселенной — гиперграф миров

**Цель:** **вселенная** = **гиперграф миров**; узлы — миры, по гиперрёбрам — обмен (payload_spec: state snapshot, артефакты, сущности). Эфир вселенной; опционально End Worlds. Высший уровень онтологии.

**Ссылки:** Philosophy Часть VIII, Scheme §8; референс [../WorldGenerator_2.0/EXPANSION_UNIVERSE_GRAPH_OF_WORLDS.md](../WorldGenerator_2.0/EXPANSION_UNIVERSE_GRAPH_OF_WORLDS.md).

### 9.1 Зависимости

- Фаза 5 завершена (мир = гиперграф переходов, state, Среда).

### 9.2 Документация

| Документ | Содержание | Статус |
|----------|------------|--------|
| **docs/06_UNIVERSE_LEVEL.md** | Уровень вселенной в 3.0: вселенная = гиперграф миров; узлы = миры (объектные или End Worlds); гиперрёбра = связи, payload_spec. Эфир вселенной (общий контекст, поток трансляции). Выполнение: обход миров, передача данных по рёбрам. Сообщество, сравнение миров, обмен. End Worlds — миры только для чтения. | Готов. |

### 9.3 Реализация

| Компонент | Описание | Критерий готовности |
|-----------|----------|----------------------|
| **Структура вселенной** | Вселенная = граф/гиперграф, узлы = миры (world_id → World). Гиперрёбра с payload_spec (что передаётся: state snapshot, артефакты, сущности). | Вселенная собирается и хранится. |
| **Исполнение вселенной** | Обход миров (топологический или фиксированный); run(world_A); маппинг выходов мира A на входы мира B по payload_spec; при необходимости — обновление state миров при переходе сущностей. | Мир A и мир B в одной вселенной; после run(world_A) данные по ребру доступны миру B. |
| **Эфир вселенной** | Общая среда (контекст, хранилище правил/глоссария — по канону). Доступ миров к эфиру при run. | Минимальная реализация эфира (например, общий контекст-словарь). |
| **End Worlds (опционально)** | Мир с флагом «только чтение»; другие миры могут ссылаться на него по гиперссылке, без изменения. | Поддержка End World в структуре; чтение контента. |
| **Пример вселенной** | Вселенная из 2 миров; обмен по одному ребру. Тест. | Воспроизводимость. |

### 9.4 Критерии завершения фазы 6

- docs/06_UNIVERSE_LEVEL.md создан.
- Вселенная реализована: гиперграф миров, исполнение, эфир, опционально End Worlds.
- Пример вселенной с двумя мирами выполняется.
- Онтология заканчивается на вселенной (уровень метавселенной не вводится — Philosophy 12.3).

---

## 10. Фаза 7: Сквозные темы

**Цель:** **сериализация** на всех уровнях, **агентные сценарии**, **блоки через API**, **тестируемость и воспроизводимость**, **поддержка графа документации**. Может выполняться параллельно с уточнениями фаз 1–5 по мере появления сущностей.

**Ссылки:** Philosophy 1.3, 1.15, Часть IX–X, Scheme §9–10.

### 10.1 Сериализация

| Область | Содержание | Результат |
|---------|------------|------------|
| **Документация** | docs/SERIALIZATION.md (или разделы в уровнях): конфиг + чекпоинт на каждом уровне; формат конфига и чекпоинта для блока, графа, пайплайна, Stage, мира, вселенной. Загрузка/сохранение по контракту. | Единый подход к сериализации описан и реализован на реализованных уровнях. |
| **Код** | Реализация save/load для Block, Graph, Pipeline, Stage, World, Universe (в объёме, достигнутом к концу фаз 0–5). Конфиг структуры + чекпоинт весов. | Артефакт можно сохранить и загрузить; воспроизводимость (Philosophy 1.15). |

### 10.2 Агентные системы

| Область | Содержание | Результат |
|---------|------------|------------|
| **Документация** | docs/AGENTS.md (или раздел в Scheme/canon): агент = блок с состоянием, tool_calls / tool_results; цикл действие → наблюдение → ответ. Интеграция в граф и мир без отдельной онтологии (Philosophy 9.1–9.2). | Канон агентов согласован с Philosophy и Scheme. |
| **Код** | Реализация агентного блока (или использование существующего по контракту), цикл agent_loop в графе/мире. | Минимальный агентный сценарий исполняется в рамках движка. |

### 10.3 Блоки через API

| Область | Содержание | Результат |
|---------|------------|------------|
| **Документация** | Уточнение контракта: блок может работать через API (LLM, VLM, генерация по API); для остальной системы — никакой разницы с локальным блоком (Philosophy 11.2, Scheme §10). | Документирован единый контракт для API-блоков. |
| **Код** | Реализация блока-обёртки для вызова внешнего API (входы/выходы по портам, run = вызов API). Регистрация в реестре. | Один граф/мир может содержать узлы с API-блоками и с локальными; выполнение едино. |

### 10.4 Тестирование и воспроизводимость

| Область | Содержание | Результат |
|---------|------------|------------|
| **Тесты** | Юнит-тесты для контракта Block/Node, гиперграфа, графа задачи, пайплайна, Stage, мира (условия, Среда, первая итерация). Интеграционные тесты: конфиг + чекпоинт + run = воспроизводимый результат. | Регрессии ловятся тестами; конфиг + чекпоинт задают воспроизводимый эксперимент. |
| **Документация** | docs/TESTING.md или раздел в README: как запускать тесты, как воспроизводить сценарий по конфигу и чекпоинту. | Сообщество может воспроизвести и проверить (Philosophy 1.15). |

### 10.5 Граф документации

| Область | Содержание | Результат |
|---------|------------|------------|
| **docs/README.md** | Назначение папки docs; навигация по всем документам (00_FOUNDATION, 01_GRAPH_LEVEL, …, HARMON_CIRCLE_AND_WORLD_CYCLE, PLAN_DEVELOPMENT_CANON, SERIALIZATION, AGENTS, TESTING и т.д.). Гиперссылки в обе стороны со Scheme.md. | Единая точка входа в канон 3.0; граф ссылок согласован со Scheme §11. |
| **Scheme.md** | Поддержание актуальности §11.2: добавление ссылок на новые документы в docs/ по мере их появления. | Scheme остаётся полным графом ссылок на канон. |

### 10.6 Критерии завершения фазы 7

- Сериализация реализована и документирована на всех введённых уровнях.
- Агентный сценарий и блоки через API документированы и при необходимости реализованы в минимальном объёме.
- Тесты покрывают ключевые контракты и сценарии; документ по тестированию и воспроизводимости есть.
- docs/README.md и Scheme §11.2 отражают актуальный набор документов.

---

## 11. Зависимости между фазами (граф)

Иерархия: каждый следующий уровень — **гиперграф предыдущего**.

```
  [Philosophy, Scheme] (неизменный якорь)
           │
           ▼
  Фаза 0: Фундамент (Block, Node, гиперграф)
           │
           ▼
  Фаза 1: Уровень абстрактных блоков-задач (Backbone, Solver, Codec, …)
           │
           ▼
  Фаза 2: Уровень гиперграфа (гиперграф из блоков-задач)
           │
           ▼
  Фаза 3: Уровень пайплайна (гиперграф гиперграфов)
           │
           ▼
  Фаза 4: Уровень перехода — Stage (гиперграф пайплайнов)
           │
           ▼
  Фаза 5: Уровень мира (гиперграф переходов)
           │
           ▼
  Фаза 6: Уровень вселенной (гиперграф миров)

  Фаза 7: Сквозные темы (могут идти параллельно с 1–6 по мере появления сущностей)
```

Ни одна фаза не стартует без завершения зависимых; фаза 7 частично итеративна (сериализация и тесты — по уровням).

---

## 12. Порядок работ внутри фазы (рекомендация)

Для каждой фазы рекомендуется придерживаться порядка:

1. **Уточнить и зафиксировать документ канона** (docs/0X_… или тематический) — что именно строится, контракты, ссылки на Philosophy и Scheme.
2. **Реализовать контракт и минимальную реализацию** в коде — без «лишнего»; только то, что входит в критерии готовности фазы.
3. **Добавить минимальный пример и тест** — воспроизводимый сценарий.
4. **Обновить граф документации** (docs/README.md, при необходимости Scheme §11.2).
5. **Проверить соответствие Philosophy и Scheme** — при расхождении править канон или код, не философию.

---

## 13. Глоссарий и ссылки

- **Philosophy:** [../Philosophy.md](../Philosophy.md) — единственный идеологический ориентир; не меняется.
- **Scheme:** [../Scheme.md](../Scheme.md) — полная схема архитектуры фреймворка.
- **Старый канон:** [../WorldGenerator_2.0/](../WorldGenerator_2.0/) — референс по уровням и контрактам.
- **Навигация docs:** [README.md](README.md) (после создания).

Термины (блок, узел, порт, run, гиперграф, переход, state, мир, вселенная, контракт, сериализация, чекпоинт) — по Philosophy 1.12 и Scheme; единый язык на всех фазах.

---

**Итог.** Настоящий план задаёт **глубокую и детальную программу разработки** Universe Generator 3.0: шесть фаз (0 — фундамент, 1–5 — уровни иерархии, 6 — сквозные темы), для каждой фазы — цели, зависимости, документация-результаты, компоненты реализации, критерии завершения. Разработка ведётся **снизу вверх**, с опорой на Philosophy и Scheme и с сохранением единого языка и графа документации.
