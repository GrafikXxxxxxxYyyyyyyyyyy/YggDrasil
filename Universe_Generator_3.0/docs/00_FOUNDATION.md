# 00. Фундамент: Block, Node, гиперграф — полная техническая спецификация

**Назначение:** глубокая и детальная **техническая документация уровня фундамента** для Universe Generator 3.0 (Yggdrasil). Документ задаёт всё, что присутствует на этом уровне: контракт блока, контракт узла, правило «блок → узел», структуру гиперграфа, порядок обхода, исполнитель, реестр типов, сериализацию. Это **единственный канонический источник** технических решений фундамента в каноне 3.0.

**Якорь:** [Philosophy.md](../Philosophy.md) — идеологический ориентир; [Scheme.md](../Scheme.md) §2 — схема основания. При противоречии пересматриваются данный документ или реализация, а не философия.

**Референс:** [../WorldGenerator_2.0/Abstract_Block_And_Node.md](../WorldGenerator_2.0/Abstract_Block_And_Node.md), [../WorldGenerator_2.0/HYPERGRAPH_AND_HYPERLINKS.md](../WorldGenerator_2.0/HYPERGRAPH_AND_HYPERLINKS.md).

**Язык:** русский.

**Связь с планом:** [PLAN_DEVELOPMENT_CANON.md](PLAN_DEVELOPMENT_CANON.md) — фаза 0.

---

## 1. Место фундамента в каноне 3.0

Фундамент — **нулевой уровень** иерархии. На нём определены только:

| Сущность | Назначение |
|----------|------------|
| **Abstract Base Block (блок)** | Материальное начало: хранит и вычисляет; атом сборки. |
| **Abstract Graph Node (узел)** | Идеальное начало: задаёт место в гиперграфе и связи (гиперрёбра). |
| **Правило синтеза** | Любой блок может стать узлом гиперграфа (блок → узел). |
| **Гиперграф** | Структура: множество узлов (каждый узел содержит ровно один блок) + множество гиперрёбер. |
| **Исполнитель** | Обход узлов, вызов `run` блока, передача данных по гиперрёбрам. |
| **Реестр типов блоков** | Отображение `block_type` → класс/фабрика; создание экземпляра по конфигу. |

Всё остальное (абстрактные блоки-задачи, уровень гиперграфа задачи, пайплайн, переход, мир, вселенная) строится **над** фундаментом и опирается на эти сущности. Фундамент **минимален**: без него невозможны остальные уровни; он не содержит доменной логики задач, только контракт и структуру.

---

## 2. Два начала и синтез (кратко)

Философская основа — [Philosophy.md](../Philosophy.md) Часть II–III.

| Начало | Сущность | Смысл |
|--------|----------|--------|
| **Материальное** | **Block** | Хранит (параметры, тензоры, конфиг, состояние) и **выполняет** (run по входам → выходы). Носитель содержания. |
| **Идеальное** | **Node** | Задаёт **положение** в гиперграфе и **связи** (входящие/исходящие гиперрёбра). Не хранит данные — только форму. |

**Правило синтеза:** любой Block может быть **помещён в узел** гиперграфа. После этого блок остаётся блоком; узел задаёт его положение и соединения. **Гиперграф** — снятие двух начал: материя (блоки в узлах) и идея (узлы и гиперрёбра) существуют только вместе при исполнении.

---

## 3. Контракт Block (Abstract Base Block)

### 3.1 Определение

**Abstract Base Block** — минимальная единица системы, которая:

1. **что-то хранит** (материальное содержание);
2. **что-то вычисляет** (выполнение по входам → выходы).

На фундаментальном уровне **вся материя системы** воплощена в блоках. Любой объект (модель, кодек, солвер, кондиционер и т.д.) представляется как базовый блок или обёрнут в него.

### 3.2 Что блок хранит (материальное содержание)

| Категория | Содержимое | Назначение |
|-----------|------------|------------|
| **Параметры и конфигурация** | Конфиг (словарь, YAML, JSON), гиперпараметры, флаги. Идентификаторы: `block_id`, `block_type`. Всё, что задаёт «кто этот блок» и «с какими настройками работает». | Идентичность и настройки; воспроизводимость. |
| **Тензоры и веса** | Обучаемые веса (нейросеть), кэш, промежуточные буферы. Всё, что занимает память и участвует в вычислениях. | Выполнение; обучение; инференс. |
| **Ссылки** | Указатели на другие блоки, на ресурсы (файлы, URI), на граф (если блок помещён в граф). | Композиция; доступ к внешним ресурсам. |
| **Состояние** | Всё для воспроизводимости и save/load: state_dict, снимок конфига при сохранении, опционально версия и метаданные. | Чекпоинты; воспроизводимость. |

Итого: блок = **хранилище** (параметры, тензоры, ссылки, состояние) + **исполняемая единица** (контракт ниже).

### 3.3 Контракт блока: три аспекта

#### 3.3.1 Объявление интерфейса (порты)

- Блок **объявляет** входы и выходы — **порты** (ports).
- У каждого порта: **имя** (уникальное внутри блока), **тип** или схема данных (тензор, словарь, конфиг, поток и т.д.), **опциональность** (обязательный / опциональный).
- Описание «что блок принимает и отдаёт» **без привязки к конкретному графу**. Блок не знает, откуда придут данные и куда уйдут — только имена и типы портов.
- **Входные порты:** по ним блок получает данные при выполнении.
- **Выходные порты:** по ним блок отдаёт результаты.
- Совместимость при соединении узлов в гиперграфе проверяется по типам портов (и при необходимости по семантике).

#### 3.3.2 Выполнение (execution)

- Блок **выполняется**: по входным данным (по значениям на входных портах) выдаёт выходные (значения на выходных портах).
- Сигнатура (псевдо): `outputs = block.run(inputs)` или `block.forward(inputs) → outputs`, где `inputs` и `outputs` — словари по именам портов (или эквивалент).
- Выполнение — материальный акт: вычисления, обращение к тензорам и весам, чтение/запись состояния.
- Опционально: блок может иметь фазы (`train` / `eval`), тогда контракт может различаться по фазам.

#### 3.3.3 Идентификация

- **block_type** — тип блока (строка или enum: `"backbone"`, `"solver"`, `"codec"` и т.д.). Определяет класс/реализацию; используется реестром для создания экземпляра.
- **block_id** — уникальный в рамках графа (или области видимости) идентификатор экземпляра. Позволяет обращаться к конкретному блоку при построении рёбер и при выполнении.

Итого по контракту: блок = **объявление портов** + **выполнение (run/forward)** + **идентичность (block_type, block_id)**.

### 3.4 Порты: детализация

| Аспект | Описание |
|--------|----------|
| **Имена портов** | Строки (или стабильные идентификаторы). Уникальны внутри блока. В гиперрёбрах: ребро связывает (узел_A, порт_A) с (узел_B, порт_B). |
| **Типы портов** | Тензор, словарь, конфиг, поток байтов, ссылка на артефакт и т.д. Тип задаёт, что можно передавать по ребру; при валидации проверяется совместимость типов источника и приёмника. |
| **Опциональность** | Входной порт может быть обязательным или опциональным. Если опциональный — блок должен корректно работать при отсутствии значения (значение по умолчанию или пропуск). |
| **Множественность** | Один входной порт может получать данные по нескольким рёбрам (тогда нужна политика агрегации: конкатенация, сумма, выбор одного). Один выходной порт может быть источником для нескольких рёбер (раздача одного значения). |

### 3.5 Жизненный цикл блока

1. **Создание** — инстанцирование по конфигу (тип блока, параметры). Блок получает `block_id` (если не задан — генерируется).
2. **Размещение в гиперграфе** — блок помещается в узел (преобразование блок → узел). Узел получает имя; гиперрёбра задают связи портов блока с портами других узлов.
3. **Выполнение** — исполнитель гиперграфа передаёт на входные порты блока данные (согласно входящим рёбрам); вызывает выполнение блока; забирает данные с выходных портов и передаёт по исходящим рёбрам.
4. **Сохранение/загрузка** — состояние блока (state_dict, конфиг) сериализуется для чекпоинта; при загрузке блок восстанавливается из чекпоинта.

### 3.6 Композиция: блоки из блоков

Блок может **внутри себя** содержать другие блоки (подблоки). Тогда он сам является композицией: его выполнение сводится к вызову подблоков и передаче данных между ними (внутренний подграф или фиксированный пайплайн). Снаружи такой блок соблюдает контракт Abstract Base Block: порты, выполнение, идентичность. Вся материя внутри — снова блоки.

### 3.7 Сериализация блока

- **Конфиг:** параметры, `block_type`, `block_id`, всё, что нужно для воссоздания экземпляра без весов (структура).
- **Чекпоинт (state_dict):** веса, кэш, состояние для воспроизводимости. Сохранение и загрузка по контракту `state_dict()` и `load_state_dict(state, strict=...)`.
- При сериализации гиперграфа порты и имена портов хранятся на уровне узлов и рёбер; блок сериализует своё внутреннее состояние и конфиг.

### 3.8 Реестр типов блоков (привязка к блоку)

Реестр — отображение **block_type** → класс или фабрика (конструктор/фабричная функция). Операции:

- **Регистрация:** зарегистрировать тип под строкой `block_type` (например, `"backbone/identity"`).
- **Создание экземпляра:** по конфигу с полем `block_type` (или `type`) и остальными параметрами вызвать фабрику и вернуть экземпляр Block. Конфиг передаётся в конструктор (в т.ч. `block_id`, `config`).

Новый блок добавляется в систему **без изменений ядра** — только реализация контракта и регистрация в реестре.

---

## 4. Контракт Node (Abstract Graph Node)

### 4.1 Определение

**Abstract Graph Node** — **место** или **роль** в гиперграфе, которому может соответствовать **любой** Abstract Base Block. Узел **не хранит** материю сам по себе: он задаёт **положение** в гиперграфе и **связи** (гиперрёбра) с другими узлами. То, что помещено в узел, — всегда блок; узел — **идеальная форма**, в которую блок помещается.

### 4.2 Что задаёт узел (идеальное содержание)

| Аспект | Описание |
|--------|----------|
| **Положение в гиперграфе** | **Имя узла (node_id)** — уникальный в рамках гиперграфа идентификатор (строка или стабильный ID). Узел отвечает на вопрос «где в гиперграфе эта сущность». По имени узла исполнитель обращается к блоку и к входящим/исходящим гиперрёбрам. |
| **Связи с другими узлами (гиперрёбра)** | **Входящие гиперрёбра:** (источник_узел, источник_порт) → (этот_узел, входной_порт). **Исходящие гиперрёбра:** (этот_узел, выходной_порт) → (приёмник_узел, приёмник_порт). Гиперрёбра задают порядок и направление потоков данных. На уровне фундамента достаточно **рёбер размера 2** (одна пара источник–приёмник); гиперрёбра большей арности — опционально (см. §6). |
| **Семантика портов на уровне гиперграфа** | Какие порты блока «торчат наружу» и к чему подключаются: какой входной порт узла является входом гиперграфа, какой выходной — выходом гиперграфа. Узел задаёт **отображение** портов блока на гиперрёбра гиперграфа. |

Узел не дублирует блок: он задаёт **как блок встроен в целое**. Целое — гиперграф.

### 4.3 Гиперрёбра (рёбра): формат и семантика

- **Ребро** (гиперребро размера 2) — направленная связь от одного порта к другому. Формат: `(source_node_id, source_port_name) → (target_node_id, target_port_name)`.
- Тип данных на ребре должен совпадать с типом выходного порта источника и типом входного порта приёмника (или быть совместимым по правилам системы).
- Один выходной порт может быть источником **нескольких** рёбер (одно значение раздаётся в несколько узлов). Один входной порт может быть приёмником одного или нескольких рёбер (при нескольких — политика агрегации на уровне узла/блока).
- **Порядок выполнения** гиперграфа определяется топологией: топологическая сортировка по направлению рёбер (от входов к выходам). При циклах нужна итеративная или фиксированная схема (например, фиксированное число итераций).

### 4.4 Любой блок может стать узлом

- Abstract Graph Node **не привязан** к одному конкретному типу блока. **Любой** Abstract Base Block может быть помещён в узел гиперграфа.
- Один и тот же **класс** блоков может использоваться в **разных гиперграфах** и в **разных узлах** одного гиперграфа; узел задаёт не тип блока, а **роль в данном гиперграфе** (место и связи).
- **Преобразование «блок → узел»:** взять экземпляр блока, назначить ему имя узла и набор гиперрёбер. После этого при выполнении гиперграфа исполнитель обращается к узлам по имени, передаёт данные по рёбрам; содержимое узла — блок, который вызывается при подаче данных на его входные порты.

### 4.5 Входы и выходы гиперграфа

- **Вход гиперграфа** — входной порт какого-то узла, помеченный как «внешний вход» (или не имеющий входящих рёбер от других узлов и подаваемый извне). Аналогично **выход гиперграфа** — выходной порт узла, помеченный как «внешний выход».
- Узел задаёт участие портов блока в этих входах/выходах гиперграфа. В конфиге гиперграфа задаётся список **exposed inputs** и **exposed outputs** — пары (node_id, port_name).

### 4.6 Жизненный цикл узла

1. **Создание узла** — задаётся имя узла (уникальное в гиперграфе).
2. **Размещение блока** — в узел помещается блок (экземпляр Abstract Base Block). Узел хранит ссылку на блок; данные хранит блок, не узел.
3. **Задание гиперрёбер** — для узла задаются входящие и исходящие гиперрёбра (связи портов этого узла с портами других узлов).
4. **Выполнение гиперграфа** — исполнитель обходит узлы (в топологическом порядке), для каждого узла собирает входные данные по входящим рёбрам, вызывает блок узла, раздаёт выходные данные по исходящим рёбрам.

---

## 5. Правило «блок → узел» и процесс

### 5.1 Правило

**Любой Abstract Base Block может быть превращён в узел гиперграфа:** помещён в гиперграф как узел с именем и набором гиперрёбер. Материя (блок) получает идеальную форму (место и связи), не переставая быть блоком.

### 5.2 Процесс

1. Иметь экземпляр блока (с заданными `block_type`, `block_id`, портами, состоянием).
2. Создать узел с уникальным именем в гиперграфе.
3. Поместить блок в узел (узел хранит ссылку на блок).
4. Задать входящие гиперрёбра: от каких (узел, порт) приходят данные на какие входные порты блока.
5. Задать исходящие гиперрёбра: с каких выходных портов блока данные уходят в какие (узел, порт).

После этого блок выступает как узел при выполнении гиперграфа: его порты участвуют в рёбрах; выполнение блока вызывается исполнителем при подаче данных на его входы.

### 5.3 Система как целое

- **Гиперграф** = множество узлов (каждый узел содержит ровно один блок) + множество гиперрёбер (связи портов).
- **Потоки данных** — по гиперрёбрам; **вычисления** — в блоках внутри узлов.
- Содержимое узлов — **материя** (блоки); структура гиперграфа (узлы, гиперрёбра, порядок) — **идея**. Оба уровня необходимы и работают только вместе.

---

## 6. Структура гиперграфа

### 6.1 Компоненты

| Компонент | Описание |
|-----------|----------|
| **Узлы** | Множество узлов. Каждый узел: node_id (уникальный), ссылка на блок (Abstract Base Block). |
| **Гиперрёбра** | Множество связей между портами узлов. На уровне фундамента достаточно **рёбер размера 2**: каждая связь (source_node, source_port) → (target_node, target_port). |
| **Внешние входы/выходы** | Списки (node_id, port_name) — какие порты узлов являются входами/выходами гиперграфа для внешнего вызова. |

### 6.2 Гиперрёбра арности > 2 (опционально в фазе 0)

В полной модели движка (Philosophy, Scheme) структура — **гиперграф**: гиперребро может соединять **любое число** узлов (не только два). Обычный граф — частный случай (все гиперрёбра размера 2). В **фазе 0** допустимо реализовать только рёбра размера 2; поддержка гиперрёбер большей арности может быть добавлена на уровне канона и кода без смены контракта Block/Node. См. [../WorldGenerator_2.0/HYPERGRAPH_AND_HYPERLINKS.md](../WorldGenerator_2.0/HYPERGRAPH_AND_HYPERLINKS.md).

### 6.3 Порядок обхода

- **Топологическая сортировка** по направлению рёбер: от узлов без входящих рёбер (или от внешних входов) к узлам с исходящими в выходы гиперграфа.
- При **циклах** в гиперграфе порядок не может быть полным DAG; требуется либо итеративная схема (фиксированное число итераций, обновление буферов), либо явно заданный порядок обхода. На уровне фундамента достаточно случая **DAG** (без циклов) для минимального примера; циклы — уровень мира и выше.
- Исполнитель получает **допустимый порядок** обхода узлов и выполняет блоки в этом порядке.

### 6.4 Операции над структурой

- **Добавление узла:** создать узел с node_id и блоком; добавить в множество узлов.
- **Добавление ребра:** задать (source_node, source_port, target_node, target_port); проверить существование узлов и портов; добавить ребро.
- **Получение топологического порядка:** по множеству рёбер вычислить порядок узлов (например, Kahn или DFS).
- **Внешние входы/выходы:** установить/получить списки (node_id, port_name) для вызова run гиперграфа.

---

## 7. Исполнитель гиперграфа

Исполнитель — компонент, который **выполняет** гиперграф: передаёт данные по рёбрам и вызывает блоки.

### 7.1 Алгоритм (псевдо)

1. По структуре гиперграфа получить **допустимый порядок обхода** узлов (топологическая сортировка или заданный порядок).
2. Инициализиовать **буфер значений** на рёбрах: внешние входы гиперграфа подаются на соответствующие порты узлов (по списку exposed inputs).
3. Для каждого узла в порядке обхода:
   - Собрать **входы** узла: для каждого входного порта блока взять значения из буферов входящих рёбер (источник_узел, источник_порт) → (этот_узел, порт).
   - Вызвать **block.run(inputs)** (или forward(inputs)) → outputs.
   - Раздать **выходы** по исходящим рёбрам: записать значения выходных портов в буферы рёбер (этот_узел, порт) → (приёмник_узел, приёмник_порт).
4. Собрать **выходы гиперграфа** из буферов по списку exposed outputs и вернуть их как результат run.

### 7.2 Контракт run гиперграфа

- Вход: словарь **inputs** — имена внешних входов (или пары (node_id, port_name) в зависимости от соглашения) и соответствующие значения.
- Выход: словарь **outputs** — имена внешних выходов и соответствующие значения.
- Минимальный случай: один узел, один блок, без рёбер — run подаёт inputs на порты блока и возвращает outputs с выходных портов. Это «здравствуй, мир» уровня фундамента.

### 7.3 Дополнительные аспекты (реализация)

- **Устройство (device):** при необходимости блоки переносятся на устройство (CPU/GPU) перед выполнением; контракт может включать `to(device)` для графа.
- **Режим train/eval:** при выполнении может передаваться флаг `training=True/False` для блоков, поддерживающих режимы.
- **Кэширование плана:** исполнитель может кэшировать топологический порядок и карту рёбер до первого run и инвалидировать при изменении структуры гиперграфа.

---

## 8. Реестр типов блоков

### 8.1 Назначение

Реестр связывает **имя типа** (block_type) с **реализацией** (класс или фабрика). Это позволяет:

- создавать блоки по конфигу без жёсткого кода (конфиг содержит `block_type` и параметры);
- расширять систему новыми типами блоков без изменений ядра — только регистрация.

### 8.2 Операции

| Операция | Описание |
|----------|----------|
| **register(block_type, class_or_factory)** | Зарегистрировать тип. `block_type` — строка; второй аргумент — класс, наследующий Abstract Base Block, или фабричная функция, возвращающая блок. |
| **build(config)** | Создать экземпляр блока. В `config` обязательно поле `block_type` (или `type`); остальные поля передаются в конструктор (в т.ч. `block_id`, `config`). |
| **get(block_type)** | Получить зарегистрированный класс/фабрику по типу (для интроспекции). |

### 8.3 Глобальный и локальные реестры

Для простоты в фазе 0 достаточно **одного глобального реестра** (синглтон). При необходимости можно поддерживать локальные реестры (например, на уровень гиперграфа или пайплайна) для изоляции типов.

---

## 9. Валидация гиперграфа (опционально в фазе 0)

Перед выполнением или сериализацией можно проверять:

- Все node_id в рёбрах существуют в множестве узлов.
- Все port_name в рёбрах соответствуют объявленным портам блоков (входы/выходы).
- Типы портов на концах ребра совместимы.
- Обязательные входные порты узлов имеют ровно одно входящее ребро (или заданную политику).
- Отсутствуют циклы, если исполнитель предполагает DAG (или явно задана стратегия для циклов).
- Списки exposed inputs/outputs ссылаются на существующие (node_id, port_name).

Валидация может возвращать список ошибок и предупреждений; при строгом режиме run не выполняется при наличии ошибок.

---

## 10. Сериализация фундамента

### 10.1 Конфиг структуры гиперграфа

Сериализация **структуры** (без весов) должна позволять воссоздать гиперграф: узлы (node_id, block_type, block_id, config блока), рёбра (source_node, source_port, target_node, target_port), exposed_inputs, exposed_outputs. Формат — словарь или JSON/YAML. При загрузке по конфигу блоки создаются через реестр (build), затем собираются узлы и рёбра.

### 10.2 Чекпоинт (веса)

Сериализация **состояния** блоков: для каждого узла (по node_id или block_id) сохраняется state_dict блока. Формат — один файл (словарь node_id → state_dict) или директория с файлами по node_id. Загрузка — передача state_dict в каждый блок (load_state_dict).

### 10.3 Полное сохранение/загрузка

- **Сохранить:** записать конфиг структуры + чекпоинт (в каталог: config.json + checkpoint.json или аналог).
- **Загрузить:** прочитать конфиг, собрать гиперграф через реестр, загрузить чекпоинт в блоки.

Версионирование схемы конфига (schema_version) рекомендуется для обратной совместимости при эволюции формата.

---

## 11. Отличия от WG 2.0 и совпадения

| Аспект | WG 2.0 | Канон 3.0 (фундамент) |
|--------|--------|------------------------|
| **Блок** | Abstract Base Block: порты, forward/run, block_type, block_id, state_dict. | То же; контракт явно зафиксирован в данном документе. |
| **Узел** | Abstract Graph Node: положение, связи; рёбра на уровне графа. | То же; узел хранит только node_id и ссылку на блок; гиперрёбра — на уровне гиперграфа. |
| **Граф/гиперграф** | В WG 2.0 часто «граф»; движок 0.3.0 — гиперграф. | Единая модель — гиперграф; рёбра размера 2 достаточны на фазе 0. |
| **Реестр** | Реестр типов блоков по block_type. | То же; register/build. |
| **Исполнитель** | Обход узлов, сбор входов, вызов блоков, раздача выходов. | То же; контракт run гиперграфа (inputs → outputs). |
| **Сериализация** | Конфиг структуры + чекпоинт весов. | То же; schema_version для конфига. |
| **Exposed inputs/outputs** | В контракте графа для пайплайна и исполнителя. | Входят в контракт гиперграфа на фундаменте. |

Итог: фундамент 3.0 **совместим по духу и контракту** с WG 2.0; отличия — явная формулировка под гиперграф и единый канон в docs/ 3.0.

---

## 12. Сводные таблицы

### 12.1 Block

| Аспект | Содержимое |
|--------|------------|
| **Определение** | Минимальная единица: хранит + вычисляет. Вся материя системы — в блоках. |
| **Хранит** | Параметры, конфиг; тензоры, веса; ссылки; состояние для save/load. |
| **Контракт** | Порты (входы/выходы: имена, типы, опциональность); выполнение (run/forward); идентичность (block_type, block_id). |
| **Жизненный цикл** | Создание → размещение в узле → выполнение (по вызову) → сохранение/загрузка. |
| **Композиция** | Блок может содержать подблоки; снаружи соблюдает тот же контракт. |

### 12.2 Node

| Аспект | Содержимое |
|--------|------------|
| **Определение** | Место/роль в гиперграфе; не хранит данные — задаёт положение и связи. В узле всегда блок. |
| **Задаёт** | Имя узла (node_id, уникальное); входящие и исходящие гиперрёбра; участие портов во входах/выходах гиперграфа. |
| **Рёбра** | (source_node, source_port) → (target_node, target_port); тип данных совместим с портами. |
| **Блок → узел** | Любой блок можно поместить в узел, задать имя и рёбра; узел = форма, блок = содержимое. |
| **Жизненный цикл** | Создание узла → размещение блока → задание рёбер → участие в выполнении гиперграфа. |

### 12.3 Гиперграф и исполнитель

| Вопрос | Ответ |
|--------|--------|
| Из чего состоит гиперграф? | Узлы (каждый с одним блоком) + гиперрёбра (связи портов) + exposed inputs/outputs. |
| Кто задаёт порядок выполнения? | Топология по рёбрам (топологическая сортировка) или явно заданный порядок. |
| Как выполняется run? | Обход узлов в порядке; для каждого: собрать входы по рёбрам → block.run(inputs) → раздать выходы по рёбрам. |
| Минимальный пример? | Один узел, один блок (например, identity или константа), вызов run гиперграфа даёт вызов run блока и воспроизводимый выход. |

---

## 13. Критерии завершения фазы 0 (напоминание)

- Документ docs/00_FOUNDATION.md создан и согласован со Scheme и Philosophy. ✓
- В коде реализованы контракт Block, контракт Node, структура гиперграфа, исполнитель, реестр типов.
- Минимальный пример (один блок в одном узле, run) выполняется и воспроизводится.
- Нет изменений в Philosophy; при расхождении с Philosophy скорректированы канон или код.

---

## 14. Ссылки

| Документ | Назначение |
|----------|------------|
| [Philosophy.md](../Philosophy.md) | Якорь; два начала, синтез, гиперграф, минимализм фундамента (Часть II–III, 3.5–3.8). |
| [Scheme.md](../Scheme.md) | Схема фреймворка; §2 — основание (блок, узел, контракт, уровень над фундаментом). |
| [PLAN_DEVELOPMENT_CANON.md](PLAN_DEVELOPMENT_CANON.md) | План разработки; фаза 0 — цели, документация, реализация, критерии. |
| [../WorldGenerator_2.0/Abstract_Block_And_Node.md](../WorldGenerator_2.0/Abstract_Block_And_Node.md) | Полное техническое описание Block и Node в WG 2.0. |
| [../WorldGenerator_2.0/HYPERGRAPH_AND_HYPERLINKS.md](../WorldGenerator_2.0/HYPERGRAPH_AND_HYPERLINKS.md) | Гиперграф и гиперрёбра произвольной арности, гиперссылки. |

---

**Итог.** Настоящий документ — **полная и глубокая техническая спецификация уровня фундамента** для Universe Generator 3.0. В нём заданы контракт блока, контракт узла, правило блок→узел, структура гиперграфа, порядок обхода, исполнитель, реестр типов и сериализация. Всё, что присутствует на фундаменте, описано здесь; реализация и последующие уровни (абстрактные блоки-задачи, уровень гиперграфа задачи и выше) опираются на эту спецификацию.
