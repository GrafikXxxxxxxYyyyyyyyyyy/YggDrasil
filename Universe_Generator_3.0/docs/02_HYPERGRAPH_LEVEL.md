# 02. Уровень гиперграфа — полная техническая спецификация

**Назначение:** глубокая и детальная **техническая документация первого исполняемого уровня** для Universe Generator 3.0 (Yggdrasil). Документ задаёт **гиперграф, узлы которого — блоки-задачи** (из уровня абстрактных блоков-задач), поток **данных** между портами по гиперрёбрам, **внешние входы/выходы** гиперграфа, **валидацию**, построение (API и конфиг), **агентный цикл** при наличии узла-агента, сериализацию и связь с пайплайном. Отдельно и развёрнуто описана **гиперграфовый движок** — центральная тема фреймворка: архитектура движка, планирование выполнения, построение и кэширование плана, буферы, жизненный цикл run, проектирование и планирование реализации движка в проекте, масштабируемость без обрастания ядра доменной логикой. Это **канонический источник** технических решений уровня гиперграфа задачи в каноне 3.0.

**Якорь:** [Philosophy.md](../Philosophy.md) (п. 5.1–5.2); [Scheme.md](../Scheme.md) §3–4.

**Предыдущие уровни:** [00_FOUNDATION.md](00_FOUNDATION.md) — Block, Node, гиперграф, исполнитель, реестр; [01_ABSTRACT_TASK_BLOCKS.md](01_ABSTRACT_TASK_BLOCKS.md) — абстрактные блоки-задачи.

**Референс:** [../WorldGenerator_2.0/Graph_Level.md](../WorldGenerator_2.0/Graph_Level.md).

**Язык:** русский.

**Связь с планом:** [PLAN_DEVELOPMENT_CANON.md](PLAN_DEVELOPMENT_CANON.md) — фаза 2.

---

## 1. Место уровня в иерархии

| Уровень | Сущность | Описание |
|---------|----------|----------|
| **Фундамент** | Block, Node, гиперграф, исполнитель, реестр | Структура и контракт; один узел с одним блоком уже исполняем на фундаменте. [00_FOUNDATION.md](00_FOUNDATION.md). |
| **Над фундаментом** | Abstract Backbone, Solver, Codec, Conditioner, Tokenizer, Guidance, Agent, … | Спецификации задач, контракты портов. [01_ABSTRACT_TASK_BLOCKS.md](01_ABSTRACT_TASK_BLOCKS.md). |
| **Уровень гиперграфа** | Гиперграф, узлы которого — **экземпляры** блоков-задач | **Первый полноценно исполняемый уровень:** один гиперграф = **одна цельная задача**; по гиперрёбрам передаются **данные** между портами. |
| **Уровень пайплайна** | Гиперграф гиперграфов (узлы = гиперграфы задач) | Комбинированные сценарии (несколько задач в цепочке или ветвлении). [03_PIPELINE_LEVEL.md](03_PIPELINE_LEVEL.md) (фаза 3). |

На **уровне гиперграфа** узлы — не абстракции, а **конкретные реализации** (UNet2D, DDIMSolver, AutoencoderKL, CLIP, агент на базе LLM и т.д.), собранные в один гиперграф. По нему выполняется run: данные поступают на внешние входы, проходят по узлам согласно топологии и снимаются с внешних выходов. Комбинирование нескольких задач (текст → картинка → апскейл → видео) делается на уровне **пайплайна**, а не путём раздувания одного гиперграфа.

---

## 2. Гиперграф задачи — одна цельная задача

**Гиперграф на этом уровне задаёт одну законченную цель** (одну задачу). Примеры:

| Задача | Описание |
|--------|----------|
| **Text-to-image** | Полная реализация: текст на входе, изображение на выходе. Токенизация, условие, диффузия, декодирование — в **одном гиперграфе**. |
| **Image-to-video** | Целая задача: изображение → видео. |
| **Upscale** | Изображение низкого разрешения → изображение высокого разрешения. |
| **Image-to-image** | Стилизация, перевод домена и т.д. |
| **Распознавание** | Классификация, детекция (не обязательно диффузия). |
| **Агентный сценарий** | Агент + инструменты в одном гиперграфе; вход — prompt, выход — финальный response после agent_loop. |

Гиперграф не обязан быть «куском» пайплайна: внутри одного гиперграфа собирается **полная реализация** задачи. Пайплайн нужен, когда нужно **соединить несколько таких задач** (выход одной задачи → вход другой).

---

## 3. Состав гиперграфа: узлы и гиперрёбра

### 3.1 Узлы

- **Узлы** — экземпляры блоков-задач (Backbone, Solver, Codec, Conditioner, Tokenizer, Adapter, Guidance, Agent и т.д.), созданные по **block_type** и **config** через реестр (см. 00_FOUNDATION, 01_ABSTRACT_TASK_BLOCKS).
- Каждый узел имеет **node_id** (уникальный в рамках гиперграфа) и **блок** (экземпляр с портами и run). Данные хранит блок; узел задаёт положение и связи.

### 3.2 Гиперрёбра (рёбра)

- **Рёбра** соединяют порты узлов: (source_node_id, source_port_name) → (target_node_id, target_port_name).
- По рёбрам передаются **данные** (тензоры, словари, сообщения и т.д.) — то, что течёт между портами блоков-задач.
- Один выходной порт может быть источником нескольких рёбер; один входной порт может быть приёмником одного или нескольких рёбер (при нескольких — политика агрегации задаётся контрактом блока или уровнем).

### 3.3 Внешние входы и выходы гиперграфа

- **Внешние входы (exposed inputs):** список пар (node_id, port_name) — порты узлов, которые считаются **входами всего гиперграфа**. При вызове run(hypergraph, inputs) значения из словаря inputs подаются на эти порты (по имени входа или по (node_id, port_name)).
- **Внешние выходы (exposed outputs):** список пар (node_id, port_name) — порты узлов, с которых снимается **результат гиперграфа**. run возвращает словарь outputs с значениями с этих портов.
- Гиперграф вызывается как **чёрный ящик**: внешний наблюдатель передаёт данные на внешние входы и получает данные с внешних выходов; внутренняя топология и типы узлов скрыты за контрактом «входы/выходы гиперграфа».

---

## 4. Построение гиперграфа

### 4.1 Добавление узлов

- **add_node(node_id, block_type, config?, pretrained?, …)** — создать блок через реестр по block_type и config, поместить в узел с заданным node_id, добавить узел в гиперграф. Опционально: загрузка весов (pretrained), флаг trainable.
- **add_node(Node)** — добавить готовый узел (например, при загрузке из конфига).
- При добавлении узла можно использовать **автосвязывание (auto_connect)**: по типу узла-задачи (backbone, solver, codec, …) система выводит типичные связи с уже существующими узлами и предлагает или создаёт рёбра автоматически (см. 01_ABSTRACT_TASK_BLOCKS §13). Это позволяет собирать гиперграф задачи (например, text-to-image) **в несколько строк** — добавление нужных узлов и при необходимости явное связывание нестандартных портов.

### 4.2 Добавление рёбер

- **add_edge(source_node, source_port, target_node, target_port)** — добавить ребро между портами. Все четыре идентификатора должны существовать (узлы и порты объявлены в блоках).
- Валидация при добавлении (или при явном вызове validate): типы портов на концах ребра совместимы; дубликаты рёбер по смыслу не создаются (один и тот же (source, port) → (target, port) не дублируется).

### 4.3 Объявление внешних входов/выходов

- **expose_input(node_id, port_name, name?)** — пометить порт узла как внешний вход гиперграфа. Опционально задаётся имя для словаря inputs при вызове run.
- **expose_output(node_id, port_name, name?)** — пометить порт узла как внешний выход гиперграфа.
- Без объявленных внешних входов/выходов гиперграф не может быть использован как чёрный ящик извне (пайплайн, этап); для внутренних тестов можно вызывать run с подачей данных напрямую на порты узлов по топологии.

### 4.4 Построение из конфига

- Конфиг гиперграфа: **nodes** (список {node_id, block_type, block_id?, config?, trainable?}), **edges** (список {source_node, source_port, target_node, target_port}), **exposed_inputs**, **exposed_outputs** (списки {node_id, port_name, name?}). Опционально: graph_id, graph_kind, metadata.
- **from_config(config, registry?, validate?)** — создать гиперграф из конфига: для каждого узла вызвать registry.build(config узла), добавить узлы, добавить рёбра, восстановить exposed_inputs/outputs. При validate=True выполнить валидацию (см. §5).

---

## 5. Валидация гиперграфа

Перед выполнением или сериализацией рекомендуется проверять:

| Проверка | Описание |
|----------|----------|
| **Существование узлов и портов** | Все node_id в рёбрах и в exposed_inputs/outputs существуют в множестве узлов. Все port_name соответствуют объявленным портам блоков (входы/выходы). |
| **Совместимость типов** | Тип данных на выходном порте источника и тип входного порта приёмника совместимы (по правилам системы или по явной схеме типов). |
| **Обязательные порты** | Обязательные входные порты узлов имеют хотя бы одно входящее ребро (или значение с внешнего входа), если иное не задано политикой (опциональный порт, значение по умолчанию). |
| **Связность (опционально)** | Узлы, участвующие во внешних входах, достижимы от входов; от них достижимы узлы внешних выходов (если граф не допускает «висячих» узлов). |
| **Циклы** | При наличии циклов (например, backbone ↔ solver в диффузии) исполнитель должен поддерживать итеративную схему (фиксированное число шагов или до сходимости); валидатор может предупреждать о циклах. |

Валидация возвращает список **ошибок** (блокирующие выполнение) и **предупреждений**. В строгом режиме run не выполняется при наличии ошибок; при загрузке из конфига с validate=True невалидный гиперграф не создаётся или выдаёт явное исключение.

---

## 6. Гиперграфовый движок в фреймворке: архитектура, планирование и построение

**Гиперграфовый движок** — центральная тема и техническое ядро фреймворка Yggdrasil. От того, насколько корректно и единообразно реализован движок (структура гиперграфа, планирование выполнения, построение плана, буферы, контракт run), зависит способность фреймворка **масштабироваться под любую задачу** — от одного блока до мира и вселенной — без размывания онтологии и без появления «особых путей» для отдельных сценариев. Ниже даётся развёрнутое техническое описание: роль движка, принципы, архитектура компонентов, структуры данных, планирование выполнения, построение и инвалидация плана, буферы и разрешение портов, жизненный цикл run, а также рекомендации по проектированию и планированию реализации движка в проекте.

### 6.1 Роль движка: центральная тема фреймворка

- **Единая модель на всех уровнях.** На каждом уровне иерархии (задача, пайплайн, переход, мир, вселенная) структура представлена и исполняется как **гиперграф** (Philosophy 5.1; Scheme §3). Движок гиперграфа — не «один из модулей», а **общая модель выполнения**: один и тот же механизм обхода узлов, передачи данных по рёбрам и вызова run узлов используется на уровне задачи (узлы = блоки-задачи), на уровне пайплайна (узлы = гиперграфы), на уровне перехода (узлы = пайплайны), мира (узлы = переходы) и вселенной (узлы = миры). Меняется только **содержимое узла** и **семантика данных** на рёбрах; **форма** (гиперграф, порты, порядок обхода, run) одна.
- **Масштабируемость под любую задачу.** Чтобы фреймворк масштабировался под любую задачу (одна модель, диффузия, агент с инструментами, мир, вселенная), движок должен быть **минимальным и универсальным**: не содержать доменной логики конкретных задач, а только (1) хранение структуры (узлы, гиперрёбра, внешние входы/выходы), (2) планирование порядка выполнения, (3) выполнение run по этому порядку с передачей данных через буферы. Вся доменная логика живёт в **блоках** (узлах); движок лишь **ориентирует** их в графе и **передаёт данные** между ними. Поэтому проектирование и реализация движка должны получать в проекте **особое внимание**: от качества движка зависит, будет ли фреймворк держать одну мысль от основания до вселенной или обрастёт исключениями и ветвлениями.

### 6.2 Принцип «одна модель — любой масштаб»

- **Один контракт выполнения.** Независимо от того, является ли узел блоком-задачей (Backbone, Solver, Agent, …), целым гиперграфом задачи (узел пайплайна), пайплайном (узел перехода), переходом (узел мира) или миром (узел вселенной), с точки зрения движка узел — **чёрный ящик** с объявленными входами и выходами (портами) и операцией **run(inputs) → outputs**. Движок не «знает», что внутри узла: он собирает входы по входящим рёбрам (и со внешних входов гиперграфа), вызывает run узла, раздаёт выходы по исходящим рёбрам (и во внешние выходы гиперграфа). Такая унификация позволяет подставлять на место узла как один блок, так и вложенный гиперграф (который сам выполняется тем же движком рекурсивно или через делегирование).
- **Без особых путей.** В движке не должно быть ветвлений вида «если узел — агент, то …», «если граф — пайплайн, то …» на уровне ядра планирования и передачи данных. Специфика агента (tool_calls, agent_loop) инкапсулируется в **режиме выполнения** (исполнитель обнаруживает в выходе узла поле tool_calls и запускает подцикл вызова инструментов и повторного вызова узла), но сам граф и план обхода остаются общими. Циклы (backbone ↔ solver, итерация N шагов) тоже описываются **планом выполнения** (повторяемый фрагмент порядка обхода или явный num_steps), а не отдельной «логикой для диффузии». Итог: движок остаётся простым и предсказуемым; масштабирование идёт за счёт композиции узлов и единого контракта, а не за счёт усложнения ядра.

### 6.3 Архитектура движка: компоненты

Движок гиперграфа можно разбить на следующие **логические компоненты** (в реализации они могут быть объединены в один класс или разнесены по модулям):

| Компонент | Назначение |
|-----------|------------|
| **Хранилище структуры** | Множество узлов (node_id → узел с блоком), множество рёбер (source_node, source_port, target_node, target_port), списки exposed_inputs и exposed_outputs. Версионирование структуры (execution_version или хеш): при любом изменении (add/remove node/edge, change exposed) версия увеличивается для инвалидации кэша плана. |
| **Валидатор** | Проверка согласованности структуры (существование узлов и портов, совместимость типов, обязательные порты, опционально связность и циклы). Вызывается до первого run или при from_config(validate=True). Результат — список ошибок и предупреждений. |
| **Планировщик (execution planner)** | По текущей структуре гиперграфа строит **план выполнения**: порядок обхода узлов, разбиение на фазы при наличии циклов (например, «повторить N раз: [Backbone, Solver]»), распознавание узла-агента и вставка подплана agent_loop. План кэшируется и привязан к версии структуры; при изменении структуры план инвалидируется. |
| **Буферы (edge buffers)** | Во время run каждому ребру (или каждой паре (target_node, target_port)) сопоставляется **буфер значения**: результат, записанный с (source_node, source_port). Для внешних входов буферы инициализируются из словаря inputs; для внешних выходов значения из буферов считываются в словарь outputs по окончании run. |
| **Исполнитель (executor)** | По плану выполнения в порядке обхода для каждого узла: (1) разрешить входы (собрать из буферов входящих рёбер и внешних входов), (2) вызвать node.block.run(inputs), (3) записать выходы в буферы исходящих рёбер и при необходимости во внешние выходы. При обнаружении tool_calls (узел-агент) — выполнить подцикл вызова инструментов и повторного вызова узла до завершения. |
| **Контракт run** | Единая точка входа: run(hypergraph, inputs, **options) → outputs. Опции: training, device, num_loop_steps, max_steps (agent), callbacks, dry_run. Внутри run вызываются планировщик (если план устарел), инициализация буферов, исполнитель, сбор outputs. |

Ни один из этих компонентов не должен содержать доменной логики конкретных задач (диффузия, LLM, мир): только структура, порядок, буферы и вызов run узлов.

### 6.4 Структуры данных движка

- **Узлы:** отображение `node_id → Node`, где Node содержит ссылку на блок (Block) и опционально метаданные (trainable, role). Блок предоставляет get_input_ports(), get_output_ports(), run(inputs).
- **Рёбра:** список или множество рёбер; каждое ребро — кортеж (source_node, source_port, target_node, target_port). Для быстрого доступа при выполнении строятся индексы: входящие рёбра по узлу `in_edges[node_id]`, исходящие `out_edges[node_id]`.
- **Внешние входы/выходы:** список записей {node_id, port_name, name?}; name используется как ключ в словаре inputs/outputs при вызове run.
- **Версия структуры (execution_version):** целое число, инкрементируемое при add_node, remove_node, add_edge, remove_edge, изменении exposed_inputs/exposed_outputs. Планировщик хранит последнюю построенную версию; при несовпадении с текущей версией гиперграфа план перестраивается.
- **План выполнения:** абстрактная структура, достаточная для исполнителя. Варианты: (1) упорядоченный список node_id (для DAG); (2) список «фаз» (каждая фаза — список node_id или подграф); (3) для циклов — «повторить N раз: фаза_цикла»; (4) для агента — «узел agent_id; при tool_calls — подплан вызова tool_id → node_id и повтор agent_id». Конкретный формат — на усмотрение реализации; важно, что план **детерминирован** по структуре и опциям (num_loop_steps, max_steps) и **не зависит** от значений данных на рёбрах (данные влияют только на результаты run узлов, а не на порядок обхода).

### 6.5 Планирование выполнения (execution plan)

- **Цель плана:** определить **последовательность вызовов** узлов и моменты записи/чтения буферов так, чтобы к моменту вызова узла все его входные порты были уже заполнены (входящими рёбрами или внешними входами).
- **Топологическая сортировка (DAG):** если гиперграф не содержит циклов, достаточно один раз вычислить топологический порядок (Kahn или DFS); план = этот порядок. Выполнение — один проход по плану.
- **Гиперграф с циклами:** цикл (например, Backbone → Solver → Backbone) не допускает единственной топологической сортировки. План задаётся как **итеративная схема**: (1) начальная фаза — узлы, не входящие в цикл (например, Conditioner, Codec encode); (2) циклическая фаза — повторять K раз пару [Backbone, Solver] (или заданный подграф); (3) конечная фаза — узлы после цикла (например, Codec decode). Число K задаётся конфигом (num_inference_steps) или опцией run. Планировщик должен уметь распознавать циклы (анализ сильно связных компонент или явная разметка в конфиге) и формировать такой пошаговый план.
- **Узел-агент (agent_loop):** план для графа с агентом содержит специальную метку «узел agent_id; режим agent_loop». Исполнитель при выполнении этого узла: вызывает agent.run(inputs); если в выходе есть tool_calls — для каждого tool_id выполняет соответствующий узел-инструмент (по таблице tool_id → node_id из конфига), собирает tool_results, снова вызывает agent.run(inputs + tool_results); повторяет до отсутствия tool_calls или до max_steps. С точки зрения планировщика план может быть «линейным» с одной специальной вершиной «agent_loop»; детали подцикла выполняет исполнитель.

### 6.6 Построение плана: алгоритмические аспекты

- **Входные данные для планировщика:** граф (узлы, рёбра), флаги или опции (есть ли узел-агент, есть ли явный цикл, num_loop_steps, max_steps). Опционально конфиг гиперграфа задаёт «шаблон» (например, diffusion_graph с циклом backbone–solver и параметром num_inference_steps).
- **Шаги построения плана (псевдо):** (1) Построить граф достижимости по рёбрам (от внешних входов к узлам, от узлов к внешним выходам). (2) Выделить сильно связные компоненты (SCC); узлы, входящие в SCC размера > 1, образуют циклическую часть. (3) Топологическая сортировка «конденсации» графа (SCC как вершины); получить порядок «до цикла», «цикл», «после цикла». (4) Для циклической части задать число итераций (из конфига или опции) и сформировать последовательность узлов внутри одной итерации (например, по порядку рёбер внутри SCC). (5) Если есть узел с признаком «agent», пометить в плане вызов этого узла в режиме agent_loop. (6) Сохранить план и привязать к execution_version.
- **Альтернатива:** для известных шаблонов (diffusion, agent) план может задаваться **декларативно** (конфиг graph_kind: "diffusion" + num_inference_steps), а планировщик лишь подставляет параметры в шаблон, не анализируя граф общо. Компромисс между универсальностью и простотой реализации — на усмотрение проекта; канон рекомендует **универсальный** планировщик, чтобы любой гиперграф (в том числе нестандартные циклы и комбинации) выполнялся без новых веток в коде.

### 6.7 Кэширование и инвалидация плана

- **Кэш плана:** после первого вызова run (или явного вызова build_plan()) планировщик сохраняет построенный план и значение execution_version, при котором он был построен.
- **Инвалидация:** при любом изменении структуры гиперграфа (add_node, add_edge, remove_node, remove_edge, изменение exposed_inputs/outputs) execution_version увеличивается. При следующем run исполнитель сравнивает текущую версию гиперграфа с версией закэшированного плана; при несовпадении вызывается планировщик заново, план обновляется, кэш записывается.
- **Выгода:** для больших гиперграфов построение плана (топология, SCC, порядок) может быть затратным; повторные run с одними и теми же входными данными (например, батч запросов) не должны пересчитывать план. Изменение только **данных** на рёбрах (inputs) не меняет структуру, поэтому план остаётся валидным.

### 6.8 Буферы и разрешение портов (data flow)

- **Буферы:** во время одного run каждому «приёмнику» (target_node, target_port) соответствует одно значение — то, что пришло по ребру от (source_node, source_port). Если на один входной порт приходит несколько рёбер, нужна **политика агрегации** (конкатенация, сумма, выбор одного и т.д.); она может быть задана в контракте блока или в конфиге ребра. Буферы инициализируются: (1) для портов, помеченных как внешние входы, — из словаря inputs; (2) остальные заполняются по мере выполнения узлов (исходящие порты пишут в буферы исходящих рёбер).
- **Разрешение входов узла:** для узла N и его входного порта P собрать все рёбра вида (_, _, N, P); взять значения из буферов этих рёбер (и если (N, P) в exposed_inputs — добавить значение из inputs). Сформировать словарь inputs для node.run(inputs).
- **Запись выходов:** после node.run(inputs) → outputs для каждого выходного порта P и каждого ребра (N, P, target_node, target_port) записать outputs[P] в буфер (target_node, target_port). Если (N, P) в exposed_outputs — также записать в «слот» внешнего выхода для формирования итогового словаря outputs гиперграфа.
- **Жизненный цикл буферов:** буферы создаются в начале run и уничтожаются в конце; не сохраняются между вызовами run (в отличие от состояния внутри блоков, например состояния агента).

### 6.9 Жизненный цикл одного run

1. **Вход:** hypergraph, inputs, options (training, device, num_loop_steps, max_steps, …).
2. **Проверка плана:** если закэшированный план устарел (execution_version изменился), вызвать планировщик, обновить кэш плана.
3. **Инициализация буферов:** для каждого внешнего входа (node_id, port_name) записать в буфер значение из inputs (по имени или по (node_id, port_name)).
4. **Обход по плану:** для каждого шага плана (узел или «agent_loop»): разрешить входы узла из буферов и внешних входов; вызвать node.block.run(inputs); записать выходы в буферы и при необходимости во внешние выходы. Для agent_loop — внутренний подцикл до завершения агента.
5. **Сбор выходов:** по списку exposed_outputs собрать из буферов значения в словарь outputs.
6. **Выход:** вернуть outputs.

Никакой доменной логики внутри этого цикла: только структура, план, буферы и вызов run.

### 6.10 Проектирование и планирование движка в проекте

- **Единая реализация.** Движок гиперграфа должен быть реализован **один раз** на фундаменте (фаза 0) и использоваться без изменений на уровне гиперграфа задачи (фаза 2), а затем — через делегирование или рекурсию — на уровне пайплайна (узлом является гиперграф, у которого свой run, внутри которого вызывается тот же движок), перехода, мира и вселенной. То есть «движок» — это не отдельный продукт фазы 2, а **ядро**, заложенное в фазе 0 (исполнитель, план, буферы) и **расширяемое** на фазах 1–2 за счёт узлов-задач и валидации; логика обхода и передачи данных не дублируется.
- **План работ по движку:** (1) Фаза 0: структура гиперграфа (узлы, рёбра), базовый исполнитель (топологический порядок для DAG, буферы, один проход), exposed_inputs/outputs, реестр. (2) Фаза 2: валидация (порты, типы, обязательные порты); планировщик с поддержкой циклов (итеративная схема, num_loop_steps); кэш плана и execution_version; опционально распознавание узла-агента и режим agent_loop в исполнителе. (3) Далее: при введении пайплайна и выше — убедиться, что узел «гиперграф» реализует тот же контракт run(inputs)→outputs и внутри делегирует вызов тому же движку (или вложенному исполнителю с той же семантикой).
- **Тестирование движка:** минимальные тесты — один узел (run передаёт inputs в блок и возвращает outputs); цепочка A→B→C (данные проходят по рёбрам); цикл из двух узлов с num_loop_steps=2 (проверка, что буферы обновляются между итерациями); граф с агентом и одним инструментом (проверка, что agent_loop выполняется и выход — финальный response). Так движок остаётся надёжной основой для масштабирования.

### 6.11 Масштабируемость: почему движок не должен обрастать задачами

- **Любая задача = та же форма.** Тексто-картинка, апскейл, агент с инструментами, мир из пяти переходов, вселенная из миров — с точки зрения движка это всегда «гиперграф узлов с портами и рёбрами; обход по плану; run узлов; буферы». Если в ядро движка внедрить ветки «если задача = диффузия, то …», «если узел = мир, то …», универсальность ломается и масштабирование под новые задачи будет требовать правок ядра. Поэтому **все** доменные знания должны находиться в **блоках** (и в конфиге структуры графа), а движок — только **ориентирует** и **передаёт данные**.
- **Расширяемость без изменений движка.** Новые типы узлов (новые блоки-задачи, новые виды пайплайнов) добавляются через **реестр** и **контракт** (порты, run); движок не меняется. Агентный цикл укладывается в модель «узел возвращает tool_calls; исполнитель выполняет подвызовы и повторяет узел» — без жёсткого кода «для агентов» в ядре, а с одной общей веткой «если в выходе узла есть tool_calls, выполнить подплан и повторить». Итог: **гиперграфовый движок, спроектированный и реализованный один раз правильно, позволяет фреймворку масштабироваться под любую задачу в рамках одной онтологии.**

---

## 7. Порядок выполнения и исполнитель

(Детали движка — планирование, буферы, кэш плана — см. §6 выше.)

### 7.1 Топологический порядок

- **Порядок обхода** узлов определяется топологией гиперграфа: топологическая сортировка по направлению рёбер (от внешних входов к внешним выходам). При **циклах** (backbone ↔ solver, agent_loop) топологическая сортировка даёт только частичный порядок; для циклов используется итеративная схема (см. ниже).
- Исполнитель (см. 00_FOUNDATION §7): для каждого узла в порядке обхода собрать входы по входящим рёбрам (и со внешних входов гиперграфа для портов, помеченных как exposed input), вызвать block.run(inputs), раздать выходы по исходящим рёбрам (и во внешние выходы гиперграфа).

### 7.2 Циклы: итеративная схема

- При **цикле** (например, в диффузии: Solver выдаёт next_latent и next_timestep обратно в Backbone, и так N шагов) исполнитель выполняет **фиксированное число итераций** или до выполнения условия остановки. На каждой итерации обновляются буферы на рёбрах; узлы в цикле вызываются в заданном порядке (например, сначала все Backbone вызовы по шагам, затем Solver — или попеременно Backbone → Solver на каждом шаге, в зависимости от контракта).
- Детали итеративной схемы (число шагов, порядок внутри цикла) задаются конфигом гиперграфа или узлов (например, num_inference_steps в диффузии).

### 7.3 Агентный цикл (agent_loop)

- Если в гиперграфе есть **узел-агент** (блок с агентным протоколом: tool_calls out, tool_results in), исполнитель поддерживает режим **agent_loop** (см. 01_ABSTRACT_TASK_BLOCKS §11):
  1. Вызвать agent.run(inputs) — на первом шаге inputs включают prompt/context с внешних входов гиперграфа.
  2. Если в выходе агента есть **tool_calls** — для каждого вызова выполнить соответствующий узел-инструмент (по таблице tool_id → node_id), собрать tool_results.
  3. Вызвать агента снова с inputs + tool_results; повторять до отсутствия tool_calls или до max_steps/stop.
  4. Выход гиперграфа — финальный **response** агента (и при необходимости другие внешние выходы).
- Рёбра от агента к инструментам — **динамические** (вызов по tool_id), а не статичные гиперрёбра; связь задаётся конфигом «какие инструменты доступны агенту».

---

## 8. Контракт run гиперграфа

- **Вход:** словарь **inputs** — значения для внешних входов гиперграфа. Ключи — имена входов (если заданы при expose_input) или пары (node_id, port_name). Значения — данные в формате, ожидаемом портами (тензоры, словари, строки и т.д.).
- **Выход:** словарь **outputs** — значения с внешних выходов гиперграфа. Ключи — имена выходов или (node_id, port_name); значения — результаты с соответствующих портов после выполнения всего гиперграфа (и при наличии агента — после завершения agent_loop).
- **Опции run:** training (bool), device, num_loop_steps (для итеративных циклов), max_steps (для agent_loop), callbacks, dry_run и т.д. — в зависимости от реализации.

Гиперграф уровня «задача» вызывается извне именно так: run(hypergraph, inputs) → outputs. Вышестоящий уровень (пайплайн) передаёт данные на внешние входы гиперграфа-узла и забирает данные с внешних выходов.

---

## 9. Сериализация уровня гиперграфа

- **Конфиг структуры:** как на фундаменте (00_FOUNDATION §10.1): nodes (node_id, block_type, block_id, config, trainable), edges, exposed_inputs, exposed_outputs; schema_version, graph_id, опционально graph_kind, metadata. Узлы — блоки-задачи, поэтому в config узла входят параметры конкретной реализации (архитектура, размерности и т.д.).
- **Чекпоинт:** state_dict каждого блока по node_id (включая состояние агента, если есть узел-агент). Формат — один файл (словарь node_id → state_dict) или директория с файлами по node_id.
- **Полное сохранение/загрузка:** save_dir содержит config.json (или config.yaml) и checkpoint.json (или директорию с чекпоинтами по узлам). load(save_dir, registry?) восстанавливает гиперграф из конфига через реестр и загружает чекпоинт в блоки.

Сериализация уровня гиперграфа **совпадает по формату** с сериализацией фундамента; отличие только в том, что узлы — экземпляры блоков-задач (создаются по block_type из реестра типов задач).

---

## 10. Примеры и типичные сценарии

| Сценарий | Узлы (идея) | Поток данных |
|----------|-------------|--------------|
| **Text-to-image** | Tokenizer → Conditioner; Conditioner → Backbone (condition); Codec (encode) → начальные латенты; Backbone + Solver в цикле (N шагов); Solver (финальные латенты) → Codec (decode) → image. Внешние входы: text (или prompt); внешний выход: image. |
| **Простая цепочка A → B → C** | Три узла-задачи; рёбра A.out → B.in, B.out → C.in. Внешние входы — порты A; внешние выходы — порты C. |
| **Агент + инструменты** | Один узел Agent, несколько узлов Tool; агент выдаёт tool_calls, исполнитель выполняет инструменты и передаёт tool_results агенту до завершения. Внешние входы: prompt; внешний выход: response. |

Минимальный воспроизводимый пример для фазы 2: гиперграф из 2–3 узлов-задач с потоком данных (например, A → B или A → B → C), вызов run(hypergraph, inputs), проверка outputs. Тест фиксирует конфиг и входы и проверяет совпадение выходов (или их структуры).

---

## 11. Связь с пайплайном (следующий уровень)

- **Пайплайн** — гиперграф, узлами которого являются **целые гиперграфы** (уровня задачи). По рёбрам пайплайна передаются **данные** между выходами одного гиперграфа и входами другого. Таким образом, гиперграф уровня задачи становится **узлом пайплайна**: снаружи он имеет только внешние входы и внешние выходы; внутренняя структура (узлы-задачи, рёбра) для пайплайна не важна.
- Контракт внешних входов/выходов гиперграфа (exposed_inputs, exposed_outputs) — это то, что пайплайн использует для соединения гиперграфов-узлов между собой. Спецификация пайплайна: [03_PIPELINE_LEVEL.md](03_PIPELINE_LEVEL.md).

---

## 12. Сводные таблицы

### 12.1 Уровень гиперграфа (кратко)

| Понятие | Определение |
|---------|-------------|
| **Гиперграф задачи** | Одна цельная задача (text-to-image, upscale, агент с инструментами и т.д.). Узлы — экземпляры блоков-задач; по рёбрам — данные между портами. |
| **Первый исполняемый уровень** | По гиперграфу передаются данные и выполняется run; вход/выход гиперграфа = внешние входы/выходы (exposed_inputs, exposed_outputs). |
| **Построение** | add_node(node_id, block_type, config, …), add_edge(…), expose_input/expose_output; или from_config(config). |
| **Валидация** | Существование узлов/портов, совместимость типов, обязательные порты, опционально связность и проверка циклов. |
| **Гиперграфовый движок** | Ядро фреймворка: структура, планировщик, буферы, исполнитель; единая модель на всех уровнях; масштабирование без изменений ядра (§6). |
| **Выше** | Пайплайн (гиперграф гиперграфов); данные между задачами. [03_PIPELINE_LEVEL.md](03_PIPELINE_LEVEL.md). |

### 12.2 Зависимости фаз

| Фаза | Результат |
|------|------------|
| 0 | Block, Node, гиперграф, исполнитель, реестр — структура и один узел с одним блоком исполняемы. |
| 1 | Абстрактные блоки-задачи, реестр типов задач; экземпляр узла-задачи можно положить в узел гиперграфа. |
| 2 | Гиперграф из нескольких узлов-задач, валидация, внешние входы/выходы, пример с 2–3 узлами и run. |

---

## 13. Критерии завершения фазы 2 (напоминание)

- Документ docs/02_HYPERGRAPH_LEVEL.md создан. ✓
- Реализованы построение гиперграфа из блоков-задач (add_node, add_edge, из конфига), валидация, внешние входы/выходы (expose_input, expose_output, run с inputs → outputs).
- Пример гиперграфа с несколькими узлами (2–3) выполняется; тест воспроизводим.
- Соответствие Philosophy и Scheme сохранено.

---

## 14. Ссылки

| Документ | Назначение |
|----------|------------|
| [Philosophy.md](../Philosophy.md) | П. 5.1–5.2: первый исполняемый уровень — гиперграф задачи; иерархия уровней. |
| [Scheme.md](../Scheme.md) | §3–4 — уровень графа задачи, иерархия. |
| [00_FOUNDATION.md](00_FOUNDATION.md) | Фундамент: Block, Node, гиперграф, исполнитель, реестр, валидация, сериализация. |
| [01_ABSTRACT_TASK_BLOCKS.md](01_ABSTRACT_TASK_BLOCKS.md) | Узлы-задачи: типы, контракты портов, типичные связи, автосвязывание, Agent, инструменты. |
| [PLAN_DEVELOPMENT_CANON.md](PLAN_DEVELOPMENT_CANON.md) | Фаза 2 — цели, документация, реализация, критерии. |
| [../WorldGenerator_2.0/Graph_Level.md](../WorldGenerator_2.0/Graph_Level.md) | Уровень графа в WG 2.0. |

---

**Итог.** Настоящий документ — **полная и глубокая техническая спецификация уровня гиперграфа** для Universe Generator 3.0. В нём заданы гиперграф задачи как первый исполняемый уровень (узлы = блоки-задачи, поток = данные), построение (узлы, рёбра, внешние входы/выходы), валидация, **гиперграфовый движок** (архитектура, планирование выполнения, построение и кэширование плана, буферы, жизненный цикл run, проектирование движка в проекте и масштабируемость без обрастания ядра задачами), порядок выполнения и агентный цикл, контракт run, сериализация и связь с пайплайном. Гиперграфовый движок описан как **центральная тема фреймворка**, от корректности которого зависит масштабирование под любую задачу. Реализация фазы 2 и последующий уровень пайплайна (фаза 3) опираются на эту спецификацию.
