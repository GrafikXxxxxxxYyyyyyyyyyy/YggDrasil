# 01. Уровень абстрактных блоков-задач — полная техническая спецификация

**Назначение:** глубокая и детальная **техническая документация уровня над фундаментом** для Universe Generator 3.0 (Yggdrasil). Документ задаёт **абстрактные типы узлов-задач** (Backbone, Solver, Codec, Conditioner, Adapter, Tokenizer, Guidance и др.), **двойное наследование** Block и Node, **спецификацию задачи** (контракт портов, семантика выполнения, типичные связи) по каждому типу, **реестр типов задач** и связь с фундаментом и уровнем гиперграфа. Это **канонический источник** технических решений уровня абстрактных блоков-задач в каноне 3.0.

**Якорь:** [Philosophy.md](../Philosophy.md) (п. 4.3–4.5); [Scheme.md](../Scheme.md) §2 (уровень над фундаментом).

**Предыдущий уровень:** [00_FOUNDATION.md](00_FOUNDATION.md) — Block, Node, гиперграф, реестр типов блоков.

**Референс:** [../WorldGenerator_2.0/Abstract_Task_Nodes.md](../WorldGenerator_2.0/Abstract_Task_Nodes.md), [../WorldGenerator_2.0/Abstract_Block_And_Node.md](../WorldGenerator_2.0/Abstract_Block_And_Node.md).

**Язык:** русский.

**Связь с планом:** [PLAN_DEVELOPMENT_CANON.md](PLAN_DEVELOPMENT_CANON.md) — фаза 1.

---

## 1. Место уровня в иерархии

| Уровень | Сущность | Описание |
|---------|----------|----------|
| **Фундамент** | Abstract Base Block, Abstract Graph Node | Материя и идея; блок хранит и выполняется; узел задаёт место и связи. Любой блок можно поместить в узел. [00_FOUNDATION.md](00_FOUNDATION.md). |
| **Над фундаментом** | Abstract Backbone, Solver, Codec, Adapter, Conditioner, Tokenizer, Guidance, … | **Узлы-задачи:** каждая сущность — одновременно блок и узел с **фиксированной задачей**. Задаёт контракт портов и семантику выполнения. Конкретные модели — реализации этих абстракций. |
| **Уровень гиперграфа** | Гиперграф, узлы которого — блоки-задачи | Один гиперграф = одна цельная задача; по рёбрам — данные между портами. [02_HYPERGRAPH_LEVEL.md](02_HYPERGRAPH_LEVEL.md) (создаётся в фазе 2). |

На уровне над фундаментом **не вводятся новые независимые сущности**: каждая абстракция — **ограничение и специализация** пары (Block, Node). Узел не «просто узел», а узел типа «backbone», «solver», «codec»; блок внутри такого узла — блок, реализующий соответствующую задачу. Конкретные реализации (UNet2D, DDIMSolver, AutoencoderKL, CLIP, LoRA и т.д.) — **экземпляры** этих абстракций, регистрируемые в реестре и используемые в узлах гиперграфа.

---

## 2. Зависимость от фундамента

- Уровень абстрактных блоков-задач **опирается на фазу 0**: контракт Block (порты, run, block_type, block_id), контракт Node (положение, гиперрёбра), правило блок→узел, структура гиперграфа, реестр типов блоков.
- Каждый **абстрактный узел-задача** реализует контракт Block и контракт Node (двойное наследование); экземпляр такого узла можно **положить в узел гиперграфа** (фаза 0) и выполнить run.
- **Реестр типов блоков** фундамента используется для создания экземпляров: block_type узла-задачи (например, `"backbone/unet2d"`, `"solver/ddim"`) сопоставляется классу или фабрике; конфиг передаётся в конструктор.

---

## 3. Двойное наследование и спецификация задачи

### 3.1 Двойное наследование

Каждая абстрактная сущность уровня над фундаментом **одновременно**:

1. **Наследует (реализует) Abstract Base Block** — хранит параметры, тензоры, конфиг, состояние; объявляет порты; выполняет `run`/`forward`; идентифицируется `block_type` и `block_id`.
2. **Наследует (реализует) Abstract Graph Node** — имеет положение в гиперграфе (node_id), участвует в гиперрёбрах, задаёт отображение портов на связи гиперграфа.

Таким образом, **узел-задача** — это блок с зафиксированной **решаемой задачей** (backbone, solver, codec, adapter и т.д.) и узел, для которого эта задача задаёт **роль в гиперграфе** и **ожидаемые связи** с другими узлами.

### 3.2 Спецификация задачи

**Спецификация задачи** для каждого типа узла задаёт:

| Элемент | Содержимое |
|---------|------------|
| **Семантика узла** | Что узел «понимает» о себе: например, backbone — «один шаг предсказания модели», solver — «один шаг дискретизации по времени». |
| **Контракт портов** | Имена и типы входных и выходных портов, назначение (что приходит, что уходит), опциональность. |
| **Семантика выполнения** | Что происходит при вызове run/forward: один шаг деноisingа, один шаг солвера, encode/decode и т.д. |
| **Типичные связи** | С какими типами узлов данный узел обычно соединяется (например, backbone получает condition от conditioner, pred потребляется solver’ом). |

Конкретная **реализация** (конкретный класс, например `UNet2DBackbone`, `DDIMSolver`) заполняет хранилище блока (архитектура, веса), реализует логику выполнения и соблюдает контракт портов абстракции.

### 3.3 Одна сущность как материя и форма

Философски (Philosophy 4.5): на уровне задач **атом сборки** — не «чистый блок» и не «чистый узел», а **блок-как-узел** — синтез в одном типе. Двойное наследование закрепляет это онтологически: каждая роль (Backbone, Solver, Codec, …) по определению и блок, и узел.

---

## 4. Abstract Backbone (абстрактный бэкбон)

### 4.1 Определение и задача

**Abstract Backbone** — узел гиперграфа, отвечающий за **ядро модели**: предсказание шума, один шаг деноisingа, предсказание в латентном пространстве (или аналог в не-диффузионных схемах). Backbone выполняет **один шаг предсказания** по текущему состоянию (латенты, таймстеп, условие) и выдаёт предсказание (шум, x0, v и т.д.). Дискретизация по времени — задача Solver, не Backbone.

### 4.2 Что хранит (материальное содержание)

| Категория | Содержимое |
|-----------|------------|
| Параметры и конфигурация | Архитектура (тип сети: UNet, трансформер, DiT и т.д.), размерности, число слоёв, конфиг внимания. `block_type` = `"backbone"` или подтип (`"backbone/unet2d"`, `"backbone/dit"`). |
| Тензоры и веса | Обучаемые веса модели (параметры сети). Кэш промежуточных активаций при необходимости. |
| Ссылки | Опционально: на кодек (размерности латентного пространства), на расписание (эмбеддинги таймстепа). |
| Состояние | state_dict для сохранения/загрузки чекпоинта. |

### 4.3 Контракт портов

| Порт | Направление | Тип (типично) | Назначение |
|------|-------------|---------------|------------|
| **latent** (или **x**) | Вход | Тензор | Текущее латентное состояние (или пиксели в pixel-space). |
| **timestep** (или **t**) | Вход | Тензор или скаляр | Текущий шаг времени / уровень шума. |
| **condition** (или **context**, **emb**) | Вход | Тензор, словарь | Условие от conditioner’ов (текст, изображение, эмбеддинги). Может быть опциональным. |
| **pred** (или **noise**, **x0**) | Выход | Тензор | Предсказание модели (шум ε, или x0, или v в v-parameterization). |

Имена портов и наличие дополнительных портов (например, **encoder_hidden_states**, **attention_mask**) задаются конкретной реализацией; абстракция фиксирует **семантику**: вход — состояние + таймстеп + условие, выход — предсказание.

### 4.4 Выполнение (семантика)

- **Вход:** латенты, таймстеп, условие (и опционально прочие входы).
- **Действие:** один прямой проход модели (forward pass): предсказание шума/значения по текущему состоянию.
- **Выход:** тензор предсказания.

Один вызов backbone = **один шаг предсказания**.

### 4.5 Типичные связи в гиперграфе

- **Вход latent:** от выхода Codec (decode) или от выхода Solver на предыдущем шаге; или внешний вход гиперграфа (начальные латенты).
- **Вход timestep:** от расписания (schedule) или от Solver.
- **Вход condition:** от узлов Conditioner.
- **Выход pred:** в Solver или во внешний выход гиперграфа.

### 4.6 Примеры конкретных реализаций

UNet 2D (диффузия изображений), трансформер (DiT, SD3), UNet 3D (видео), любая модель с контрактом (latent, timestep, condition) → pred.

---

## 5. Abstract Solver (абстрактный солвер)

### 5.1 Определение и задача

**Abstract Solver** — узел гиперграфа, отвечающий за **шаг дискретизации по времени**: по текущему состоянию (латенты, таймстеп) и предсказанию модели (от Backbone) выдаёт **следующее состояние** (латенты на следующем таймстепе). Solver выполняет один шаг схемы интегрирования (DDIM, DDPM, Heun, Euler и т.д.).

### 5.2 Что хранит

| Категория | Содержимое |
|-----------|------------|
| Параметры и конфигурация | Тип схемы (DDIM, Euler, …), параметры расписания (beta, sigma), число шагов. `block_type` = `"solver"` или подтип. |
| Тензоры и веса | Обычно солвер не содержит обучаемых весов; возможны кэши (расписание сигм). |
| Ссылки | Опционально на расписание шума. |
| Состояние | Конфиг и опционально кэш расписания для save/load. |

### 5.3 Контракт портов

| Порт | Направление | Тип | Назначение |
|------|-------------|-----|------------|
| **latent** (или **x**) | Вход | Тензор | Текущее латентное состояние. |
| **timestep** (или **t**) | Вход | Тензор или скаляр | Текущий таймстеп. |
| **pred** (или **model_output**) | Вход | Тензор | Предсказание от Backbone (шум, x0 или v). |
| **next_latent** (или **x_next**) | Выход | Тензор | Латенты на следующем таймстепе. |
| **next_timestep** (или **t_next**) | Выход | Тензор или скаляр | Следующий таймстеп (для цикла вызовов). |

### 5.4 Выполнение (семантика)

- **Вход:** latent, timestep, pred.
- **Действие:** по формуле выбранной схемы вычислить next_latent и опционально next_timestep.
- **Выход:** next_latent, next_timestep.

Один вызов solver = **один шаг** дискретизации.

### 5.5 Типичные связи

- **latent, timestep:** от предыдущего шага Solver или от начального состояния (внешний вход / Codec).
- **pred:** от Backbone.
- **next_latent, next_timestep:** в следующий вызов Backbone (и снова в Solver) или во внешний выход (финальное изображение после N шагов).

### 5.6 Примеры реализаций

DDIM, DDPM, Euler, Heun, flow matching solver.

---

## 6. Abstract Codec (абстрактный кодек)

### 6.1 Определение и задача

**Abstract Codec** — узел гиперграфа, отвечающий за **кодирование и декодирование представления**: переход между пространствами (например, пиксели ↔ латенты). Codec выполняет **encode** (пиксели → латенты) или **decode** (латенты → пиксели), или оба в зависимости от конфигурации/портов.

### 6.2 Что хранит

| Категория | Содержимое |
|-----------|------------|
| Параметры и конфигурация | Тип кодера/декодера (VAE, VQ и т.д.), размерности латентного пространства, scaling factor. `block_type` = `"codec"` или подтип. |
| Тензоры и веса | Веса энкодера и декодера. |
| Ссылки | Опционально на конфиг (разрешение, нормализация). |
| Состояние | state_dict для чекпоинта. |

### 6.3 Контракт портов

Типично два режима (или два набора портов).

**Encode:**

| Порт | Направление | Тип | Назначение |
|------|-------------|-----|------------|
| **image** (или **pixels**) | Вход | Тензор | Изображение в пиксельном пространстве. |
| **latent** | Выход | Тензор | Закодированные латенты. |

**Decode:**

| Порт | Направление | Тип | Назначение |
|------|-------------|-----|------------|
| **latent** | Вход | Тензор | Латенты. |
| **image** (или **pixels**) | Выход | Тензор | Декодированное изображение. |

В гиперграфе могут быть два узла (encode_codec и decode_codec) или один узел с разными портами/режимами вызова.

### 6.4 Выполнение (семантика)

- **Encode:** один проход энкодера: image → latent.
- **Decode:** один проход декодера: latent → image.

### 6.5 Типичные связи

- **Encode:** вход image — внешний вход гиперграфа или от предыдущего узла; выход latent — в Solver (начальное состояние) или в Backbone/Conditioner.
- **Decode:** вход latent — от выхода Solver (финальные латенты); выход image — во внешний выход гиперграфа или в постобработку.

### 6.6 Примеры реализаций

VAE (AutoencoderKL), VQ-VAE, кодек для видео (пространственно-временной).

---

## 7. Abstract Adapter (абстрактный адаптер)

### 7.1 Определение и задача

**Abstract Adapter** — узел гиперграфа, отвечающий за **адаптацию**: внедрение внешнего сигнала (условие, стиль, контроль) в пайплайн без замены всей модели. Adapter **модифицирует** входные или промежуточные активации другого блока (чаще всего Backbone) с учётом дополнительного условия (LoRA, инжектор, control net и т.д.).

### 7.2 Что хранит

| Категория | Содержимое |
|-----------|------------|
| Параметры и конфигурация | Тип адаптера (LoRA, injection, control), места инжекции, ранг. `block_type` = `"adapter"` или подтип. |
| Тензоры и веса | Обучаемые веса адаптера (LoRA-матрицы, веса инжекторных слоёв). |
| Ссылки | На блок, к которому применяется адаптация (часто Backbone). |
| Состояние | state_dict. |

### 7.3 Контракт портов

| Порт | Направление | Тип | Назначение |
|------|-------------|-----|------------|
| **condition** (или **control**, **style**) | Вход | Тензор, изображение, словарь | Внешнее условие (эмбеддинг, карта контроля, стиль). |
| **hidden** (или **activations**) | Вход | Тензор | Промежуточные активации блока, который адаптируется. |
| **adapted** (или **output**) | Выход | Тензор | Модифицированные активации (hidden + вклад адаптера). |

Вариант: adapter может выдавать только «дополнение» (delta), которое граф складывает с hidden в другом узле.

### 7.4 Выполнение (семантика)

- Принимает condition и опционально hidden.
- Вычисляет вклад адаптера и возвращает adapted (или delta).

### 7.5 Типичные связи

- **condition:** от Conditioner или от внешнего входа (control image, style).
- **hidden:** от Backbone (промежуточные слои) или от узла, агрегирующего активации.
- **adapted:** обратно в Backbone или в следующий слой.

### 7.6 Примеры реализаций

LoRA, ControlNet, T2I-Adapter, IP-Adapter, style injection.

---

## 8. Abstract Conditioner (абстрактный кондиционер)

### 8.1 Определение и задача

**Abstract Conditioner** — узел гиперграфа, отвечающий за **подготовку условия**: преобразование сырого ввода (текст, изображение, аудио) в форму, пригодную для Backbone (эмбеддинги, скрытые состояния). Conditioner **кодирует условие** для последующего использования в модели.

### 8.2 Что хранит

| Категория | Содержимое |
|-----------|------------|
| Параметры и конфигурация | Тип энкодера (CLIP, T5 и т.д.), размерность выхода, пулинг. `block_type` = `"conditioner"` или подтип. |
| Тензоры и веса | Веса энкодера условия. |
| Состояние | state_dict. |

### 8.3 Контракт портов

| Порт | Направление | Тип | Назначение |
|------|-------------|-----|------------|
| **input** (или **text**, **image**, **prompt**) | Вход | Строка, тензор, токены | Сырое условие (промпт, изображение для кодирования). |
| **embedding** (или **encoder_hidden_states**, **condition**) | Выход | Тензор, словарь | Закодированное условие для Backbone. |

Может быть несколько выходных портов (pooled embedding + hidden states).

### 8.4 Выполнение (семантика)

- Вход: сырой ввод (текст, изображение).
- Один проход энкодера условия.
- Выход: эмбеддинги/скрытые состояния.

### 8.5 Типичные связи

- **input:** внешний вход гиперграфа (промпт) или выход Tokenizer (token_ids).
- **embedding:** в Backbone (порт condition), в Adapter или в несколько потребителей.

### 8.6 Примеры реализаций

CLIP text encoder, T5, BERT; CLIP image encoder (для IP-Adapter и аналогов).

---

## 9. Abstract Tokenizer (абстрактный токенайзер)

### 9.1 Определение и задача

**Abstract Tokenizer** — узел гиперграфа, отвечающий за **преобразование дискретного сырого ввода в токены и обратно**: текст → идентификаторы токенов; при необходимости decode: токены → текст. Tokenizer **нормализует и сегментирует** ввод в последовательность токенов для Conditioner, языковых моделей и т.д. Вынесение в отдельный узел даёт явную границу текст↔токены и единый контракт портов.

### 9.2 Что хранит

| Категория | Содержимое |
|-----------|------------|
| Параметры и конфигурация | Тип (BPE, SentencePiece, WordPiece), путь к словарю/мержам, специальные токены, max_length. `block_type` = `"tokenizer"` или подтип. |
| Данные | Словарь (vocab), мержи (BPE), модель (SentencePiece). |
| Состояние | Конфиг и опционально кэш для save/load. |

### 9.3 Контракт портов

| Порт | Направление | Тип | Назначение |
|------|-------------|-----|------------|
| **text** (или **input_text**, **prompt**) | Вход | Строка или список строк | Сырой текст. |
| **token_ids** (или **input_ids**) | Выход | Тензор целых [batch, length] | Идентификаторы токенов. |
| **attention_mask** (опционально) | Выход | Тензор | Маска длины последовательности. |

Для **decode**: опциональные порты token_ids (вход) и text (выход).

### 9.4 Выполнение (семантика)

- **Encode:** текст → нормализация, разбиение на токены, отображение в ID → token_ids (и при необходимости attention_mask).
- **Decode:** token_ids → ID → токены, склейка в строку → текст.

### 9.5 Типичные связи

- **Вход text:** внешний вход гиперграфа (промпт) или выход другого узла.
- **Выход token_ids:** в Conditioner, в языковую модель. Один узел Tokenizer может обслуживать несколько потребителей с одним словарём.

### 9.6 Примеры реализаций

BPE (GPT-2/CLIP style), SentencePiece, WordPiece (BERT-style), специализированные токенайзеры.

---

## 10. Abstract Guidance (абстрактный гайданс)

### 10.1 Определение и задача

**Abstract Guidance** — узел гиперграфа, отвечающий за **коррекцию предсказания** по дополнительному сигналу (классификатор, энергия, reward): модификация выхода Backbone или Solver с учётом guidance-функции (CFG, reward-based guidance и т.д.).

### 10.2 Что хранит

Конфиг (сила guidance, тип: CFG, reward); опционально веса (если guidance — модель). `block_type` = `"guidance"` или подтип.

### 10.3 Контракт портов (типично)

| Порт | Направление | Назначение |
|------|-------------|------------|
| **pred_cond** | Вход | Предсказание условной модели. |
| **pred_uncond** | Вход | Предсказание безусловной модели. |
| **scale** | Вход | Коэффициент guidance (опционально). |
| **pred_guided** | Выход | Комбинированное предсказание (например, pred_uncond + scale * (pred_cond - pred_uncond)). |

Вариант: один узел принимает только pred и condition и вычисляет скорректированное предсказание по своей логике.

### 10.4 Выполнение и связи

- Вычисление скорректированного предсказания; выход идёт в Solver или во внешний выход.
- Примеры реализаций: CFG block, PAG, reward-based guidance.

---

## 11. Дополнительные абстрактные типы (кратко)

| Тип | Задача | Типичные порты (идея) |
|-----|--------|------------------------|
| **Abstract PositionEmbedder** | Позиционное кодирование (sinusoidal, learned) для таймстепа или позиции. | Вход: indices/timestep. Выход: embedding. |
| **Abstract Pooler** | Агрегация последовательности (pooling) в один вектор. | Вход: sequence. Выход: vector. |
| **Abstract Projection** | Отображение размерности (condition → размер входа backbone). | Вход: tensor. Выход: tensor другой размерности. |

Каждый задаётся по той же схеме: двойное наследование Block + Node, спецификация задачи, контракт портов, семантика выполнения, типичные связи. При необходимости добавляются в канон и реестр.

**Abstract Agent** и узлы-инструменты — отдельная тема; см. референс [../WorldGenerator_2.0/AGENT_SYSTEMS_SUPPORT.md](../WorldGenerator_2.0/AGENT_SYSTEMS_SUPPORT.md).

---

## 12. Реестр типов задач

### 12.1 Назначение

Реестр типов блоков (фундамент) используется и для узлов-задач: **block_type** задаёт абстрактный тип или конкретную реализацию (например, `"backbone"`, `"backbone/unet2d"`, `"solver/ddim"`). Регистрация связывает строку с классом или фабрикой; по конфигу с полем `block_type` создаётся экземпляр узла-задачи.

### 12.2 Регистрация и создание

- **Регистрация:** `registry.register(block_type, BlockClass)` или `registry.register(block_type, factory_fn)`. Подтипы (например, `backbone/unet2d`) регистрируются отдельно для конкретных реализаций.
- **Создание:** `block = registry.build(config)`, где `config` содержит `block_type` (или `type`) и остальные параметры (block_id, конфиг архитектуры и т.д.). Возвращается экземпляр, реализующий Block (и по определению Node при двойном наследовании).
- Новый тип задачи добавляется **без изменений ядра** — реализация контракта абстракции и регистрация.

### 12.3 Связь с гиперграфом (фаза 0)

Экземпляр узла-задачи можно **положить в узел гиперграфа**: создать Node(node_id, block), где block — экземпляр Backbone, Solver, Codec и т.д. Гиперграф фазы 0 выполняет run по топологии; блок вызывается с входами, собранными по входящим рёбрам. Критерий готовности фазы 1: экземпляр узла-задачи создаётся и выполняется в рамках гиперграфа фазы 0.

---

## 13. Автосвязывание и типичные связи

- **Типичные связи** заданы спецификацией каждого абстрактного типа (см. разделы 4–10): какие порты с какими типами узлов обычно соединяются. Например: выход Tokenizer → вход Conditioner; выход Conditioner → вход Backbone (condition); выход Backbone → вход Solver (pred); выход Solver (next_latent) → вход Backbone (latent) на следующей итерации.
- **Автосвязывание (auto_connect):** при добавлении узла в гиперграф система может **выводить** части рёбер по ролям узлов-задач: по типу узла (backbone, solver, codec, …) определяются ожидаемые партнёры и порты, и рёбра предлагаются или создаются автоматически. Пользователю не обязательно задавать каждое ребро вручную — сборка гиперграфа задачи (например, text-to-image) может сводиться к добавлению нужных узлов и опционально явному связыванию портов. Детали автосвязывания относятся к уровню гиперграфа (фаза 2) и могут быть описаны в docs/02_HYPERGRAPH_LEVEL.md.
- На **фазе 1** достаточно того, что контракты портов и типичные связи **заданы** в каноне; реализация автосвязывания — при сборке гиперграфа.

---

## 14. Сериализация уровня

- В **конфиге гиперграфа** (или пайплайна, мира) каждый узел задаётся: `node_id`, `block_type` (строка, соответствующая абстрактному типу или конкретной реализации), `config` (словарь конфига блока). При загрузке по `block_type` создаётся блок через реестр, конфиг передаётся в конструктор.
- **Чекпоинт** сохраняет state_dict каждого блока (backbone, codec, conditioner, tokenizer, adapter и т.д.); при загрузке конфига и чекпоинта узлы создаются, веса загружаются. Сериализация та же, что на фундаменте (00_FOUNDATION §10); абстрактный тип не сериализуется отдельно — задан в коде и схеме конфига; сериализуются **экземпляры** с их block_type и config.

---

## 15. Отличия от WG 2.0 и совпадения

| Аспект | WG 2.0 | Канон 3.0 (уровень абстрактных блоков-задач) |
|--------|--------|-----------------------------------------------|
| **Перечень типов** | Backbone, Solver, Codec, Adapter, Conditioner, Tokenizer, Guidance, NoiseSchedule, PositionEmbedder, Pooler, Projection, Agent. | То же; перечень может расширяться в каноне без смены философии. |
| **Двойное наследование** | Block + Node в одной сущности. | То же; Philosophy 4.5. |
| **Спецификация задачи** | Семантика узла, контракт портов, семантика выполнения, типичные связи. | То же; зафиксировано в данном документе. |
| **Реестр** | block_type → класс/фабрика; build(config). | Используется реестр типов блоков фундамента; тот же механизм. |
| **Сборка графа** | AddNode, автосвязывание по ролям, рёбра по контрактам. | Сборка — на уровне гиперграфа (фаза 2); контракты и типичные связи заданы здесь. |

Итог: уровень абстрактных блоков-задач в 3.0 **совместим по духу и контракту** с WG 2.0 Abstract_Task_Nodes; настоящий документ — единый канонический источник для 3.0.

---

## 16. Сводные таблицы

### 16.1 Узлы-задачи (семантика)

| Абстрактный тип | Задача | Ключевые входы | Ключевые выходы |
|-----------------|--------|----------------|------------------|
| **Backbone** | Шаг предсказания модели | latent, timestep, condition | pred |
| **Solver** | Шаг дискретизации по времени | latent, timestep, pred | next_latent, next_timestep |
| **Codec** | Encode/decode представления | image или latent | latent или image |
| **Adapter** | Адаптация по условию | condition, [hidden] | adapted |
| **Conditioner** | Кодирование условия | text/image/token_ids | embedding |
| **Tokenizer** | Текст ↔ токены | text | token_ids [, attention_mask] |
| **Guidance** | Коррекция предсказания | pred_cond, pred_uncond, [scale] | pred_guided |

### 16.2 Иерархия уровней (фрагмент)

| Уровень | Сущности |
|---------|-----------|
| Фундамент | Abstract Base Block, Abstract Graph Node, гиперграф, реестр типов блоков |
| Над фундаментом | Abstract Backbone, Solver, Codec, Adapter, Conditioner, Tokenizer, Guidance, … |
| Конкретные реализации | UNet2D, DDIMSolver, AutoencoderKL, LoRA, CLIPEncoder, BPE, … |
| Гиперграф задачи | Узлы = экземпляры реализаций; гиперрёбра = связи портов; один гиперграф = одна задача |

---

## 17. Критерии завершения фазы 1 (напоминание)

- Документ docs/01_ABSTRACT_TASK_BLOCKS.md создан. ✓
- Реализованы абстрактные типы узлов-задач (минимум 2–3), двойное наследование, реестр типов задач (или использование реестра фундамента с регистрацией типов задач).
- Экземпляр узла-задачи создаётся и выполняется в рамках гиперграфа фазы 0.
- Соответствие Philosophy и Scheme сохранено.

---

## 18. Ссылки

| Документ | Назначение |
|----------|------------|
| [Philosophy.md](../Philosophy.md) | П. 4.3–4.5: уровень над фундаментом, абстрактные узлы-задачи, двойное наследование, конечный набор абстракций → бесконечное множество решений. |
| [Scheme.md](../Scheme.md) | §2 — основание, уровень над фундаментом (абстрактные узлы-задачи). |
| [00_FOUNDATION.md](00_FOUNDATION.md) | Фундамент: Block, Node, гиперграф, реестр, исполнитель. |
| [PLAN_DEVELOPMENT_CANON.md](PLAN_DEVELOPMENT_CANON.md) | Фаза 1 — цели, документация, реализация, критерии. |
| [../WorldGenerator_2.0/Abstract_Task_Nodes.md](../WorldGenerator_2.0/Abstract_Task_Nodes.md) | Полное описание узлов-задач в WG 2.0. |
| [../WorldGenerator_2.0/Abstract_Block_And_Node.md](../WorldGenerator_2.0/Abstract_Block_And_Node.md) | Фундамент WG 2.0. |

---

**Итог.** Настоящий документ — **полная и глубокая техническая спецификация уровня абстрактных блоков-задач** для Universe Generator 3.0. В нём заданы двойное наследование Block и Node, спецификация задачи по каждому типу (Backbone, Solver, Codec, Conditioner, Adapter, Tokenizer, Guidance и дополнительным), контракты портов, семантика выполнения, типичные связи, реестр, сериализация и связь с фундаментом и уровнем гиперграфа. Реализация фазы 1 и последующий уровень гиперграфа (фаза 2) опираются на эту спецификацию.
