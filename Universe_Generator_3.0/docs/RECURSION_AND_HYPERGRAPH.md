# Рекурсия и гиперграфовая структура Иггдрасиль

**Назначение:** техническое описание того, **как идея и реализации рекурсии** встраиваются в Yggdrasil (Universe Generator 3.0) и **естественно уживаются с гиперграфовой структурой**. Документ опирается на канон уровней (00–06), Philosophy (композиция, п. 3.7 — рекурсия и глубина) и не вводит новых онтологических сущностей: рекурсия обеспечивается **единым контрактом run**, **композицией уровней** и **возможностью вложенности** (блок в блоке, граф в графе при сохранении контракта).

**Якорь:** [Philosophy.md](../Philosophy.md) п. 3.7 (рекурсия и глубина композиции), п. 2 (композиция — блок из блоков); [00_FOUNDATION.md](00_FOUNDATION.md) §3.6; [02_HYPERGRAPH_LEVEL.md](02_HYPERGRAPH_LEVEL.md) §6.2, §6.10.

**Язык:** русский.

---

## 1. Идея рекурсии в проекте

Под **рекурсией** в контексте Иггдрасиль понимаются:

1. **Структурная рекурсия (глубина композиции):** сущность одного типа может содержать внутри себя сущности того же или нижележащего типа (блок — подблоки; узел гиперграфа — блок, который сам может быть «обёрткой» над вложенным гиперграфом). Глубина вложенности не ограничена онтологией.
2. **Иерархическая композиция уровней:** гиперграф задачи → узел пайплайна → узел Stage → узел мира → узел вселенной. Каждый следующий уровень — гиперграф, узлами которого являются сущности предыдущего уровня; выполнение на уровне N сводится к вызову **run** узлов, каждый из которых на уровне N−1 сам может быть гиперграфом с тем же контрактом run. Это **рекурсия по уровням** (делегирование вниз).
3. **Рекурсия выполнения (итерация до сходимости):** повторный вызов одного и того же гиперграфа (или узла) с обновлением данных до выполнения условия (фиксированное число шагов, фикспойнт, критерий останова). Уже частично присутствует в каноне (циклы в графе задачи, num_loop_steps; agent_loop).

Рекурсия **не требует отдельного «режима»** в движке: она вытекает из **единой формы** (гиперграф узлов с портами и run) и из **одного контракта** на всех уровнях.

---

## 2. Единый контракт run и естественная рекурсия

Во всей иерархии (02 §6.2, 02 §6.10) узел для движка — **чёрный ящик** с операцией **run(inputs) → outputs**. Движок не различает, что внутри узла: один блок, вложенный гиперграф или целый пайплайн. Он только:

- собирает входы по входящим рёбрам (и внешним входам гиперграфа);
- вызывает **run** узла (т.е. run блока или run вложенного гиперграфа/пайплайна/Stage/мира);
- раздаёт выходы по исходящим рёбрам (и во внешние выходы).

Если узел реализован как **вложенный гиперграф**, то его run внутри себя использует **тот же движок** (или ту же семантику обхода, буферов и вызова run для своих узлов). Получается **рекурсивный вызов движка** без явной рекурсии в коде «для рекурсии»: рекурсия — это **делегирование** run вложенной структуре, которая снова обращается к тому же примитиву выполнения.

Технически обеспечить это можно так:

- На уровне **гиперграфа задачи** узел содержит блок; блок может быть **композитным** (00 §3.6): внутри — подблоки и внутренний подграф/пайплайн, снаружи — тот же контракт run. Выполнение такого блока = внутренний вызов того же движка по внутреннему подграфу.
- На уровне **пайплайна** узел = гиперграф задачи; run узла = run(hypergraph, inputs) → outputs. Внутри гиперграфа снова используется движок (обход узлов-блоков). То есть **движок вызывается рекурсивно**: пайплайн → движок обходит узлы-гиперграфы → для каждого узла вызывается run гиперграфа → внутри него движок обходит узлы-блоки.
- Аналогично для **Stage** (узел = пайплайн), **мира** (узел = Stage), **вселенной** (узел = мир). На каждом шаге «run узла» делегируется уровню ниже, где снова применяется та же логика (гиперграф, план, буферы, run узлов).

Таким образом, **гиперграфовая структура уже рекурсивна по конструкции**: рекурсия заложена в том, что узел может быть «целым гиперграфом нижележащего уровня» с тем же интерфейсом run.

---

## 3. Где рекурсия уже есть в каноне

| Место | Как реализовано |
|-------|------------------|
| **Блок из блоков** (00 §3.6, Philosophy 2) | Блок может содержать подблоки; выполнение = внутренний подграф или пайплайн. Снаружи — тот же контракт Block (порты, run). |
| **Гиперграф как узел пайплайна** (03) | Узел пайплайна = гиперграф задачи. run(pipeline, inputs) вызывает run(hypergraph, inputs) для каждого узла-гиперграфа. Внутри гиперграфа — тот же движок. |
| **Пайплайн как узел Stage** (04) | Узел Stage = пайплайн. run(Stage, state) вызывает run(pipeline, inputs) для узлов-пайплайнов. Вложенность без ограничения глубины в онтологии. |
| **Stage как узел мира** (05) | Узел мира = Stage. run(World, state) вызывает run(Stage, state) для каждого перехода. |
| **Мир как узел вселенной** (06) | Узел вселенной = мир. run(Universe, …) вызывает run(World, …) для каждого мира. |
| **Конфиг и сериализация** | Вложенные конфиги (гиперграф в пайплайне, пайплайн в Stage и т.д.); from_config рекурсивно строит вложенные структуры. Глубина задаётся конфигом, а не жёстким лимитом онтологии. |

Философски это закреплено в Philosophy 3.7: **рекурсия и произвольная глубина композиции — поддерживаемая возможность**; «блок внутри блока», «граф внутри графа», при расширении «мир внутри мира» допускаются онтологией.

---

## 4. Рекурсия «в одном уровне» (same-level recursion)

Кроме **иерархической** рекурсии (узел = сущность уровня ниже) возможна **одноуровневая** вложенность: узел того же уровня, что и контейнер, но реализованный как вложенная структура того же типа.

Примеры:

- **Гиперграф задачи, узел которого — снова гиперграф задачи.** Формально такой узел уже есть на уровне пайплайна (пайплайн = гиперграф гиперграфов). Если же мы хотим «гиперграф, один из узлов которого — подгиперграф» внутри одного уровня задачи, то этот узел реализуется как **блок-обёртка**, внутри которого хранится гиперграф и run блока = run(inner_hypergraph, inputs) → outputs. Контракт соблюдён; движок на уровне контейнера просто вызывает run узла и не знает, что внутри — ещё один граф. Реализация: тип блока «SubGraph» или «NestedGraph», в конфиге — вложенный конфиг гиперграфа; при run вызывается тот же движок по этому конфигу.
- **Пайплайн, один из узлов которого — пайплайн.** Аналогично: узел пайплайна может быть не «один гиперграф», а «пайплайн» (список гиперграфов с рёбрами между ними). Тогда узел реализует run(pipeline, inputs) → outputs; внутри — тот же движок пайплайна (обход гиперграфов, буферы на рёбрах пайплайна). Конфиг узла — вложенный конфиг пайплайна.
- **Мир внутри мира (world-in-world).** Если в сценарии нужен «мир, один из переходов которого — целый подмир» (например, сцена внутри сцены со своим циклом), то узел мира (переход) может быть реализован как **Stage, внутри которого один из пайплайнов вызывает целый мир**. Или в конфиге мира один из Stage задаётся как «вложенный мир»: тип узла World, run узла = run(inner_world, state?, action?) → state. Онтология это допускает (Philosophy 3.7); технически — делегирование run вложенному миру с тем же контрактом.

Общий принцип: **на любом уровне узел может быть не только «атомарной» сущностью этого уровня, но и обёрткой над вложенной структурой того же или нижележащего типа**, при условии что эта структура реализует **run(inputs) → outputs** (или run(state) → state на уровне мира). Движок не меняется; добавляются только **типы блоков/узлов** (например, NestedGraph, NestedPipeline, SubWorld), реализующие контракт через внутренний вызов того же движка.

---

## 5. Рекурсия выполнения (итерация до сходимости)

Кроме **структурной** рекурсии полезна **рекурсия по выполнению**: один и тот же граф (или узел) вызывается многократно, пока не выполнится условие.

- **Уже в каноне:** цикл в гиперграфе задачи (Backbone ↔ Solver) с **num_loop_steps** (02 §6.5); **agent_loop** (повторный вызов узла-агента до отсутствия tool_calls). Это по сути «рекурсивный» вызов в смысле повторения одного и того же узла/подграфа с обновлёнными данными на рёбрах.
- **Расширение:** опция run вида **run_until(hypergraph, inputs, condition)** или **max_iterations + fixpoint_check**: выполнять run гиперграфа, проверять condition(outputs); если не выполнено — подать outputs (или их часть) снова на вход и повторить. Условие может быть «выход не изменился» (фикспойнт) или явный предикат. Реализация — тонкая обёртка над существующим run: цикл while not condition: outputs = run(hypergraph, inputs); inputs = f(outputs). Никаких изменений в ядре движка не требуется; рекурсия выполнения — **политика вызова** run, а не новая сущность.

Так рекурсия выполнения **уживается с гиперграфом**: гиперграф и его run остаются однопроходными (или с уже заданным числом итераций цикла внутри плана); многократный вызов с обновлением входа — на уровне оркестрации (run_until, refinement loop).

---

## 6. Реализационные рекомендации

Чтобы рекурсия естественно сосуществовала с гиперграфовой структурой:

1. **Не вводить жёсткой максимальной глубины в онтологии.** Ограничение глубины вложенности — вопрос политики (лимит в конфиге, защита от переполнения стека) или ресурсов, а не «запрет рекурсии» в модели. Philosophy 3.7 явно допускает произвольную глубину.
2. **Единый движок и один контракт run.** На каждом уровне узел предоставляет run(inputs) → outputs (или run(state) → state). Реализация узла может внутри вызывать тот же движок по вложенной структуре — без дублирования логики обхода и буферов.
3. **Типы-обёртки для вложенности.** Для same-level recursion ввести (при необходимости) типы блоков/узлов: NestedGraph, NestedPipeline, SubWorld и т.д., конфиг которых содержит вложенный конфиг структуры; run = делегирование движку по этой структуре. Реестр и контракт блоков позволяют добавлять такие типы без изменений ядра.
4. **План и кэш.** При вложенных структурах план выполнения строится **для каждого гиперграфа отдельно** (при первом run вложенного графа или при его загрузке). Кэш плана привязан к версии структуры своего графа; рекурсия не ломает кэширование, так как каждый уровень имеет свой план.
5. **Сериализация.** Вложенные конфиги уже поддерживаются (03, 04, 05, 06); при сохранении чекпоинта рекурсивно сохраняются чекпоинты вложенных миров/пайплайнов/графов (05 §14, 06 §12). Рекурсия глубины лишь увеличивает дерево сохраняемых артефактов.

---

## 7. Краткая сводка

| Аспект | Как рекурсия уживается с гиперграфом |
|--------|--------------------------------------|
| **Контракт** | Один run(inputs) → outputs на всех уровнях; узел может быть вложенным гиперграфом с тем же run → естественное делегирование (рекурсия вызова). |
| **Движок** | Реализован один раз; на уровне N при вызове run узла вызывается run вложенной структуры уровня N−1 (или того же уровня), внутри которой снова используется тот же движок. |
| **Структура** | Блок может содержать подблоки (00); граф — узел пайплайна; пайплайн — узел Stage; мир — узел вселенной. Same-level: узел может быть обёрткой над вложенной структурой того же типа (NestedGraph, SubWorld и т.д.). |
| **Выполнение** | Итерация до сходимости (run_until, refinement) — цикл вызовов run с обновлением входа; не требует изменений ядра, только обёртка над run. |
| **Онтология** | Philosophy 3.7: рекурсия и произвольная глубина — поддерживаемая возможность; ограничения — по ресурсам и политике, не по модели. |

Рекурсия в Иггдрасиль не является отдельным «режимом» или надстройкой: она **вытекает из единой гиперграфовой формы и единого контракта run** и обеспечивается делегированием выполнения вложенным структурам, реализующим тот же контракт.

---

## 8. Ссылки

| Документ | Назначение |
|----------|------------|
| [Philosophy.md](../Philosophy.md) | П. 3.7 — рекурсия и глубина композиции; п. 2 — композиция (блок из блоков). |
| [00_FOUNDATION.md](00_FOUNDATION.md) | §3.6 — блок из блоков, контракт. |
| [02_HYPERGRAPH_LEVEL.md](02_HYPERGRAPH_LEVEL.md) | §6 — движок, единый контракт, делегирование/рекурсия на уровне пайплайна и выше. |
| [03_PIPELINE_LEVEL.md](03_PIPELINE_LEVEL.md) | Гиперграф как узел пайплайна. |
| [04_STAGE_LEVEL.md](04_STAGE_LEVEL.md) | Пайплайн как узел Stage. |
| [05_WORLD_LEVEL.md](05_WORLD_LEVEL.md) | Stage как узел мира; сериализация рекурсивно. |
| [06_UNIVERSE_LEVEL.md](06_UNIVERSE_LEVEL.md) | Мир как узел вселенной. |
