# Уровень над фундаментом: абстрактные узлы-задачи

**Описание следующего уровня иерархии Yggdrasil** — уровня абстрактных специализированных блоков (узлов-задач). Этот документ раскрывает и детализирует раздел 6 файла [Philosophy.md](Philosophy.md) и опирается на **аналогию фундаментального уровня с фермионами и бозонами** (Philosophy, п. 4.4).

---

## 1. Место уровня в иерархии

Уровень **абстрактных узлов-задач** расположен **сразу над фундаментальным уровнем**:

- **Ниже** — фундамент: **Abstract Base Block** (материя; по аналогии — фермионы) и **Abstract Graph Node** (идея, форма в графе; по аналогии — бозоны). Логика «блок → узел»: любой базовый блок может стать узлом графа.
- **На данном уровне** — абстрактные сущности, которые **одновременно** являются и блоком, и узлом графа и при этом **задают спецификацию задачи**: backbone, solver, codec, adapter, conditioner, guidance, position embedder и т.д.
- **Выше** — промежуточные ступени (граф как целое, модальность, контекст) и верхний уровень (World, Universe).

Таким образом, это уровень **задач**: узел в графе здесь не «просто узел», а узел с зафиксированной ролью. В физической аналогии: над «элементарными» фермионами и бозонами располагаются **частицы с определённой ролью** — типы (species), каналы взаимодействия, вершины определённого рода; так и здесь над Block и Node располагаются **типы узлов с определённой задачей**, из которых собирается граф.

---

## 2. Двойное наследование: Block + Node

Каждая абстрактная сущность этого уровня должна **одновременно**:

| Наследование / контракт | Назначение | Аналогия в физике |
|-------------------------|------------|-------------------|
| **Abstract Base Block** | Хранить параметры, тензоры, конфиг; выполнять вычисления; объявлять порты и идентичность. **Материя** — то, что лежит в узле. | **Фермионная природа**: носитель «содержимого» (как фермион — носитель заряда, массы). |
| **Abstract Graph Node** | Иметь положение в графе (имя узла), входящие и исходящие рёбра, семантику портов на уровне графа. **Идея** — место и связи в целое. | **Бозонная природа**: задаёт «взаимодействие» и связь с другими узлами (как бозон переносит взаимодействие). |

Итог: **Abstract Backbone**, **Abstract Solver**, **Abstract Codec**, **Abstract Adapter** и аналогичные классы — это **узлы-задачи**: каждая сущность по-прежнему совмещает фермионоподобное (Block) и бозоноподобное (Node) начало, но при этом имеет **фиксированную «квантовую характеристику»** — решаемую задачу. Они образуют «словарь» типов узлов (аналог: словарь типов частиц или типов вершин в диаграмме), из которых собирается любой пайплайн.

---

## 3. Спецификация задачи по типам узлов

Каждый абстрактный класс задаёт **что решает** соответствующий узел в графе. Ниже — типы узлов и их **физическая аналогия**: какой «ролью» в процессе (вычислении) или в диаграмме они соответствуют.

### 3.1 Основные типы

| Абстрактная сущность | Задача (спецификация) | Аналогия в физике |
|----------------------|------------------------|-------------------|
| **Abstract Backbone** | Ядро модели: предсказание шума, шаг деноisingа, предсказание в латентном пространстве. Выполняет шаг диффузии/трансформации. | **Сектор динамики / гамильтониан**: «кто задаёт эволюцию» системы (ядро уравнения, ядро взаимодействия). Аналог — оператор эволюции или основное взаимодействие в лагранжиане. |
| **Abstract Solver** | Шаг назад по диффузии: по предсказанию модели и текущему состоянию выдаёт следующее состояние (латенты, таймстеп). Шаг солвера (DDIM, Heun, Euler и т.д.). | **Пропагатор / дискретный шаг эволюции**: перенос состояния во времени (интегратор, шаг по времени). Аналог — пропагатор \( e^{-iHt} \) или разностная схема. |
| **Abstract Codec** | Кодирование и декодирование представления: пиксели ↔ латенты, сжатие, другое пространство. Работа с encode/decode и представлением данных. | **Смена представления / базиса**: переход между пространствами (координата ↔ импульс, конфигурационное ↔ латентное). Аналог — преобразование Фурье, смена базиса в квантовой механике. |
| **Abstract Adapter** | Адаптация: дополнительные условия, контроль, стиль; встраивание внешнего сигнала в пайплайн. Адаптирует условие или модель. | **Внешнее поле / связь с внешним миром**: потенциал, источник, калибровочное поле. Аналог — внешнее поле, подмешиваемое в лагранжиан, или канал связи с «наблюдателем». |

### 3.2 Дополнительные типы

| Абстрактная сущность | Задача (спецификация) | Аналогия в физике |
|----------------------|------------------------|-------------------|
| **Abstract Conditioner** | Условность: ввод текста, класса, эмбеддингов в модель. | **Условие / граничное условие или квантовое число**: фиксированное значение «заряда» или «состояния», задающее ветвь процесса. |
| **Abstract Guidance** | Guidance: масштабирование или модификация градиентов/предсказаний (CFG, безградиентные схемы). | **Масштабирование канала / усиление вклада**: аналог усиления определённой компоненты взаимодействия или ветви амплитуды. |
| **Abstract PositionEmbedder** | Позиционное кодирование: таймстеп, разрешение, позиция в последовательности. | **Пространственно-временная метка / ковариантная производная**: привязка к месту и времени в «пространстве» вычисления. |
| *(далее по мере появления)* | Каждая сущность задаёт узел с чёткой задачей. | Соответствующая роль в «процессе» или «диаграмме». |

Спецификация задаёт **контракт** (порты, семантика входов/выходов) и ожидаемое поведение при сборке графа — аналогично тому, как в физике тип частицы или вершины задаёт, с какими другими типами она может соединяться и какой вклад даёт в амплитуду процесса.

---

## 4. Аналогия уровня с физикой (сводно)

На **фундаментальном уровне** (Philosophy, п. 4.4):

- **Abstract Base Block** ↔ **фермионы** — носители «содержимого» (параметры, тензоры, состояние).
- **Abstract Graph Node** ↔ **бозоны** — задают связи и взаимодействие (положение в графе, рёбра).

На **уровне абстрактных узлов-задач** над этим фундаментом строится следующая аналогия:

| В физике | В YggDrasil (уровень абстрактных узлов) | Смысл |
|----------|----------------------------------------|--------|
| **Типы (species) частиц** — электрон, кварк, фотон, глюон: у каждого своя роль в взаимодействиях. | **Типы узлов-задач** — Backbone, Solver, Codec, Adapter: у каждого своя задача в графе. | Не «просто фермион/бозон», а **конкретный вид** с фиксированной ролью (заряд, тип взаимодействия). |
| **Вершины в диаграмме Фейнмана** — тип вершины задаёт, какие частицы входят/выходят и какой вклад в амплитуду. | **Узел заданного типа** — тип узла задаёт порты (входы/выходы) и семантику в графе. | Граф вычисления аналогичен **диаграмме процесса**: набор вершин (узлов) и линий (рёбер), по которым «течёт» состояние. |
| **Конкретная частица** — например, электрон (реализация «заряженного лептона»). | **Конкретная модель** — например, DDIM (реализация Abstract Solver). | Одна и та же **спецификация** (задача), разные **реализации** (конкретный алгоритм, архитектура). |
| **Процесс / амплитуда** — собирается из разрешённых вершин и пропагаторов. | **Граф пайплайна** — собирается из экземпляров Backbone, Solver, Codec, Adapter по конфигу. | **Сборка целого** из типизированных элементов по правилам (совместимость портов ↔ сохранение квантовых чисел на вершинах). |

Итог: уровень абстрактных узлов-задач — это уровень **типизированных ролей** в графе, по аналогии с типизированными частицами и вершинами в физическом процессе. Каждый такой узел по-прежнему «сделан» из Block (фермионоподобное) и Node (бозоноподобное), но носитель **определённой задачи** — как частица с определёнными квантовыми числами.

---

## 5. Конкретные модели и сборка графа

- **Конкретные модели** — реализации абстрактных классов: конкретный backbone (DiT, U-Net), конкретный solver (DDIM, Heun), конкретный codec (VQGAN, AutoencoderKL), конкретный adapter (ControlNet, IP-Adapter) и т.д. В физической аналогии: **конкретные частицы данного типа** (например, электрон и мюон — две реализации заряженного лептона). Каждая модель наследует от соответствующего Abstract-класса и тем самым является и блоком (Base Block), и узлом графа с заданной задачей.
- **Граф строится из этих блоков:** узлами графа становятся экземпляры конкретных backbone, solver, codec, adapter; рёбра соединяют их порты согласно пайплайну. По аналогии: **процесс (амплитуда) собирается из разрешённых вершин и линий** — конфиг модели задаёт, какие узлы-задачи и в каком порядке входят в граф (например, через `build_model_graph`).

Уровень над фундаментом задаёт **словарь типов узлов и задач** (словарь «типов частиц» / «типов вершин»); конкретные реализации заполняют этот словарь; из них **собирается граф** («процесс»).

---

## 6. Сводная схема уровня (с физической аналогией)

```
                    Уровень над фундаментом
    ┌─────────────────────────────────────────────────────────────┐
    │  Abstract Backbone    Abstract Solver    Abstract Codec       │
    │  Abstract Adapter     Abstract Conditioner  Abstract Guidance  │
    │  Abstract PositionEmbedder   …                               │
    │                                                              │
    │  Каждый = Block (материя) + Node (идея) + Спецификация задачи│
    │  Физическая аналогия: тип частицы / тип вершины в процессе   │
    └──────────────────────────┬──────────────────────────────────┘
                                │
                наследование / реализация
                                │
    ┌───────────────────────────▼──────────────────────────────────┐
    │  Abstract Base Block (↔ фермионы)   Abstract Graph Node (↔ бозоны) │
    │  Фундаментальный уровень — Philosophy, п. 4.4                  │
    └─────────────────────────────────────────────────────────────┘
```

---

## 7. Связь с другими документами

- **Философия и фундаментальная аналогия:** [Philosophy.md](Philosophy.md) — раздел 4.4 (фермионы и бозоны), раздел 6 (уровень над фундаментом), раздел 8.6 (таблица иерархии уровней).
- **План работ:** [To_do.md](To_do.md) — этапы, в которых задействованы backbone, solver, codec, adapter и сборка графа.

Добавление новых абстрактных узлов-задач должно согласовываться с принципом двойного наследования (Block + Node), с задачей (спецификацией) узла в графе и с аналогией: новый тип узла — новый «тип частицы» или «тип вершины» в «процессе» вычисления.
