# Соответствие реализации иерархии уровней и целям проекта

Документ проверяет: (1) реализована ли в коде полная иерархия от Universe до фундаментальных блоков; (2) логична ли и согласована ли система; (3) поддерживаются ли заявленные цели: **инференс и обучение свободной диффузионной архитектуры любой модальности для любой задачи** и **свободная LLM-архитектура для любой задачи и любой модальности**. Иерархия уровней берётся из [Level_Hierarchy.md](Level_Hierarchy.md) и [Philosophy.md](Philosophy.md).

---

## 1. Соответствие иерархии уровней и кода

| Уровень (иерархия) | Сущность | Реализовано в коде? | Где в коде | Примечание |
|--------------------|----------|----------------------|------------|------------|
| **0** | Universe | **Нет** | — | В коде нет класса Universe, контейнера двух World, режима «только train». Есть только упоминание «world size» в distributed (размер мира для distributed training). |
| **1–2** | World of Ideas, World of Matter, World (Автор + Создатель) | **Нет** | — | Нет циклического графа (Author, Creator), нет двух реализаций World. Запланировано в To_do и Redesign (MASTER_PLAN, Фаза 4). |
| **3** | Автор, Создатель (каждый = граф пайплайнов) | **Частично** | `InferencePipeline`, `TrainingPipeline` работают с одним графом | Есть «пайплайн» как граф этапов, но нет сущностей Author/Creator и нет графа пайплайнов как узлов верхнего уровня. |
| **4** | Pipeline (граф этапов) | **Да** | `yggdrasil/core/graph/graph.py`: `ComputeGraph` с узлами `AbstractStage`; `add_stage`, `from_yaml` (kind: combined_pipeline); `yggdrasil/pipeline.py`: `InferencePipeline`, `TrainingPipeline` | Граф, узлы которого — этапы (Stage). Поддержка combined_pipeline в YAML. |
| **5** | Stage (базовый граф) | **Да** | `yggdrasil/core/graph/stage.py`: `AbstractStage` с внутренним `ComputeGraph`; шаблоны строят графы (denoise_step, codec и т.д.) | Один этап = один `ComputeGraph`; исполнение через `GraphExecutor`. |
| **6** | Узлы графа | **Да** | `ComputeGraph.nodes`: `OrderedDict[name, block]`; рёбра задают связи | Узел = блок, помещённый в граф по имени; «идея» узла = топология (рёбра). Отдельного класса AbstractGraphNode нет — блок в графе и есть узел (согласуется с философией «блок → узел»). |
| **7** | Уровень над фундаментом (Backbone, Solver, Codec, Adapter, …) | **Да** | `AbstractBackbone`, `AbstractSolver`, `AbstractLatentCodec`, `AbstractConditioner`, `AbstractGuidance`, `AbstractPositionEmbedder`, `AbstractAdapter`, `AbstractDiffusionProcess` в `core/model/`, `core/diffusion/`, `blocks/adapters/base.py`; все наследуют `AbstractBaseBlock`; `block_type` задаёт роль | Конкретные реализации (UNet, DiT, DDIM, VAE, CLIP, ControlNet, LoRA и т.д.) зарегистрированы через `@register_block`. Сборка графа модели: `model_graph_builder.build_model_graph(config)`. |
| **8** | Фундаментальный уровень (Block, Node) | **Да** | `yggdrasil/core/block/base.py`: `AbstractBaseBlock` (block_id, block_type, config, declare_io, process). «Node» — не отдельный класс; роль узла выполняет положение блока в `ComputeGraph` (имя, рёбра) | Логика «любой блок может стать узлом» реализована: добавление блока в граф по имени и соединение портов рёбрами. |

**Итог по иерархии:** Реализованы уровни **4, 5, 6, 7, 8** (Pipeline → Stage → узлы графа → абстрактные узлы-задачи → Abstract Base Block). **Не реализованы уровни 0, 1, 2, 3** (Universe, World, Author, Creator). Документация описывает полную иерархию; код покрывает «нижнюю» часть: от пайплайна до фундаментальных блоков.

---

## 2. Логическая связность

- **Сборка снизу вверх:** В коде соблюдается: блоки (AbstractBaseBlock) → регистрация по block_type → сборка в граф (`build_model_graph`, `ComputeGraph.add_node`, шаблоны) → этапы как графы (`AbstractStage` с внутренним графом) → пайплайн как граф этапов (`ComputeGraph` с узлами AbstractStage). Цепочка **блок → узел графа → этап → пайплайн** реализована и согласована.
- **Материя и идея:** Блок хранит параметры, тензоры, конфиг (материя); граф задаёт имена узлов и рёбра (идея). Двойственность не нарушается: исполнение идёт по графу, данные переносятся по рёбрам между блоками.
- **Разрыв:** Верхние уровни (Universe, World, Author, Creator) в коде отсутствуют, поэтому «логическая связность» полной иерархии сохраняется только в документации; в коде связь обрывается на уровне пайплайна (нет сущности «World», которая бы содержала графы Автора и Создателя).

---

## 3. Цель: инференс и обучение свободной диффузии любой модальности и любой задачи

| Требование | Статус | Где в коде / ограничения |
|------------|--------|---------------------------|
| **Свободная архитектура диффузии** | **Поддерживается** | Конфиг модели (backbone, codec, conditioner, guidance, position, adapters) → `build_model_graph`; `BlockBuilder` + `BlockRegistry` позволяют собирать произвольный граф из зарегистрированных типов. Новые архитектуры добавляются через новые блоки и регистрацию. |
| **Инференс** | **Поддерживается** | `InferencePipeline` от графа/шаблона/конфига; `ComputeGraph.run()`, `GraphExecutor`; шаблоны для image, video, audio. |
| **Обучение** | **Поддерживается** | `TrainingPipeline` от графа; возможность указывать train_nodes, freeze_nodes, train_stages. Обучение графа (или подмножества узлов) реализовано. |
| **Любая модальность** | **Частично** | **Image:** много шаблонов (SD1.5, SDXL, SD3, Flux, DiT, Kandinsky, DeepFloyd, Cascade, Flux2, Wan video и др.). **Video:** шаблоны (Wan 2.1, AnimateDiff и др.), метаданные `modality: video`, выход `PipelineOutput.video`. **Audio:** шаблоны (audio_pipelines), `modality: audio`, `PipelineOutput.audio`, `_make_noise_audio`, encodec и т.д. **3D:** в `_guess_modality` и `get_expected_io_for_modality` упоминаются "3d", "mesh", "point_cloud", но отдельных полноценных пайплайнов/блоков под 3D может не хватать — нужно уточнять по коду. |
| **Любая задача** | **Частично** | Задачи в рамках диффузии покрыты разными шаблонами и блоками: txt2img, img2img, inpainting, control (ControlNet, IP-Adapter), upscale, refiner, video generation и т.д. «Любая задача» ограничена тем, что добавление новой задачи требует новых блоков/шаблонов или конфигов — но механизм расширения есть (граф + регистр блоков). |

**Итог:** Для диффузии система в целом поддерживает инференс и обучение свободной архитектуры; модальности image/video/audio явно учтены; 3D и прочие модальности — через общий механизм (modality, IO), но могут требовать доп. блоков. Логика уровней (Stage, Pipeline, узлы-задачи, блоки) с этой целью согласована.

---

## 4. Цель: свободная LLM-архитектура для любой задачи и любой модальности

| Требование | Статус | Где в коде / ограничения |
|------------|--------|---------------------------|
| **LLM как сущность первого класса** | **Нет** | В коде нет отдельной «LLM-модели» или «Author» как графа LLM-пайплайнов. Текстовые/мультимодальные энкодеры используются **внутри диффузии** как кондиционеры (CLIP, T5, SD3 text, Qwen VL, Mistral и т.д.). |
| **Свободная архитектура LLM** | **Нет** | Нет аналога `build_model_graph` для LLM (граф слоёв/блоков LLM с произвольной топологией). Нет регистрации «LLM-блоков» как отдельного класса сущностей. |
| **Инференс/обучение LLM** | **Нет** | Нет пайплайна «только LLM» для генерации текста или мультимодального вывода как отдельного продукта (всегда в связке с диффузией как conditioner). |
| **Философия (Author = LLM)** | **Только в документации** | В Philosophy указано, что Автор в ядре — LLM; в коде сущности Author и World не реализованы, значит и LLM как Author не реализован. |

**Итог:** Поддержка **свободной LLM-архитектуры для любой задачи и любой модальности** в текущей реализации **отсутствует**. Есть использование LLM/текстовых моделей как кондиционеров внутри диффузионных пайплайнов, но нет отдельного уровня «LLM-граф / Author» с инференсом и обучением как у диффузии.

---

## 5. Сводка: что реализовано, что нет

**Реализовано и согласовано с иерархией и целями (диффузия):**

- Фундаментальный уровень: Abstract Base Block; узел = блок в графе (топология в ComputeGraph).
- Уровень над фундаментом: абстрактные типы Backbone, Solver, Codec, Adapter, Conditioner, Guidance, Position; конкретные реализации через BlockRegistry; сборка графа модели из конфига.
- Этап (Stage): AbstractStage с внутренним ComputeGraph; исполнение через GraphExecutor.
- Пайплайн (Pipeline): ComputeGraph из этапов; InferencePipeline и TrainingPipeline; combined_pipeline в YAML.
- Инференс и обучение диффузионных графов; поддержка модальностей image, video, audio; расширяемость через новые блоки и шаблоны.

**Не реализовано (но описано в философии и иерархии):**

- Universe, World (Мир идей, Мир материи), Author, Creator как сущности кода.
- LLM как отдельная сущность первого класса (Author) и свободная LLM-архитектура (граф LLM-блоков, инференс/обучение «только LLM» для любой задачи и модальности).

**Логическая связность:** В реализованной части (уровни 4–8) связность соблюдена. Полная иерархия от Universe до блоков в коде не замкнута из-за отсутствия верхних уровней и явной LLM-ветки.

---

## 6. Рекомендации

1. **Иерархия:** Зафиксировать в документации (например, в [Level_Hierarchy.md](Level_Hierarchy.md) или [To_do.md](To_do.md)), что уровни 0–3 (Universe, World, Author, Creator) на данный момент **не реализованы в коде** и являются целевой архитектурой (см. To_do, этапы Э.2 и далее).
2. **Диффузия:** Продолжать опираться на текущую реализацию (граф, этапы, блоки) для «свободной диффузии любой модальности и любой задачи»; при необходимости явно добавить 3D/другие модальности в шаблоны и блоки.
3. **LLM:** Для поддержки цели «свободная LLM-архитектура для любой задачи и любой модальности» потребуется:
   - ввести в коде сущность уровня «Author» (или аналог) как граф LLM-пайплайнов;
   - определить контракт «LLM-блок» (аналог AbstractBackbone/AbstractConditioner для текста/мультимодального вывода) и сборку графа LLM из конфига;
   - поддержать инференс и обучение такого графа отдельно от диффузии (и при необходимости интегрировать с World как в Philosophy).
4. **World/Universe:** Реализация World (циклический граф Author–Creator) и Universe (контейнер двух World, только train) — по плану To_do (доменная модель World, хранилище миров); при этом явно связать Author с LLM-графом, Creator — с диффузионным графом (уже есть).

Этот документ можно обновлять по мере появления в коде Universe, World, Author, Creator и LLM-уровня.
