# План полной переделки Yggdrasil (Master Plan)

**Цель:** полное изменение проекта Yggdrasil — кода, логики, структуры и сути — в соответствии с философией World Generator и иерархией уровней от **Universe** до **фундаментальных блоков**. Поддержка инференса и обучения **свободной диффузионной архитектуры** любой модальности и любой задачи, а также **свободной LLM-архитектуры** для любой задачи и любой модальности.

Этот документ — единая точка входа для планирования и выполнения переделки.

---

## 1. Исходные документы (не менять без согласования)

| Документ | Назначение |
|----------|------------|
| [../Philosophy.md](../Philosophy.md) | Философия: Идеальное/Материальное, Lego, Block/Node, Universe, World, Author, Creator. |
| [../Level_Hierarchy.md](../Level_Hierarchy.md) | Иерархия уровней 0–8: Universe → World → Author/Creator → Pipeline → Stage → узлы → абстрактные узлы-задачи → Block + Node. |
| [../Abstract_Nodes_Level.md](../Abstract_Nodes_Level.md) | Уровень абстрактных узлов-задач (Backbone, Solver, Codec, Adapter и др.), физические аналогии. |
| [../Graph_Stage_Level.md](../Graph_Stage_Level.md) | Stage, Pipeline, модальность, контекст, физические аналогии. |
| [../Implementation_Status.md](../Implementation_Status.md) | Что уже в коде, чего нет; разрыв по диффузии и LLM. |

Вся переделка опирается на эти документы и не противоречит им.

---

## 2. Видение после переделки

- **Полная иерархия в коде:** от уровня 0 (Universe) до уровня 8 (Abstract Base Block + узел графа). Каждый уровень представлен явными сущностями и сборкой «снизу вверх».
- **Два равноправных столпа:** (1) **Диффузия** — свободная архитектура, любая модальность, любая задача, инференс и обучение; (2) **LLM** — свободная архитектура, любая задача, любая модальность, инференс и обучение. В философии: Creator = диффузия, Author = LLM.
- **World и Universe:** World — циклический граф из двух узлов (Author, Creator). Universe — контейнер двух World (Мир идей, Мир материи), только обучение (train), без наследования и без графа.
- **Единая суть:** Lego-принцип, материя (блок) и идея (узел графа), порты и рёбра, расширяемость без переписывания ядра.

---

## 3. Принципы переделки

1. **Не отказываться от работающего низа.** Уровни 4–8 (Pipeline, Stage, узлы, абстрактные блоки, AbstractBaseBlock) уже реализованы и согласованы. Переделка их **уточняет и расширяет**, а не уничтожает: явный контракт узла, единообразие имён и сборки.
2. **Добавлять сверху вниз по иерархии.** Сначала ввести сущности уровня 3 (Author, Creator как графы пайплайнов), затем уровень 2 (World как цикл), затем уровни 1 и 0 (два World, Universe). Так код всегда остаётся согласованным с документированной иерархией.
3. **LLM — первый класс.** Ввести граф LLM-блоков (аналог build_model_graph для диффузии), пайплайн инференса/обучения для LLM, сущность Author как держатель этого графа. Кондиционеры (CLIP, T5 и т.д.) остаются в диффузии; отдельно — «чистый» LLM для текста/мультимода.
4. **Один стиль конфига и сборки.** И диффузия, и LLM собираются из конфига (YAML/словарь) в граф блоков; различие — в типах узлов и шаблонах, а не в механике.
5. **Обратная совместимость по шагам.** Где возможно — сохранять совместимость API (InferencePipeline, TrainingPipeline, from_template, from_pretrained) через адаптеры или фасады, пока старые сценарии не мигрированы.

---

## 4. Фазы переделки (порядок работ)

### Фаза 0. Подготовка (сделано)
- [x] Философия, иерархия уровней, уровень абстрактных узлов, уровень графа/этапа зафиксированы в WorldGenerator.
- [x] Implementation_Status зафиксировал разрыв между кодом и иерархией, цели по диффузии и LLM.
- [x] Создана папка Redesign и MASTER_PLAN.

### Фаза 1. Фундамент и чистота (уровни 8, 7, 6)
- [ ] **1.1** Явно ввести контракт **Abstract Graph Node** (интерфейс или абстрактный класс): имя узла, порты на уровне графа, возможность «обернуть» блок в узел. Текущая реализация (блок в `ComputeGraph.nodes`) остаётся; контракт формализует «идею» узла.
- [ ] **1.2** Убедиться, что все абстрактные узлы-задачи (AbstractBackbone, AbstractSolver, AbstractCodec, AbstractAdapter, AbstractConditioner, AbstractGuidance, AbstractPositionEmbedder) явно реализуют и Block, и Node (или единый контракт BlockAsNode). Документация уже предполагает двойное наследование.
- [ ] **1.3** Единое именование и реестр: `block_type` и роль узла (role) согласованы с [Abstract_Nodes_Level](../Abstract_Nodes_Level.md) и role_rules; при необходимости вынести константы уровней в один модуль (e.g. `yggdrasil.core.levels`).
- [ ] **1.4** Очистка: удалить остатки слотов, устаревшие алиасы, дублирующую логику; проверить, что граф — единственный способ композиции блоков.

### Фаза 2. Пайплайн и этап (уровни 5, 4) — упорядочивание
- [ ] **2.1** Зафиксировать в коде семантику **Stage** и **Pipeline** как в [Graph_Stage_Level](../Graph_Stage_Level.md): Stage = один ComputeGraph с одним контрактом; Pipeline = граф, узлы которого — только Stage (AbstractStage). При необходимости переименовать или выделить интерфейсы (IStage, IPipeline).
- [ ] **2.2** Модальность и контекст: явно передавать modality/context в метаданных графа и этапа; согласовать с оркестратором и шаблонами (image, video, audio, text, 3d).
- [ ] **2.3** InferencePipeline и TrainingPipeline: явно считать их фасадами над «графом этапов» (Pipeline); при добавлении Author/Creator они станут узлами или владельцами таких графов.

### Фаза 3. Author и Creator (уровень 3)
- [ ] **3.1** Ввести сущность **Creator**: граф пайплайнов (граф, узлы которого — пайплайны диффузии). Реализация: класс Creator, содержащий один ComputeGraph, узлы которого — Pipeline (или обёртка над InferencePipeline/TrainingPipeline). Сборка из конфига (список пайплайнов + связи).
- [ ] **3.2** Ввести сущность **Author**: граф пайплайнов LLM (граф, узлы которого — пайплайны LLM). Для этого сначала реализовать:
  - **3.2a** Контракт **LLM-блок** (аналог AbstractBackbone для LLM): блок с портами (вход текста/мультимода, выход скрытий/токенов). Реестр LLM-блоков или расширение BlockRegistry.
  - **3.2b** Сборку **графа LLM** из конфига (аналог build_model_graph): backbone-LLM, optional adapters, tokenizer/embedding — в один ComputeGraph.
  - **3.2c** **LLM Pipeline** (инференс/обучение одного графа LLM); затем **Author** = граф таких пайплайнов.
- [ ] **3.3** Общий интерфейс «граф пайплайнов»: и Author, и Creator — экземпляры одной абстракции (e.g. GraphOfPipelines) с разными типами узлов (LLM vs diffusion), чтобы дальше встраивать их в World.

### Фаза 4. World (уровни 2, 1)
- [ ] **4.1** Ввести сущность **World**: циклический граф из двух узлов — Author и Creator. Рёбра: Author → Creator (материализация идей), Creator → Author (идеализация материи). Режим выполнения: направление цикла (World of Ideas: Author→Creator; World of Matter: Creator→Author).
- [ ] **4.2** World запускается (launch) и обучается (train): вызов run по циклу с заданным направлением; обучение — по контрасту или согласованию выходов Author и Creator (по спецификации из Philosophy).
- [ ] **4.3** Две реализации World внутри Universe: WorldOfIdeas, WorldOfMatter — конфигурации одного и того же графа World с разным порядком/акцентом выполнения.

### Фаза 5. Universe (уровень 0)
- [ ] **5.1** Ввести сущность **Universe**: не наследуется ни от чего, не является графом. Хранит два экземпляра World (World of Ideas, World of Matter). Методы: только train (обучение на расхождении/согласовании двух миров). Не launch.
- [ ] **5.2** Интеграция с обучением: целевая функция или тренировочный цикл Universe описан в документации (Philosophy); реализовать в коде (train_universe или аналог).

### Фаза 6. Интеграция, API, совместимость
- [ ] **6.1** Фасады высокого уровня: если пользователь не использует World/Universe, остаётся привычный InferencePipeline/TrainingPipeline (работа с одним графом диффузии). Author/Creator/World/Universe доступны через отдельный API (e.g. `from yggdrasil.world import World, Universe`).
- [ ] **6.2** Документация кода: docstring’ы и README отсылают к уровням иерархии (Level_Hierarchy) и к Philosophy там, где это уместно.
- [ ] **6.3** Тесты: юнит-тесты на сборку графов по уровням; интеграционные тесты на Pipeline → Stage → блоки; затем на Author/Creator (моки графов), World (цикл), Universe (train).

---

## 5. Целевая структура кода (после переделки)

Ниже — желаемое размещение сущностей по пакетам. Текущую структуру не ломать одномоментно; двигаться к этому поэтапно.

```
yggdrasil/
├── core/
│   ├── block/           # Abstract Base Block, порты, реестр (уровень 8)
│   ├── node/            # (новое или в graph/) контракт Abstract Graph Node, обёртка блок→узел (уровень 6–7)
│   ├── graph/           # ComputeGraph, Stage, Executor (уровни 5, 4)
│   ├── model/           # build_model_graph (диффузия), абстракции Backbone, Codec, Solver, … (уровень 7)
│   ├── llm/             # (новое) LLM-блоки, build_llm_graph, Author-граф (уровень 3, часть)
│   └── ...
├── world/               # (новое) World, Author, Creator, Universe (уровни 0–3)
│   ├── world.py         # World (циклический граф Author–Creator)
│   ├── author.py        # Author (граф пайплайнов LLM)
│   ├── creator.py       # Creator (граф пайплайнов диффузии)
│   └── universe.py      # Universe (контейнер двух World, только train)
├── pipeline.py          # InferencePipeline, TrainingPipeline — фасады над графом этапов (совместимость)
├── blocks/              # конкретные реализации блоков (backbones, codecs, solvers, adapters, conditioners, …)
├── training/            # обучение графов, Universe.train
└── ...
```

- **world/** — новый пакет для уровней 0–3; не смешивать с «графом этапов» внутри pipeline.
- **core/llm/** — новый пакет для LLM-графа и сборки Author (если не хотим смешивать с core/model).
- **core/node/** — опционально; контракт узла можно оставить в core/graph, если там же живёт ComputeGraph.

---

## 6. Старт сейчас (первые шаги)

Выполнять по порядку; отмечать в MASTER_PLAN по мере выполнения.

1. **Зафиксировать ветку и теги.** Создать ветку `redesign` (или `world-generator-v2`); текущее состояние main пометить тегом (e.g. `v0.2.0-pre-redesign`), чтобы можно было откатиться.
2. **Фаза 1.1 — контракт узла.** В `yggdrasil/core/graph/` (или `core/block/`) ввести интерфейс/протокол GraphNode: имя, порты на уровне графа, связь с блоком. ComputeGraph при add_node принимает блок; при необходимости блок оборачивается в узел по этому контракту. Документация: узел = идея (положение, связи), блок = материя.
3. **Фаза 1.2 — абстрактные узлы-задачи.** Проверить все классы AbstractBackbone, AbstractSolver, AbstractCodec, AbstractAdapter, AbstractConditioner, AbstractGuidance, AbstractPositionEmbedder: они наследуют AbstractBaseBlock; явно реализуют ли они контракт GraphNode (если введён в 1.1)? При необходимости ввести миксин или базовый класс BlockAsNode.
4. **Фаза 3.2a — задел под LLM.** Добавить в документацию (To_do или Redesign) спецификацию «LLM-блок»: порты (input_tokens, output_hidden, output_logits), контракт. Зарезервировать в BlockRegistry префикс или пространство имён для LLM (e.g. `llm/backbone`, `llm/embedding`). Реализацию первого LLM-блока (e.g. обёртка над HuggingFace PreTrainedModel) можно запланировать на следующий спринт.

После этого переходить к Фазе 2 (упорядочивание Stage/Pipeline) и Фазе 3 (Creator, затем Author).

---

## 7. Контрольные точки

- **После Фазы 1:** весь существующий код диффузии по-прежнему работает; контракт узла и абстрактные узлы-задачи явно согласованы с Philosophy и Abstract_Nodes_Level.
- **После Фазы 3:** в коде есть сущности Author и Creator; Creator — граф пайплайнов диффузии; Author — граф пайплайнов LLM (LLM-граф и хотя бы один LLM-блок реализованы).
- **После Фазы 5:** в коде есть Universe и два World; возможен вызов Universe.train(...).
- **Конец Фазы 6:** документация и тесты покрывают иерархию; обратная совместимость фасадов (InferencePipeline, TrainingPipeline) сохранена для пользователей, не использующих World/Universe.

---

## 8. Связь с To_do и другими документами

- [../To_do.md](../To_do.md) — этапы Э.2–Э.6 (World, хранилище миров, генерация в контексте мира, модальности, API/UI) остаются в силе; Redesign реализует **архитектурную основу** (Universe, World, Author, Creator, LLM), на которой строятся хранилище миров и генерация «в мире».
- Обновлять [../Implementation_Status.md](../Implementation_Status.md) по мере появления в коде Universe, World, Author, Creator и LLM-уровня.

Этот MASTER_PLAN обновляется по ходу работ: пункты фаз отмечаются выполненными, добавляются подпункты при необходимости.
